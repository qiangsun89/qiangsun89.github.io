

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Qiang Sun">
  <meta name="keywords" content="">
  
    <meta name="description" content="一篇综述性文章-使用经典和启发式算法进行机器人覆盖路径规划的全面评估摘要移动机器人的小电池容量和工业机器人未经优化的规划效率妨碍了覆盖任务的时间效率和生产率，以速度和准确性为代价，对机器人在特定环境条件下的规划策略的可用性施加了巨大限制。因此，解决与探索和覆盖路径规划（CPP）相关的优化问题变得非常重要。通常，CPP的目标是通过减少行程时间、处理速度、能量成本和路径长度上的转弯次数，以及低重叠率来">
<meta property="og:type" content="article">
<meta property="og:title" content="一篇综述性文章-使用经典和启发式算法进行机器人覆盖路径规划的全面评估">
<meta property="og:url" content="https://qiangsun89.github.io/2023/06/12/%E4%B8%80%E7%AF%87%E7%BB%BC%E8%BF%B0%E6%80%A7%E6%96%87%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%85%B8%E5%92%8C%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E5%85%A8%E9%9D%A2%E8%AF%84%E4%BC%B0/index.html">
<meta property="og:site_name" content="知识的搬运工">
<meta property="og:description" content="一篇综述性文章-使用经典和启发式算法进行机器人覆盖路径规划的全面评估摘要移动机器人的小电池容量和工业机器人未经优化的规划效率妨碍了覆盖任务的时间效率和生产率，以速度和准确性为代价，对机器人在特定环境条件下的规划策略的可用性施加了巨大限制。因此，解决与探索和覆盖路径规划（CPP）相关的优化问题变得非常重要。通常，CPP的目标是通过减少行程时间、处理速度、能量成本和路径长度上的转弯次数，以及低重叠率来">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qiangsun89.github.io/2023/06/12/%E4%B8%80%E7%AF%87%E7%BB%BC%E8%BF%B0%E6%80%A7%E6%96%87%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%85%B8%E5%92%8C%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E5%85%A8%E9%9D%A2%E8%AF%84%E4%BC%B0/fig1.png">
<meta property="og:image" content="https://qiangsun89.github.io/2023/06/12/%E4%B8%80%E7%AF%87%E7%BB%BC%E8%BF%B0%E6%80%A7%E6%96%87%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%85%B8%E5%92%8C%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E5%85%A8%E9%9D%A2%E8%AF%84%E4%BC%B0/fig2.png">
<meta property="og:image" content="https://qiangsun89.github.io/2023/06/12/%E4%B8%80%E7%AF%87%E7%BB%BC%E8%BF%B0%E6%80%A7%E6%96%87%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%85%B8%E5%92%8C%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E5%85%A8%E9%9D%A2%E8%AF%84%E4%BC%B0/fig3.png">
<meta property="og:image" content="https://qiangsun89.github.io/2023/06/12/%E4%B8%80%E7%AF%87%E7%BB%BC%E8%BF%B0%E6%80%A7%E6%96%87%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%85%B8%E5%92%8C%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E5%85%A8%E9%9D%A2%E8%AF%84%E4%BC%B0/fig4.png">
<meta property="article:published_time" content="2023-06-12T07:46:21.000Z">
<meta property="article:modified_time" content="2023-06-12T10:03:04.571Z">
<meta property="article:author" content="Qiang Sun">
<meta property="article:tag" content="原创">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://qiangsun89.github.io/2023/06/12/%E4%B8%80%E7%AF%87%E7%BB%BC%E8%BF%B0%E6%80%A7%E6%96%87%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%85%B8%E5%92%8C%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E5%85%A8%E9%9D%A2%E8%AF%84%E4%BC%B0/fig1.png">
  
  
  
  <title>一篇综述性文章-使用经典和启发式算法进行机器人覆盖路径规划的全面评估 - 知识的搬运工</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"qiangsun89.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"LEYjQzDk7jo8uqlOQoAEF5qm-gzGzoHsz","app_key":"7bBCyINnLw0akaPjI39pESMN","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>知识的搬运工</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="一篇综述性文章-使用经典和启发式算法进行机器人覆盖路径规划的全面评估"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-12 15:46" pubdate>
          2023年6月12日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          165 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">一篇综述性文章-使用经典和启发式算法进行机器人覆盖路径规划的全面评估</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一篇综述性文章-使用经典和启发式算法进行机器人覆盖路径规划的全面评估"><a href="#一篇综述性文章-使用经典和启发式算法进行机器人覆盖路径规划的全面评估" class="headerlink" title="一篇综述性文章-使用经典和启发式算法进行机器人覆盖路径规划的全面评估"></a>一篇综述性文章-使用经典和启发式算法进行机器人覆盖路径规划的全面评估</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>移动机器人的小电池容量和工业机器人未经优化的规划效率妨碍了覆盖任务的时间效率和生产率，以速度和准确性为代价，对机器人在特定环境条件下的规划策略的可用性施加了巨大限制。因此，解决与探索和覆盖路径规划（CPP）相关的优化问题变得非常重要。通常，CPP的目标是通过减少行程时间、处理速度、能量成本和路径长度上的转弯次数，以及低重叠率来生成一个无碰撞轨迹的最优覆盖路径，这反映了CPP的鲁棒性。本文回顾了CPP的原理，并讨论了发展趋势，包括设计变体和优化算法的特点，如经典的、启发式的和最新的深度学习方法。然后，我们比较了现有CPP模型在区域和目标覆盖方面的优缺点。最后，我们总结了CPP的众多开放性研究问题，并提出了未来研究方向的建议以获得深入的见解。</p>
<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>移动机器人（如无人机、无人地面车辆、自主水下车辆、自主表面车辆）和工业机器人被广泛应用于自主区域覆盖任务，用于进行现场探索。尽管工业机器人通常通过操纵终端执行器沿预定路径达到目标位置，以覆盖指定的目标区域，但这种方法并未针对路径空间中的静态或动态障碍物进行优化。因此，自主机器人必须通过解决覆盖路径规划（CPP）问题来克服环境中的障碍物。</p>
<img src="/2023/06/12/%E4%B8%80%E7%AF%87%E7%BB%BC%E8%BF%B0%E6%80%A7%E6%96%87%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%85%B8%E5%92%8C%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E5%85%A8%E9%9D%A2%E8%AF%84%E4%BC%B0/fig1.png" srcset="/img/loading.gif" lazyload class="">
<p>CPP已成为机器人应用中的热门研究课题，包括自主清洁[1] [2]、草坪修剪[3]、结构检查[4] [5]、农业[6] [7]、监控以及勘探[8]、制图、搜索和救援等领域[9] [10]。机器人终端执行器也可以从CPP中受益，如表面处理应用（铣削[11]、激光清洗[12]、喷涂[13] [14]、熔融沉积成型打印和制造检验[15] [16]）。CPP是确定一条路径，该路径覆盖初始状态到最终状态的所有点，同时在目标环境中检测和避免障碍物 [17]。CPP算法的目标是计算出最优路径，并投射一个无碰撞轨迹，以确保机器人在一定时间内完全覆盖感兴趣区域（AOI）。首先，分解技术将AOI分解为一组子区域。然后，确定机器人的初始位置并确定每个子区域的覆盖方向。有效的优化求解器计算子区域的序列连接，以覆盖每个单元格。最后，机器人通过简单的往返运动覆盖所有子区域。CPP的概念如图1所示。CPP的鲁棒性和性能效率基于几个参数，如覆盖区域的百分比、行程时间、路径重叠率和机器人的能量消耗。</p>
<p>CPP是移动机器人探索中处理区域覆盖优化的重要组成部分。区域覆盖是指由机器人以非重叠路径完全或部分包围的区域。根据搭载传感器对周围环境的先验知识，CPP算法可以分为离线算法和在线算法[18]。离线算法允许移动机器人在静态且已知的环境中进行覆盖。CPP通常基于全局的顺序点对点覆盖，机器人在给定地图上遵循路线并避开障碍物。然而，在实践中，机器人需要处理未知或部分已知的环境。因此，更倾向于使用在线算法，其中探索策略在机器人移动、执行、操作和观察障碍物位置时发生变化，以在感兴趣区域内探索未知区域。机器人将通过从本地传感器获取实时数据，并从动态环境中提取出显著特征来解决适合的路径。最后，机器人必须使用CPP技术创建对探索环境的有限映射[21]。</p>
<p>在过去的十年中，Galceran和Carreras [18]对机器人学中的CPP进行了综述。他们对环境建模的文献进行了调研，这些文献基于各种表面分割方法来解决CPP问题，包括细胞、基于网格和基于图的方法，分别适用于2D和3D结构。最近几年的文献综述包括多机器人CPP用于模型重建和建图[19]，以及无人机的综述[20]。过去的综述论文与本次综述的不同之处在于后者在优化准则方面进行了全面而最新的研究。在本综述文章中，对CPP进行了广泛的综述，主要关注用于解决优化问题的经典和启发式算法。无碰撞路径、覆盖成本函数（最短路径和平滑路径）以及覆盖顺序（集合覆盖问题和旅行商问题）与CPP问题直接相关，这取决于优化问题的解决程度。此外，还没有文献综述涉及使用深度强化学习方法解决CPP问题。我们相信，本综述将全面了解机器人学中的CPP，包括设计变体、优化算法的特点以及各种技术特征，如搜索时间、路径最优性、动态性能、收敛速度和计算复杂度。</p>
<img src="/2023/06/12/%E4%B8%80%E7%AF%87%E7%BB%BC%E8%BF%B0%E6%80%A7%E6%96%87%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%85%B8%E5%92%8C%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E5%85%A8%E9%9D%A2%E8%AF%84%E4%BC%B0/fig2.png" srcset="/img/loading.gif" lazyload class="">
<p>本文对CPP技术进行了综述。接下来的部分将按照以下方式进行。第二节介绍了CPP的目标以及与平台、环境和路径最优性相关的具体挑战。接下来的第三节介绍了基于各种经典和启发式算法的最新CPP发展情况。现有的综述与覆盖效率问题和性能度量相关。第四节分析和总结了各种CPP算法的应用，包括其优点和缺点，并讨论了CPP中的开放问题，为未来的研究提供方向。最后，第五节对本文进行了总结。本文的组织结构如图2所示。</p>
<h2 id="二、CPP中的挑战"><a href="#二、CPP中的挑战" class="headerlink" title="二、CPP中的挑战"></a>二、CPP中的挑战</h2><p>在机器人学中，CPP仍然是一个开放性问题，需要改进规划最优路径以覆盖目标区域的效率，并生成一个计算量较小的无碰撞路径。生成的覆盖路径应该是最优的，以确保最小的后勤成本，如重叠、转弯次数、行程时间和能量消耗。CPP问题包括潜在的不确定性失败、复杂环境中的未知障碍物和路径最优性，这被认为是机器人学中的主要挑战。图3展示了CPP问题的目标、挑战和设计特点的概述。</p>
<img src="/2023/06/12/%E4%B8%80%E7%AF%87%E7%BB%BC%E8%BF%B0%E6%80%A7%E6%96%87%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%85%B8%E5%92%8C%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E5%85%A8%E9%9D%A2%E8%AF%84%E4%BC%B0/fig3.png" srcset="/img/loading.gif" lazyload class="">
<p>在许多研究中中，已经提出了使用单个机器人进行区域覆盖的方法，其中只有一个自主车辆在小范围内执行简单任务，如清洁房间。在更广泛的区域覆盖情况下，机器人可能因故障和潜在故障（例如机械或电子故障、传感器和执行器故障、电池耗尽）而导致任务未完成。因此，许多研究人员致力于通过部署多机器人系统来提高区域覆盖的效率。多机器人覆盖相对于单个机器人具有更显著的优势，可以最小化运行时间并增强CPP的鲁棒性[22]。然而，开发多机器人的CPP技术仍然具有挑战性，因为它必须解决许多CPP约束在复杂和大规模的环境中。</p>
<p>同时，有限的感知能力和通信瓶颈是处理多机器人系统定位故障时必须应对的重要因素。因此，分布式控制网络系统通过集中式或分散式方法进行广播，以避免在这种限制下的可扩展性问题[23]。此外，团队机器人的战略韧性同样重要，邻近机器人在机器人故障的情况下可以接管重新规划任务，以填补功能间隙。不适当的任务调度也可能导致空闲问题。具体来说，协调和任务分配是多机器人区域覆盖中的核心问题，高度依赖于每个机器人的位置。因此，CPP的效率高度依赖于协调和任务分配策略，努力最小化总覆盖时间并平衡每个机器人的工作负载。最后，与单个机器人相比，多机器人系统能够提供系统冗。</p>
<p>在机器人学中，风、波浪和水下水流等环境因素仍然被认为是CPP的巨大挑战。UAV、AUV和以人为中心的智能机器人等车辆在受到环境条件的物理影响以及人体运动的影响时，在采集数据时必须在一个位置稳定自己[25]。除了与外部力量相抗衡外，避开障碍物也是一种常见的做法，以防止车辆在物理碰撞中受到物理损害。对于大规模环境（特别是多机器人系统）的CPP，通常是一种离线规划算法，因为受限于板载传感器和电池容量的限制。通常，由于运动学和动力学约束的复杂性，许多机器人的CPP技术仅考虑二维（2D）工作空间。这限制了机器人在三维（3D）空间覆盖方面的能力，特别是在水下环境中[26]。尽管2D模型简单且只需要少量计算，因此许多研究在表面的横截面上创建了一个2D模型，忽略了3D建模中的高度信息，因为大多数机器人可以执行2D特定区域的覆盖任务。然而，在人工2D工作空间中，CPP问题的重要方面是传感器足迹沿扫描路径的重叠覆盖。在现实中，当UAV或AUV在非平面表面（表面坡度较大）上覆盖感兴趣区域（ROI）时，固定深度处的高度会发生变化。当环境事先已知时，细胞分解是将区域分割成较小子区域的最简单方法，可以是规则的网格单元或多边形形状[27]-[29]。在三维空间中的CPP主要集中在目标覆盖，以覆盖关键的ROI，以评估结构（3D模型）的质量。通过生成视点并优化访问视点的顺序，可以实现目标区域的有效覆盖。然而，大多数研究工作只关注具有光滑表面的3D目标（对粗糙表面或隐藏表面的兴趣较小）</p>
<p>路径最优性与最短覆盖路径或旅行商问题（TSP）有关，通常是指通过多个感兴趣区域以最小的行程成本访问所有点的路径规划。因此，解决CPP问题面临着重大挑战，因为TSP和CPP问题都是NP难问题[31]。许多集成了TSP和CPP研究的目标是通过TSP求解器找到一组区域的访问顺序，并以来回方式规划最优路径以完全覆盖所有子区域[32]-[34]。因此，需要关注局部和全局覆盖路径的连接来解决集成TSP和CPP问题，包括每个感兴趣区域内的覆盖路径、子区域内的访问顺序以及进出路径。此外，在三维表面中，单个或多个机器人通常通过视场角规划生成一组视点，以覆盖目标表面区域，并找到无碰撞的最短路径以访问所选视点[35]，[36]。基于模型的视角规划问题通常被视为集合覆盖问题（SCP），其目标是减少视点数量，然后使用TSP或多TSP来解决路径规划问题[23]。因此，CPP路径最优性的挑战是最小化覆盖路径上的总行程时间并减少转弯成本。</p>
<h2 id="三、相关算法"><a href="#三、相关算法" class="headerlink" title="三、相关算法"></a>三、相关算法</h2><p>CPP算法可以分为两种方法，经典算法和基于启发式的算法。根据算法的特征，CPP算法的摘要细节如图4所示进行分类。值得注意的是，基于采样的规划和生物启发算法是解决CPP问题的热门研究课题。现有文献中有十个重点，包括随机行走、混沌覆盖路径规划器、生成树覆盖、人工势场、基于采样的规划算法、动态规划、贪婪搜索和图搜索算法、进化算法、以人为本的算法以及其他经典启发式算法。</p>
<img src="/2023/06/12/%E4%B8%80%E7%AF%87%E7%BB%BC%E8%BF%B0%E6%80%A7%E6%96%87%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%85%B8%E5%92%8C%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E5%85%A8%E9%9D%A2%E8%AF%84%E4%BC%B0/fig4.png" srcset="/img/loading.gif" lazyload class="">
<h3 id="A-随机行走"><a href="#A-随机行走" class="headerlink" title="A. 随机行走"></a>A. 随机行走</h3><p>随机行走（Random Walk，RW）是描述动物在尝试扫描和探索未开发区域时的搜索模式或移动的随机过程[37]。对于环境探索和覆盖，已经研究了不同变体的随机行走[38]，[39]。基于随机行走的区域覆盖有两种方法，即固定线性方法和可变步长方法。固定线性方法中，机器人随机转动一定角度，并经常沿直线移动，直到与墙壁或障碍物边界发生碰撞。Hasan等人[40]在清洁系统中引入了涉及随机行走、螺旋运动、曲线运动和墙随从的CPP算法。Liu等人[41]提出了一种在线随机覆盖方法，提高了覆盖率。然而，为了确保机器人覆盖整个区域，可变步长方法根据机器人所采取的步长的概率分布计算一组随机行走方向。</p>
<p>可变步长方法在协作移动机器人群系统中很受欢迎，包括布朗运动（Brownian Motion，BM）[42]和莱维飞行（Lévy Flight，LF）[43]。基于BM的机器人重复以给定分布（如高斯或von Mises [44]）的步长移动，并随机转向。相反，基于LF的机器人行进的距离取决于莱维概率分布[45]。BM的步长具有有限方差，而LF的步长具有无限方差。因此，与LF相比，BM具有更高的目标密度（局部行走）和短程移动。Martinez等人[46]提出了一种使用基于BM的随机行走的群体机器人来增强区域覆盖的方法。每个机器人被视为一个通过环境中的信号控制运动的粒子。在[47]中，利用基于信息素的通信[48]来控制多个机器人，并实施LF搜索策略以提高在未知环境中的搜索和覆盖效率。而[49]提出了梯度跟随与LF方法相结合，利用虚拟信息素模型进行控制，以在区域覆盖中提供更好的性能。</p>
<p>随机行走方法的主要优势在于平台不需要定位传感器。机器人只需要简单的板载传感器来感知和检测区域的边界以进行障碍物避免。因此，由于算法简单且内存要求较低，该方法非常灵活和易于部署。然而，在存在障碍物的情况下，随机行走路径仅适用于小环境，很难覆盖所有区域。机器人可能会多次穿过相同的路径，导致整体路径效率低下。</p>
<h3 id="B-混沌覆盖路径规划器"><a href="#B-混沌覆盖路径规划器" class="headerlink" title="B. 混沌覆盖路径规划器"></a>B. 混沌覆盖路径规划器</h3><p>混沌覆盖路径规划器是一种确定性技术，它利用混沌系统基于混沌运动生成覆盖轨迹。混沌覆盖路径规划器通过机器人的运动轨迹在整个工作空间中保证高覆盖效率，从而实现更快的覆盖。该系统还可以通过在边界上实现最高覆盖率而无需进行障碍物避免来执行监视任务[51]，因为运动是预先确定的。Arnold的动力系统是一个众所周知的混沌系统，最初由Sekiguchi和Nakamura引入[50]。通过将混沌动力学变量与移动机器人的运动学方程组合设计和构建控制器，以构建混沌运动的覆盖路径规划器。</p>
<p>在三维非线性混沌系统的情况下，洛伦兹动力系统和Chua电路与Arnold动力系统相似。在[52]中，利用超混沌技术和非线性开环控制器，洛伦兹系统加速了工作空间的覆盖，相比Arnold系统和随机行走具有良好的混沌特性[53]，[54]。移动机器人中使用的Chua模式也提供了更好的覆盖性能[55]，[56]。基于Chua电路、洛伦兹系统和多个滚动吸引子的混沌吸引子随机数生成器已经在CPP中提出[57]。Nasr等人[58]利用多滚动Chua混沌镜像映射方法确定低成本的覆盖路径。</p>
<p>标准（Taylor-Chirikov）映射和Logistic映射分别是二维迭代映射和一维迭代映射的离散时间动力系统模型。Volos等人[59]，[60]设计了一个混沌Logistic映射随机比特生成器，用于生成移动机器人的覆盖轨迹。角度变换可以进一步改善覆盖路径规划器的均匀性[61]。而[62]采用伪随机比特生成器与反信息素方法相结合，在提供更高的覆盖率的同时，实现了更低的内存需求。在标准映射的情况下，[63]提出了使用不连续控制法对地形进行覆盖。而[64]，[65]则提出了一种融合策略，通过大区域和小区域之间的迭代周期以及与标准映射相对应的映射（仿射变换）实现覆盖。同时，Liet al.[66]采用了一种具有类似仿射变换技术的二维切比雪夫映射进行混沌CPP。</p>
<p>大部分混沌CPP运动以不可预测的随机、少量的步骤进行探索和监视任务，与随机行走相比，在未知环境中提供了更快的扫描，因为随机行走不是连续的[67]。因此，混沌CPP的连续运动使机器人能够有效地搜索和找到目标，并具有更均匀的覆盖密度。然而，现有文献只强调了覆盖率，忽略了覆盖时间的成本。机器人的不可预测轨迹也在很大程度上取决于机器人的运动学运动，受到运动学约束的影响，因此需要进行研究。</p>
<h3 id="C-基于生成树覆盖（Spanning-Tree-Coverage，STC）"><a href="#C-基于生成树覆盖（Spanning-Tree-Coverage，STC）" class="headerlink" title="C. 基于生成树覆盖（Spanning Tree Coverage，STC）"></a>C. 基于生成树覆盖（Spanning Tree Coverage，STC）</h3><p>基于生成树覆盖（Spanning Tree Coverage，STC）的CPP算法将工作空间划分为一系列不相交的有限单元，可以使用基于单元分解的方法或基于网格的方法进行划分[68]，[69]。然后，在相应的巨型单元中构建图的生成树，将其分为四个子单元，其中相应单元的大小等于机器人的大小。该算法通过使用树遍历算法（如深度优先搜索）找到最优路径，使机器人能够覆盖每个未占用的单元。然而，如果整个巨型单元内的障碍物占据了子单元，机器人将无法覆盖该巨型单元。在[70]中，作者提出了一种全覆盖STC算法，机器人可以覆盖自由子单元以最大化区域覆盖。STC已经扩展到针对多机器人系统的在线策略，以增加覆盖效率[71]，[72]。然而，机器人的行进路径取决于每个机器人的初始位置，并可能导致机器人之间的回溯问题。机器人遭受高重叠率的影响，严重损害能源效率。Kapoutsis等人[73]提出了一个区域划分算法，关注机器人的初始位置，以在矩阵条件下实现最优单元分配。在每个划分空间中构造最小生成树以实现任务的平衡分配。然而，该方法无法处理通过自由子单元的情况，即单元被障碍物占据，特别是在沿同一轴放置机器人的情况下。在[74]中，工作空间根据层次四叉树结构划分为不同的单元大小，然后通过考虑不同的边长构建生成树。这种方法可以最小化重复覆盖并平衡任务分配，但会导致单元的过度细分，增加任务成本。</p>
<p>Gao和Xin [75] 提出了基于拍卖和竞标过程的STC算法，用于解决多机器人CPP问题。在[76]中，构建了一个伪STC以创建虚拟边，假设障碍物占据了巨型单元。墙跟随算法使机器人能够沿着障碍物边界通过子节点移动。同时，Pham等人[77]改进了算法，通过在建立C空间边界轮廓时考虑部分被障碍物占据的巨型单元，以寻找最优路径，重点是减少回溯并增加覆盖率。路径通过逆时针方向的生成树边规划，以找到下一个未访问的巨型单元。在下一个部分被障碍物占据的巨型单元的情况下，机器人沿着C空间边缘移动并返回到父节点。实验结果表明，与全覆盖STC方法相比，所提出的算法实现了较高的覆盖率。类似地，[78]提出了基于次要节点之间的连通性的邻接图结构，以使机器人能够覆盖部分被障碍物占据的巨型单元。通常，基于机器人的在线CPP需要提供感知反馈，导致大量的能源消耗。因此，[21]提出了一种混合CPP算法，通过将基于边界的探索和STC算法结合起来，提高能源效率，无需扫描仪的辅助。</p>
<p>在最新的研究中，大多数基于多机器人的STC算法依赖于集中式控制技术，涉及通信和任务分配。传感器信息显著增加了计算和存储复杂性。当中央控制代理发生故障时，这可能导致系统故障。Dong等人[79]提出了一种基于分散策略的人工加权STC，以分布式方式执行覆盖任务。每个机器人承担的任务被平均分配，如果机器人发生故障，算法可以重新生成STC路径。因此，在机器人故障的情况下，系统可以确保完成覆盖任务。然而，路径重新规划器可能忽略了正在运行的机器人负担的任务，导致不平衡的工作负载问题。容错性在实际情况下仍然是一个重大挑战。</p>
<h3 id="D-动态规划"><a href="#D-动态规划" class="headerlink" title="D.动态规划"></a>D.动态规划</h3><p>动态规划（DP）是一种通过将复杂问题递归地划分为一组简单子问题，并将所有子问题的结果重新组合以获得解决方案的方法。在CPP中，DP问题展示了重叠的子问题和最优子结构，基于距离矩阵来优化全局覆盖子空间的顺序[81]。在[82]中，DP和TSP约减可以通过贪婪构造一组段落和连接所有段落来寻找最短覆盖路径并最小化转弯次数。DP框架在[83]中被开发用于优化感兴趣区域内的覆盖重叠。Coombes等人[84]采用自底向上的策略来节省内存空间并加速解组合过程。DP已被用于解决CPP中的TSP问题，通过全局规划找到依次覆盖所有区域的最短路径[33]。然而，由于问题规模巨大，生成的路径可能不是最优的。因此，[34]提出了基于最近邻或基于遗传算法（GA）的2-Opt算法来解决多区域问题，并通过基于DP的精确方法进一步优化路径。Cheng等人[85]根据形态层和条带层的集合引入了环境的图模型，需要将每个条带层的成本计算存储在DP中，并开发重新计算的预防措施以加快计算速度。然而，机器人不能适应复杂的动态环境。Ghaddar和Merei [86]提出了一种利用DP的在线CPP算法，以提高适应性和能量效率方面的性能。</p>
<h3 id="E-人工势场（Artificial-Potential-Field，APF）"><a href="#E-人工势场（Artificial-Potential-Field，APF）" class="headerlink" title="E. 人工势场（Artificial Potential Field，APF）"></a>E. 人工势场（Artificial Potential Field，APF）</h3><p>人工势场（Artificial Potential Field，APF）算法通常用于当机器人朝着目标位置移动时检测障碍物。在周围的障碍物和目标周围分别创建了虚拟的斥力和吸引力，以确保机器人在实现目标的同时保持与障碍物的距离[87]。Sutantyo等人[88]采用LF算法来探索未知环境。通过添加APF技术增强了分散效果，产生了机器人之间的斥力。在[89]中，当传感器检测到表面缺陷时，通过根据人工势计算成本来重新规划覆盖路径。然而，由于APF方法存在局部最优问题，机器人可能无法逃离死区。因此，Wei等人[90]通过将APF和粒子群优化（PSO）算法相结合，通过优化粒子的速度和位置来实现检查策略，从而克服了局部最优问题。Wang等人[91]介绍了基于信息增益和路径成本的势场，机器人可以找到优化的轨迹以避免陷入局部最小值。在[92]中，作者通过在网格环境中引入种子的概念改进了APF算法，用于CPP。可以根据环境地图生成不同类型的路径种子来覆盖区域。Huang等人[93]利用APF方法通过多机器人系统的编队控制来覆盖区域。仿真结果表明，该方法实现了更好的区域覆盖和实时规划。在特定情况下，例如机器人通过狭窄空间，机器人可能无法到达目标。因此，Jiang和Deng [94]通过修改斥力势函数改进了APF算法，以有效避免检查任务中的障碍物。尽管有大量的研究工作，但在多个机器人同时访问目标并进行碰撞避免规划方面仍存在不足。</p>
<h3 id="F-采样规划算法（Sampling-Based-Planning-Algorithms）"><a href="#F-采样规划算法（Sampling-Based-Planning-Algorithms）" class="headerlink" title="F.采样规划算法（Sampling-Based Planning Algorithms）"></a>F.采样规划算法（Sampling-Based Planning Algorithms）</h3><p>采样规划算法（Sampling-Based Planning Algorithms）是一种传统的算法，用于解决规划问题中的覆盖问题[95]，[96]。最近，概率采样规划（SBP）算法被用于启发式地和最优地解决复杂的规划问题。一般来说，该算法通过使用节点采样策略（在搜索环境中随机生成一组节点）将环境从配置空间映射。SBP的概率完备性对于在探索方面优化基于传感器（视觉）的检测是有效的。基于SBP的规划器包括概率路网图（Probabilistic Roadmap，PRM）[97]和快速探索随机树（Rapidly Exploring Random Tree，RRT）[98]。</p>
<h4 id="1-概率路网图（Probabilistic-Roadmap，PRM）"><a href="#1-概率路网图（Probabilistic-Roadmap，PRM）" class="headerlink" title="1.概率路网图（Probabilistic Roadmap，PRM）"></a>1.概率路网图（Probabilistic Roadmap，PRM）</h4><p>PRM规划器是一种通过建立路网图在配置空间中创建路径的规划和查询过程[99]。规划阶段在机器人的配置空间中随机生成节点，并连接这些节点对以直线方式形成一个路网，确保不穿越障碍物。然后，查询阶段利用规划阶段的结果，在初始配置和目标配置之间规划一条路径[100]。Dias等人[101]在地震情况下采用基于格点的PRM进行搜救任务。PRM广泛应用于通过结合A<em>算法等搜索算法来优化路径和避障。在[102]中，利用PRM和A</em>算法分别生成了工业机器人的无碰撞路径和最优顺序路径，模拟结果表明该算法可以通过添加TSP求解器来减少周期时间。然而，PRM方法由于节点的随机放置，使得机器人的覆盖区域在边界和障碍物附近有限。当发生障碍物碰撞时，PRM会移除相应的节点和边。此外，尽管PRM具有大量节点的概率完备性的优点，但也可能导致高复杂度和计算时间的问题。</p>
<h4 id="2-快速探索随机树（Rapidly-Exploring-Random-Tree，RRT）"><a href="#2-快速探索随机树（Rapidly-Exploring-Random-Tree，RRT）" class="headerlink" title="2.快速探索随机树（Rapidly Exploring Random Tree，RRT）"></a>2.快速探索随机树（Rapidly Exploring Random Tree，RRT）</h4><p>RRT算法是一种高效的搜索规划器，采用增量技术和树形结构，在自由或障碍物配置空间中构建图形以进行搜索和探索[103]。该算法旨在有效地在高维空间中进行搜索，并处理动力学规划问题。与PRM相比，RRT对于单一查询问题更快，因为算法在学习阶段不需要对采样配置进行路网构建[1034]。Zaheer等人[105]分析认为，与PRM相比，RRT在计算时间和路径平滑性方面具有更好的性能。同时，[106]提出了在初始树和目标树之间进行双向搜索的方法，以快速相互生长，使两个树连接并生成最短路径以进行均匀搜索。然而，基于RRT生成的路径在解决规划问题时不一定是最优的。改进的RRT变种称为RRT<em>，可以通过提供渐近最优解来改善路径质量[107]。Englot和Hover [35]基于基于采样的方法提出了一个解决覆盖采样和多目标规划问题的CPP算法。覆盖采样问题确定提供保证覆盖的最小视图集。然后，多目标规划问题确定访问所有视图的较短路径。该方法使用RRT算法渐近地找到全局最优解，以改善可行的覆盖路径。类似地，[108]提出了一种基于树形的快速探索随机树算法，用于实时三维重建的最优覆盖路径查找。元树结构包含多个子树，每个子树根据自己的RRT规划器进行每次迭代生长，以提供完全的可见性。然而，该算法需要大量的内存来存储树中的节点，导致计划成本较高。因此，基于两级算法的最优CPP算法被用来减少内存需求并生成最短的覆盖路径[109]。多方向固定节点的RRT</em>算法用于通过探索邻域生成每个兴趣点（POI）的最小成本轨迹规划，从给定的初始点到目标点。然后，使用遗传算法（GA）来找到访问一系列POI的最短路径，解决TSP问题，并返回到初始点。类似地，[110]利用增量随机检查路网搜索优化构建图中的POI数量根据RRT算法，树结构被迭代生成，构建了一个包含一部分兴趣点（POIs）的路线图。然后，使用适当的图搜索算法计算覆盖所有POIs的最短路径。该方法旨在通过限制内存大小（树中节点数量）来最小化覆盖规划时间，这在研究[109]和[110]的结果中得到证明。Faghihi等人[111]提出了随机运动规划检测树（RKIT）算法，将CPP问题和运动规划问题进行了整合。在3D模型结构中，起始点和目标点分别位于正面和背面的中心位置。然后，对结构进行重新建模，创建了几个假设的立方体，其尺寸与正面（或背面）和传感器覆盖的尺寸相关。路径创建模块计算出对应于关键点（如外螺旋路径、螺旋螺线路径和内螺旋路径）的中间点。算法利用RKIT算法在每次迭代中使用给定区域中中间点的坐标进行采样。还采用了一个转向函数来有效处理微分约束。作者证明了该算法在识别3D结构的覆盖计划方面的可行性。然而，该研究未包括在存在静态和动态障碍物的情况下的模拟结果。</p>
<p>最近发展的RRT算法在搜索时间和路径成本（更短、更平滑的路径）方面取得了突破。然而，较少的相关研究涉及当机器人执行覆盖任务时的狭窄通道问题。因此，未来通过使用RRT变种（优化接近困难区域的区域覆盖）在狭窄的非结构化环境中穿越障碍物将是一个有趣的研究课题。</p>
<h4 id="3-视角规划和运动规划"><a href="#3-视角规划和运动规划" class="headerlink" title="3.视角规划和运动规划"></a>3.视角规划和运动规划</h4><p>除了基于传感器的规划方法[112]、[113]之外，基于采样的视角规划方法[114]、[115]也是解决优化问题的另一种方案，需要同时进行视角规划和运动规划任务[116]、[117]。视角规划主要应用于建模应用和探索任务[118]。传感器对于使机器人视觉系统能够处理视角规划问题和目标覆盖的CPP问题至关重要。SCP和TSP分别解决了覆盖整个目标结构和视角的最小集合问题[119]、[120]。然后，规划算法的变体解决了覆盖规划问题，例如贪婪策略、最优策略或分解规划器[36]。在解决在线CPP问题时，大多数研究采用了最佳下一个视角（NBV）方法[121]，用于解决合适的视角选择，其中视角规划基于当前机器人位置和从传感器获取的信息。机器人的内置传感器在规划器生成视角之前探索和感知目标区域，以重建结构模型[122]、[123]。</p>
<p>同时，[115]提出了一种结构检测规划器（SIP），通过实现Lin-Kernighan-Helsgaun（LKH）算法[124]来优化视角姿势的路径。Palomeras等人[125]采用概率分析来计算效用，引入了NBV规划器。Osswald等人[126]利用逆可达性图和NBV算法，通过过滤可能的视角候选项，改善了机器人姿势和视角规划问题。Ardiyanto和Miura[127]基于多边形搜索和骨架化技术提出了一种可见性覆盖方法，用于生成覆盖视角，并进一步改进视角规划器以最小化机器人移动的能耗，从而保持对移动目标的可见性[128]。然而，如果发生遮挡，机器人可能无法跟踪目标。</p>
<p>顺序视角是视角规划问题的一部分，需要在三维环境中建模信息增益，例如使用体素[129]或表面网格[130]进行NBV规划。Wu等人[131]提出了基于学习的NBV方法，通过沿着体素进行射线投射，估计一组体素来计算下一次扫描的最佳视角。逆运动学求解器通过使用机载传感器和视角之间的相对位置校准，计算避免碰撞并找到良好的视角顺序[131]，[132]。Mansouri等人[133]，[134]利用结构运动方法重建目标区域，生成高质量的三维覆盖地图数据。与激光或测距扫描相比，该方法具有成本效益。同时，[135]提出了基于结构运动的多视角相机在CPP中的应用。Meng等人[136]利用基于Octomap结构[137]的概率体素图构建三维模型，并利用信息增益选择边界视角来解决TSP的变种问题。Paratama等人[138]提出了一种搜索空间CPP算法，以最大化航点的信息增益，并根据Octomap计算每个航点的熵来构建启发式代价函数。实验结果表明，与SIP、带RRT的LKH和带欧几里得启发式的LKH方法相比，所提出的算法能够提供更高的覆盖百分比。</p>
<p>大多数研究侧重于大型未知搜索空间，而忽视了信息较少的区域，导致结构模型不准确和不完整，忽略了全局路径，并导致路径重叠较长。因此，大多数研究者在滑动视角规划方法方面进行了研究，包括NBV规划器和探索规划器，利用RRT或RRT*算法探索未知环境[122]，[139]-[141]。优化过程在下一次迭代中重复进行，只执行第一个视角，并根据最佳视角选择路径。然而，由于有限的前瞻感知范围，机器人往往陷入次优的死胡同。因此，Jung等人[142]引入了多层次CPP技术，将三维模型结构分为几个层次，并在每个层次中重新采样视角以获得局部路径，然后将所有层次连接起来进行全局覆盖。Oleynikova等人[143]引入了在线局部重新规划，通过采用中间目标选择策略来最大化探索增益。在未知的室内环境中提供无碰撞的探索路径是具有挑战性的，因为室内环境通常具有狭窄且大规模的空间。因此，[144]，[145]提出了局部和全局探索技术的组合，利用基于采样的算法和边界探索。类似地，Almadhoun等人[146]提出了在边界和自适应网格视角生成器之间切换的方法，以提高局部极小值避免和效用函数质量。然而，特定区域的高覆盖密度会增加路径的成本。因此，Schmid等人[147]研究了信息增益和成本形式对于在效用函数中处理收益和成本之间的平衡的潜在影响。为了提高目标覆盖的完整性，[147]，[148]引入了一种信息采样算法，通过使用在线方法最大化全局覆盖和轨迹的效用值，并通过使用流式集覆盖算法减少采样范围。</p>
<p>此外，Jing等人[149]提出了一种新的CPP框架，包括视角生成、路径原语生成、可见性估计、原语覆盖图编码和覆盖图搜索。通过对均匀迭代适应性的计算，根据RRT*的点对点连接在高保真度网格模型中生成视角，以实现完全覆盖。基于Voronoi的重新网格算法对结构的网格模型进行下采样，以改善具有保证覆盖的检查路径。Glorieux等人[15]提出了一种针对性的视角采样策略，结合了SCP和TSP。自适应差分进化算法可以优化最佳的下一个视角，同时使用RRT进行碰撞避免。结果显示，与贪婪近似方法相比，检查周期时间和行程成本分别减少了23.8%和22.7%。然而，大多数现有的采样算法无法在高维搜索空间中生成准确的地图。因此，Hou等人[151]利用Gibbs采样技术（马尔可夫链蒙特卡洛）通过使用NBV算法对样本空间进行分解来生成准确的占据地图，以估计每个体素的条件概率进行3D表面重建。通过同时使用CPP算法和NBV，覆盖比例可以进一步提高，可以实时规划以通过应用蒙特卡洛树搜索来最大化信息增益。</p>
<p>在视角规划和覆盖规划中，有许多先前的研究致力于优化问题，以提高覆盖效率并确保视角规划器的质量。对高几何精度的高需求也导致算法的计算复杂性增加。因此，在模型质量（完整性和准确性）和计算时间之间仍然很难取得平衡。此外，在大规模空间中实时应用的可行性是一个复杂的任务，值得未来的研究。</p>
<h3 id="G-贪婪搜索和图搜索算法"><a href="#G-贪婪搜索和图搜索算法" class="headerlink" title="G. 贪婪搜索和图搜索算法"></a>G. 贪婪搜索和图搜索算法</h3><p>贪婪算法是一种众所周知的启发式方法，通过在每一步选择中选择一个可用的选择，一旦选择被确定，就不会在后续步骤中改变选择，来构建解决方案来解决优化问题。该算法通常通过做出局部最优选择来寻找最佳选择，以获得全局最优解。贪婪算法（例如Dijkstra算法）简单易实现，通常速度较快，但由于其短期解决方案的特性，不能保证找到全局最优解。图搜索算法，例如A算法、D算法和Theta*算法通常结合牛轭运动或螺旋图案来规划和优化覆盖路径。搜索算法在图中找到从当前盲区位置到未覆盖区域的最短路径，当机器人陷入盲区或遇到障碍物时，重新规划路径以确定机器人的下一个位置以避开盲节点；否则，如果没有检测到障碍物，机器人将继续沿着之字形或螺旋路径行动。这些任务重复进行，直到感兴趣区域完全覆盖。<br>因此，搜索算法对于解决覆盖路径规划问题和提高搜索效率非常重要。然而，在大型网格地图中进行路径搜索仍然具有挑战性，因为计算成本很高。</p>
<h4 id="1-深度优先搜索和广度优先搜索算法"><a href="#1-深度优先搜索和广度优先搜索算法" class="headerlink" title="1.深度优先搜索和广度优先搜索算法"></a>1.深度优先搜索和广度优先搜索算法</h4><p>深度优先搜索（DFS）和广度优先搜索（BFS）是基于图数据结构的递归算法用于搜索节点。这两个算法在时间复杂度方面都表现良好，但每个算法都有其缺点。DFS在无限深度空间中无法运行，并且不能保证找到最优解（最短覆盖路径），而BFS由于搜索空间中的高分支因子而消耗大量内存空间。DFS通过优化序列路径来最小化重叠和减少转向次数来优化覆盖路径。Kabir等人利用DFS技术生成一系列设置来创建清洁轨迹。然而，由于多个自由度，机器人相对复杂且计算量较大。Barrientos等人提出了一种基于BFS技术的波形规划器，可以应用于基于网格的工作空间，生成具有最少转向次数的覆盖路径。Wang等人提出了一种CPP方法，通过使用BFS算法来减少未覆盖区域。然而，该方法会导致未覆盖的边缘，机器人可能无法在角落进行操作。在一个知识推理与BFS相结合的机器人CPP中，通过避免不确定环境下的动态障碍物，降低了重复率和计算时间。Miao等人提出了一种使用子地图分解和BFS方法的分布技术。该技术将未知地图分解为几个子区域，并通过螺旋模式将每个机器人分配到最近的子区域进行覆盖。在小图的情况下，DFS和BFS算法都可以有效地优化覆盖路径。</p>
<h4 id="2-Dijkstra算法"><a href="#2-Dijkstra算法" class="headerlink" title="2.Dijkstra算法"></a>2.Dijkstra算法</h4><p>Dijkstra算法是一种广义的图搜索技术，用于解决单源最短路径问题，其中边的权重为非负数。该算法通过根据每个邻接顶点的成本函数从起始节点开始访问顶点，获得最短路径树。Almadhoun等人利用Dijkstra算法在室内环境中探索并以最小成本访问所有节点，实现了高效的路径覆盖。Yehoshua等人引入了螺旋STC方法来优化覆盖路径，并使用Dijkstra算法找到最小权重路径。然后，一个近似算法构建每对连接区域来解决TSP问题，获得更高的预期覆盖路径百分比。Cheng等人使用Dijkstra算法计算条纹层子图之间的最短路径（快速路径搜索），在最小化重复访问节点的情况下，在条纹层内实现最大区域覆盖。Rosa等人通过使用Dijkstra算法和蜜蜂（六边形）结构来进行多机器人系统的任务规划。Zhang等人通过考虑转弯次数和角度的成本函数改进了Dijkstra算法。然而，从行程距离的角度来看，搜索路径并非最优[166] [167]。</p>
<h4 id="3-A-算法"><a href="#3-A-算法" class="headerlink" title="3.A*算法"></a>3.A*算法</h4><p>A算法通过根据启发式函数估计从当前顶点到目标顶点的路径成本来确定相邻顶点。该算法选择最佳节点以找到最短路径，而不需要搜索整个地图。基于成本函数的算法已被用于减少转弯次数和降低路径搜索的处理时间。Viet等人利用A算法结合回溯方法实现了CPP，以获得最优覆盖路径，尽管需要大量内存来存储回溯点。Cai等人描述了A算法的概念，用于从死区逃脱并到达未覆盖区域的最短路径搜索。然而，如果机器人沿对角线移动，则很难覆盖障碍物周围的单元格。此外，在避开障碍物时，机器人会以较高的重叠率重新访问单元格，而不会覆盖其他单元格。因此，Le等人提出了一种修改后的A算法，用于CPP，通过确定边界航点和障碍物航点，将重访率降低了7.01%，覆盖率提高了6.4%，与传统的A算法相比。如果目标位置已知，A算法可以胜过DFS和BFS算法。</p>
<h4 id="4-D-算法"><a href="#4-D-算法" class="headerlink" title="4.D*算法"></a>4.D*算法</h4><p>D算法适用于动态环境下的路径规划。该算法是A算法的一种变种，能够在机器人遇到障碍物时应用成本路径优化解决方案重新规划路径。Dakulovic等人[175]利用D算法计算成本值，以避免重复访问节点并减少路径重新规划中的重叠。Maurovic等人[176]通过在D<em> 算法中引入负权边，实现了主动SLAM来探索动态环境。D</em> Lite算法通过从之前的搜索中获取信息（比D算法更短）[177]来提高路径重新规划的效率。Luo等人将[178]D<em> Lite重新规划算法作为全局路径规划器，生成一个无碰撞路径用于探索未知环境，并使用蚁群优化（ACO）来规划航点路径的顺序，解决TSP问题，从而在探索地形中最小化沿计划轨迹的总距离。在[179]中一项改进的研究中，即AD算法，D Lite算法通过在线重新规划实现动态障碍物避障的最优路径。总的来说，当存在障碍物时，D</em> Lite算法在路径重新规划过程中比A算法更高效，因为D Lite算法在首次搜索时具有先前的信息数据，而A*算法需要从头开始重新规划路径。因此，选择使用的算法取决于特定任务中的不同需求。</p>
<h4 id="5-THETA-算法"><a href="#5-THETA-算法" class="headerlink" title="5.THETA*算法"></a>5.THETA*算法</h4><p>A和D算法作为离散搜索方法，无法在连续空间中找到最短路径，因为生成的路径是通过网格边缘创建的。因此，Theta算法是基于任意角度路径搜索解决器的一种算法[180]，而Lazy Theta算法则可以解决其局限性。最短路径的生成基于网格地图上的一对点，其遵循顶点父节点可以是任何顶点，而不必是顶点的邻居（与A算法不同）。Choi等人使用Theta算法和蛇形路径运动提出了一个清洁机器人的在线CPP方法，以优化局部回溯路径。当机器人在执行蛇形运动后到达终点时，回溯点的确定通过回顾先前的路径来规划最短的回溯路径到下一个起始点。类似地，成本和目标选择函数可以减少未知环境中多机器人CPP的覆盖时间[182]。然而，该算法无法生成全局优化的解决方案，即路径长度方面的最优解。对于三维空间，Lazy Theta算法更适合在立方体网格上执行，因为相比于二维空间（方形网格），每个节点具有更多的邻居。Faria等人在3D Octomap框架中使用Lazy Theta算法实现了边界单元的探索和避开障碍物[183]。同时，[184]通过减少生成的邻居数量来提高Lazy Theta算法的效率，从而降低了计算成本和进行线程可见性检查的次数。Faria等人将飞越采样技术添加到探索系统中，包括边界和Lazy Theta规划器进行全局搜索、CPP和目标检查，以产生平滑路径并覆盖区域，尽管路径长度不能保证是最优的[185]。</p>
<h3 id="H-进化算法"><a href="#H-进化算法" class="headerlink" title="H. 进化算法"></a>H. 进化算法</h3><p>进化算法（Evolutionary algorithms，EAs）基于自然或遗传进化的原理，通过寻找更好的解来解决优化问题[186]。进化算法由变异操作（交叉和突变）和适应度函数的评估组成。适应度函数根据给定的得分值来评估个体解的质量。适应度函数的计算可以通过优化问题的目标函数来表达，目标是最小化或最大化适应度函数的值[187]。进化算法在移动机器人的实际世界CPP优化问题中发挥着重要作用，能够更高效地构建基因搜索算法。</p>
<h4 id="1-遗传进化"><a href="#1-遗传进化" class="headerlink" title="1.遗传进化"></a>1.遗传进化</h4><p>遗传算法（Genetic Algorithms，GA）是一种受生物遗传规律启发的元启发式算法，通过优胜劣汰和繁殖的思想来解决搜索问题[188]。遗传算法可以快速产生接近最优的解，通过并行处理的实现方式来解决路径规划问题。GA算法是一种理想的方法，由Wang和Bo[190]在CPP中解决TSP问题时首次引入。Hameed等人[191][192]提出了一种通过优化行驶方向和路径顺序来减少路径重叠和降低成本的遗传算法。Shen等人[193]使用GA来优化基于多个领域之间路径连接顺序的能量效率。Ellefsen等人[194]在AUV中使用多目标规划和遗传算法来规划水下表面检测的覆盖轨迹，通过非支配排序GA生成有目的的避碰路径，建立带有惩罚策略的规划器。与环绕和基于采样的CPP相比，该方法在覆盖率和能量使用方面能够提供更好的平衡。在[195]中，基于GA的TCP-CPP方法的计算时间在将自由空间分解为多个单元格时比基于DP的方法快。由于功率使用和通信距离的限制，Sun等人[22]应用GA来解决多机器人的任务分配问题，采用多TSP模型。</p>
<p>遗传算法在区域覆盖方面具有良好的全局搜索能力，但由于搜索空间复杂性较高，稳定性较差，需要较长的计算时间[196]。因此，Sadek等人[197]引入了多目标遗传算法与动态规划相结合的在线CPP方法，通过在遗传算法中采用确定性交叉过程代替随机交叉过程，提高了收敛速度朝向最优值[198]。Batista和Zampirolli[199]描述了将遗传算法与池清洁的近似最优CPP序列的实现。双重适应度函数可以计算染色体的效率，降低机器人的能量消耗。在[200]中，模拟退火算法和遗传算法分别能够生成全局和多个局部区域覆盖路径。两种算法并行处理，以减少计算成本。仿真结果证明该算法在第37次迭代后能够找到最短路径。Liu等人[201]将优化算法应用于结合遗传算法和神经网络生成协同路径。遗传算法通过学习过程优化神经网络的权重和阈值，提供了93.74%的覆盖率和4.25%的重复率。然而，遗传算法的收敛效率仍有改进空间，算法的组合是一个非常有前景的解决方案。</p>
<p>差分进化（DE）是一种替代遗传算法的进化算法[202]。在每次迭代中，试验向量的生成是差分进化过程中的重要步骤，用于解决优化问题，包括差分变异、重组和选择[203]。算法的性能取决于控制参数和变异策略的选择。差分进化具有快速收敛和鲁棒性等几个优点[204]。Vesterstrom等人[205]在数值基准测试中进行了实验，并证明差分进化相对于遗传算法和粒子群优化算法具有更好的性能。对于机器人任务规划问题，Xiao等人[206]通过结合轮盘和多邻域操作（解决局部最优解问题）、差分交叉策略（提高收敛速度）和多种群集成策略（获得高计算资源）改进了差分进化算法。差分进化优化路径模型在有限能量使用下表现出良好的性能，相对于最短路径模型而言。Gonzalez等人[207]利用差分进化算法优化覆盖路径（之字形路径），通过降低距离成本生成平滑轨迹。差分进化与快速匹配方格的组合可以在四个不同的三维环境中以最小的距离成本生成光滑轨迹，同时避免与障碍物发生碰撞。</p>
<h4 id="2-群体智能"><a href="#2-群体智能" class="headerlink" title="2.群体智能"></a>2.群体智能</h4><p>群体智能是由Beni和Wang[208]引入的概念，灵感来自生物的集体社会行为[209]。它指的是从群体智能中产生的合作行为中获得的集体智慧[210]。群体智能的目标是在优化问题中开发基于概率的搜索算法。因此，由于其灵活性和高效性的优势，群体智能算法已被用于解决现实世界中的全局和非线性优化问题[211]。在覆盖路径规划中，有几类优化算法，包括粒子群优化（PSO）[212]、蚁群算法（ACO）[213]和蜜蜂群算法（BCO）[214]。基于覆盖路径规划的群体智能算法利用粒子群的运动来寻找最短路径或达到目标，并以最小的时间提供最优的覆盖解决方案。</p>
<p>粒子群优化（PSO）是一种基于自然群体行为模式的元启发式算法，涉及到自然群体的聚集行为[215]。Lee等人[216]在高分辨率网格地图上进行了基于PSO的在线覆盖路径规划，提供了平滑的覆盖路径。在[217]中，聚类分布因子和PSO算法可在每个划分地图中进行区域覆盖。Sahu和Choudhury[218]使用PSO生成用于全局目标覆盖的轨迹。Y. H. Lin应用单目标PSO[219]和多目标PSO[220]来优化动态路径规划。Wang等人[221]证明了基于PSO方法的覆盖路径规划比牧野法具有更少的冗余覆盖。总的来说，PSO在初始阶段具有全局搜索能力，但群体容易陷入局部最优，导致搜索过程的收敛速度较慢。Couceiro等人[222]使用达尔文式PSO算法将群体分为多个小的合作子群（子群），通过奖惩机制提供逃离局部最优解的能力。在[223]中，一组采样路径输入PSO框架可以优化成本函数，提高覆盖路径的质量和效率。然后，全局最佳粒子从相机视野中选择最小成本的探索粒子更新，克服了过早收敛的限制。然而，在不同的模型大小上，计算时间仍然很长。此外，当PSO处理多维搜索空间时，其性能可能会迅速恶化[224]。因此，[225]提出了一种用于解决大规模优化问题的合作进化粒子群优化（CCPSO2）技术。Sun等人[226]提出了一种组合方法（CCPSO2和改进的GA）来解决最优传感器部署问题和TSP问题，分别在所有相应的子区域中实现了更好的覆盖和避障，尽管缺乏实验结果。</p>
<p>蚁群算法（ACO）是一种概率技术，模仿了蚂蚁的行为和寻找食物的过程，通过搜索最优路径来解决复杂的优化问题[227]。实施ACO算法来解决路径优化问题具有许多优势，如强鲁棒性[228]，[229]和并行计算[230]，[231]。然而，该算法很容易陷入局部最优解，收敛速度较慢[232]，[233]。因此，[234]提出了一种改进的ACO算法，使用信息素更新规则来避免陷入局部最小值。Chibin等人[235]使用ACO算法根据距离矩阵优化子区域的覆盖。Zhou等人[265]介绍了一种基于ACO算法的块序列优化来解决TSP问题。[237]提出了一种基于ACO算法的全局巡检路径优化。Max-Min Ant System (MMAS)是另一种改进的ACO算法，通过将信息素值限制在最大值和最小值之间来解决局部最优问题[238]。Karakaya[239]应用MMAS来规划UA V的目标覆盖路径。Tewolde和Sheng[240]比较了喷漆中GA和ACO算法的CPP性能，并显示ACO算法相对于GA算法可以将覆盖路径长度减少13%。Chen等人[13]通过使用指数均值贝塞尔曲线和基于ACO或GA的轨迹优化，改进了喷涂路径的精度，并通过在贝塞尔曲面上优化轨迹进一步提高了平滑路径[241]。Gao等人[242]提出了一种改进的ACO算法，通过减少多机器人CPP中的转弯次数来优化覆盖性能。Ye等人[12]通过随机计算转移概率和更新信息素以及加速因子改进了算法，提高了全局搜索能力，尽管算法的随机性可能导致失败。Dentler等人[243]利用基于ACO的航路点跟踪器结合动力学的混沌解来提高覆盖效率。然而，由于定位精度不高，可能会发生高风险的碰撞场景。Le等人提出了用于CPP的清洁机器人（hTetro）[244]和平铺机器人（hTetrakis [245]和hTrihex [246]），通过使用GA和ACO算法来减少能源消耗。此外，每种机器人类型都可以改变形状，以在给定的工作空间中提供高效的覆盖效果。<br>韩等人使用滑翔器以来回运动的方式滑行通过导航点，在海平面上使用蚁群算法寻找避开障碍物的最短路径，但受热跃层影响改变了通信半径，这是一项具有挑战性的任务。</p>
<p>BCO（蜜蜂群算法）是另一种基于群体智能的、类似于ACO和PSO的生物启发式机器学习算法。<br>Caliskanelli等人[248]引入了基于BCO的信息素信号算法，用于多机器人覆盖[249]，以及基于混合BCO-ACO信息素信号技术来解决多个机器人中的通信网络问题[250]。萤火虫算法（FA）是一种受自然启发的优化算法[251]，已广泛用于未知区域的覆盖和探索，特别是用于排雷任务[252] [253]。多机器人的目标是探索和覆盖矿区，并找到避开障碍物的最优路径。Palmeiri等人[254]在能耗方面比较了FA、PSO和BCO在群体机器人系统协调方面的性能。FA在全局覆盖所有节点方面的性能也优于ACO算法，在动态坡地的10x10网格大小情况下[255]，计算时间减少了7.2%，覆盖路径长度减少了2.5%。然而，如果增加机器人密度，则路径长度的改善不明显。Henrio等人[256]建议使用基于贝叶斯优化的超参数调整方法来应用于FA，以解决优化问题。灰狼优化器（GWO）是最近的一种元启发式算法[257]，模拟了灰狼的捕猎行为和社会领导力，其中alpha、beta、delta和omega是灰狼移动的分类。Kamalova和Lee[258]使用协调的多机器人探索（CME）和GWO算法进行多机器人探索，以实现最优协调和有效地优化覆盖区域，相比确定性CME算法获得了更好的性能。</p>
<p>尽管在四个不同的障碍地图上平均覆盖率为97.98%，但障碍物避免约束仍然是一个挑战。<br>与此同时，[260]基于多目标GWO算法进行了类似的实验，展示了机器人的覆盖能力，但机器人不断重访先前探索过的区域，导致执行时间较长。此外，GWO算法在获得全局最优解和处理动态障碍物方面存在困难，这是由于步长机制的限制。因此，Ge等人[261]通过将GWO算法与果蝇优化算法相结合，改进了局部最优解。同时，Dewangan等人证明了改进后的GWO算法具有更好的探索能力和避免局部最优解的能力。Kamalova等人[262]在基于前沿探索的全局路径点控制方法中实现了该方法，该方法生成位于不确定性开放区域上的前沿点（传感器未接收到任何传输信号），并根据前沿点阵列的输入参数创建全局路径点。GWO算法可以通过计算从当前机器人位置到前沿点位置的三个距离的平均值来估计下一个全局路径点（平均α点、平均β点和平均δ点），从而实现高效的搜索行为，与PSO算法相比具有更高的搜索行为。机器人具有很高的避开障碍物的能力，尽管最终导致行程较长。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/slam/" class="category-chain-item">slam</a>
  
  
    <span>></span>
    
  <a href="/categories/slam/path-planning/" class="category-chain-item">path_planning</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>一篇综述性文章-使用经典和启发式算法进行机器人覆盖路径规划的全面评估</div>
      <div>https://qiangsun89.github.io/2023/06/12/一篇综述性文章-使用经典和启发式算法进行机器人覆盖路径规划的全面评估/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Qiang Sun</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年6月12日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06/12/%E5%9F%BA%E4%BA%8E%E7%BD%91%E6%A0%BC%E7%9A%84%E7%A6%BB%E7%BA%BF%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/" title="基于网格的离线覆盖路径规划">
                        <span class="hidden-mobile">基于网格的离线覆盖路径规划</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"LEYjQzDk7jo8uqlOQoAEF5qm-gzGzoHsz","appKey":"7bBCyINnLw0akaPjI39pESMN","path":"window.location.pathname","placeholder":"留言","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
