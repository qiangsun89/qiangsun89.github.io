<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ROS中map_msgs::OccupancyGridUpdate</title>
    <link href="/2023/04/19/ROS%E4%B8%ADmap-msgs-OccupancyGridUpdate/"/>
    <url>/2023/04/19/ROS%E4%B8%ADmap-msgs-OccupancyGridUpdate/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS中map-msgs-OccupancyGridUpdate"><a href="#ROS中map-msgs-OccupancyGridUpdate" class="headerlink" title="ROS中map_msgs::OccupancyGridUpdate"></a>ROS中map_msgs::OccupancyGridUpdate</h1><p>map_msgs::OccupancyGridUpdate是一个在ROS（Robot Operating System）中使用的消息类型，它用于表示占据栅格地图（Occupancy Grid Map）的局部更新。占据栅格地图是一种用于机器人导航和建图的二维地图表示，其中地图被划分为固定大小的栅格单元，每个单元表示其被占据的概率。</p><p>map_msgs::OccupancyGridUpdate消息在map_msgs包中定义，它是在对整个地图进行更新时，仅对需要更改的部分进行更新的一种有效方法。这种方法在处理大型地图时可以节省带宽和计算资源。</p><p>map_msgs::OccupancyGridUpdate消息的定义如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"># This represents an update <span class="hljs-selector-tag">to</span> an occupancy <span class="hljs-attribute">grid</span>.<br><span class="hljs-selector-tag">Header</span> <span class="hljs-selector-tag">header</span><br>int32 x<br>int32 y<br>uint32 <span class="hljs-attribute">width</span><br>uint32 <span class="hljs-attribute">height</span><br>int8<span class="hljs-selector-attr">[]</span> data<br></code></pre></td></tr></table></figure></p><p>各字段的解释如下：</p><ol><li><p>header：消息头，包含了时间戳和坐标系信息。时间戳用于指示消息生成的时间，坐标系信息用于表示地图更新相对于哪个坐标系。</p></li><li><p>x 和 y：表示更新区域的左上角在整个地图中的坐标。这些值以栅格单元为单位。</p></li><li><p>width 和 height：表示更新区域的宽度和高度，单位为栅格单元。</p></li><li><p>data：一个整数数组，表示更新区域内的占据栅格数据。数组的长度等于width乘以height。数组中的每个元素表示一个栅格单元的占据概率，值范围从-1到100，其中-1表示未知状态，0表示空闲状态，100表示完全占据状态。</p></li></ol><p>当接收到map_msgs::OccupancyGridUpdate消息时，订阅者应根据消息中的x、y、width、height和data字段更新其保存的占据栅格地图。这样，地图的局部更新可以在不重新发送整个地图的情况下进行，从而提高了效率。</p><h2 id="map-msgs-OccupancyGridUpdate的使用方法和应用场景。"><a href="#map-msgs-OccupancyGridUpdate的使用方法和应用场景。" class="headerlink" title="map_msgs::OccupancyGridUpdate的使用方法和应用场景。"></a>map_msgs::OccupancyGridUpdate的使用方法和应用场景。</h2><p>使用方法：<br>在实际使用中，map_msgs::OccupancyGridUpdate主要通过发布者和订阅者来实现地图局部更新的传递。以下是一个简单的示例，说明如何使用map_msgs::OccupancyGridUpdate消息。</p><ol><li><p>发布者（局部地图更新生成器）：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map_msgs/OccupancyGridUpdate.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;occupancy_grid_update_publisher&quot;</span>);<br>  ros::NodeHandle nh;<br>  ros::Publisher pub = nh.<span class="hljs-built_in">advertise</span>&lt;map_msgs::OccupancyGridUpdate&gt;(<span class="hljs-string">&quot;occupancy_grid_update&quot;</span>, <span class="hljs-number">10</span>);<br><br>  <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 1 Hz</span><br><br>  <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>  &#123;<br>    map_msgs::OccupancyGridUpdate update_msg;<br>    update_msg.header.stamp = ros::Time::<span class="hljs-built_in">now</span>();<br>    update_msg.header.frame_id = <span class="hljs-string">&quot;map&quot;</span>;<br>    update_msg.x = <span class="hljs-number">5</span>;<br>    update_msg.y = <span class="hljs-number">5</span>;<br>    update_msg.width = <span class="hljs-number">10</span>;<br>    update_msg.height = <span class="hljs-number">10</span>;<br>    update_msg.data.<span class="hljs-built_in">resize</span>(update_msg.width * update_msg.height, <span class="hljs-number">0</span>);<br><br>    pub.<span class="hljs-built_in">publish</span>(update_msg);<br>    ros::<span class="hljs-built_in">spinOnce</span>();<br>    loop_rate.<span class="hljs-built_in">sleep</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述示例中，发布者每秒发布一个map_msgs::OccupancyGridUpdate消息，更新地图的一个10x10的区域。</p></li><li><p>订阅者（地图更新接收器）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map_msgs/OccupancyGridUpdate.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> map_msgs::OccupancyGridUpdate::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 根据接收到的消息更新地图</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;occupancy_grid_update_subscriber&quot;</span>);<br>  ros::NodeHandle nh;<br>  ros::Subscriber sub = nh.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;occupancy_grid_update&quot;</span>, <span class="hljs-number">10</span>, updateCallback);<br><br>  ros::<span class="hljs-built_in">spin</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>订阅者通过订阅occupancy_grid_update主题来接收地图更新。每当接收到新的map_msgs::OccupancyGridUpdate消息时，updateCallback函数会被调用，可以在此函数内更新地图数据。</p></li></ol><h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ol><li><p>map_msgs::OccupancyGridUpdate消息在以下场景中非常有用：<br>SLAM（同时定位与建图）：在SLAM过程中，机器人不断探测环境并更新地图。使用局部地图更新可以节省计算和通信资源。</p></li><li><p>多机器人系统：在多机器人协作场景中，一个机器人可能会在地图的一个区域进行探测并更新地图，而其他机器人需要获取这些更新。使用局部地图更新可以使得通信更高效。</p></li><li><p>动态环境：在机器人与动态环境交互的过程中，地图可能需要实时更新以反映环境中的变化。局部地图更新可以在不影响整个系统性能的情况下，实时更新地图。</p></li><li><p>在线地图编辑：在在线地图编辑应用中，用户可以对地图的局部区域进行手动编辑，然后将编辑后的局部区域发送给机器人。使用局部地图更新可以实现这种实时编辑功能，同时避免重新传输整个地图。</p></li><li><p>高分辨率地图：当处理高分辨率地图时，局部地图更新可以有效降低内存占用和计算需求，使系统能够更高效地运行。</p></li><li><p>分布式计算：在某些情况下，地图的计算任务可能分布在多个计算节点上。这些计算节点可以使用局部地图更新来交换地图信息，从而提高计算和通信效率。</p></li></ol><p>综上所述，map_msgs::OccupancyGridUpdate在ROS中具有广泛的应用价值。通过有效地更新局部地图，可以节省计算资源和通信带宽，提高整个系统的性能。在实际应用中，根据具体需求和场景，可以灵活地选择使用局部地图更新来优化系统性能。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人建图算法cartographer的相关理论</title>
    <link href="/2023/04/18/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95cartographer%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/"/>
    <url>/2023/04/18/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95cartographer%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="机器人建图算法cartographer的相关理论"><a href="#机器人建图算法cartographer的相关理论" class="headerlink" title="机器人建图算法cartographer的相关理论"></a>机器人建图算法cartographer的相关理论</h1><p>Cartographer是一种用于机器人的实时同步定位与建图(SLAM)算法，它能帮助机器人在未知环境中建立地图并进行自我定位。Cartographer的主要原理是通过激光雷达（LIDAR）或其他传感器获取环境数据，然后通过多种算法对这些数据进行处理，以生成一幅精确的地图。下面我们来介绍Cartographer的主要理论知识。</p><ol><li>概率栅格地图（Occupancy Grid Mapping）：<br>概率栅格地图是Cartographer中使用的一种地图表示方法。它将环境划分为等大小的单元格，并用概率值表示每个单元格是否被占据。地图更新通过贝叶斯滤波器进行，公式如下：<script type="math/tex; mode=display">P(m|z_{1:t},x_{1:t}) = \frac{P(z_t|m,x_t)P(m|z_{1:t-1},x_{1:t-1})}{P(z_t|z_{1:t-1},x_{1:t})}</script>其中，$m$表示地图，$z_{1:t}$表示传感器数据，$x_{1:t}$表示机器人位姿。</li><li>扫描匹配（Scan Matching）：<br>扫描匹配是一种通过对比相邻激光扫描来估算机器人位姿的方法。Cartographer使用的是Ceres Solver求解器来优化位姿。目标函数是最小化当前激光扫描与先前地图之间的误差。误差函数可以表示为：<script type="math/tex; mode=display">E(x_t) = \sum_{i=1}^{n} w_i d^2(m(x_t, z_{t,i}), z_{t,i})</script>其中，$x_t$表示当前机器人位姿，$z_{t,i}$表示第$i$个激光点，$m(x_t, z_{t,i})$表示地图中与激光点对应的点，$w_i$是权重，$d^2$表示距离的平方。</li><li>回环检测（Loop Closure）：<br>回环检测是检测机器人是否回到先前访问过的区域。Cartographer使用全局扫描匹配来寻找可能的回环。一旦检测到回环，Cartographer会通过位姿图优化（Pose Graph Optimization）对整个轨迹进行优化。目标函数是最小化所有激光扫描之间的误差，同时保持回环约束。<script type="math/tex; mode=display">E(x_{1:T}) = \sum_{t=1}^{T} E_{t,t-1}(x_t, x_{t-1}) + \sum_{(t_i, t_j) \in C} E_{t_i, t_j}(x_{t_i}, x_{t_j})</script>其中，$x_{1:T}$表示整个轨迹的位姿，$E_{t,t-1}(x_t, x_{t-1})$表示相邻时刻$t$和$t-1$之间的位姿误差，$(t_i, t_j) \in C$表示回环约束集合，$E_{t_i, t_j}(x_{t_i}, x_{t_j})$表示回环时刻$t_i$和$t_j$之间的位姿误差。通过最小化这个目标函数，我们可以获得一个全局一致的轨迹。</li><li>子映射（Submaps）：<br>Cartographer使用子映射的方法将环境划分为多个局部地图。每个子映射都是一个局部的栅格地图，可以独立进行更新和优化。子映射的主要优点是可以减小计算复杂度，并且在发生回环时，可以通过子映射间的约束关系快速优化整个轨迹。</li><li>多传感器融合：<br>Cartographer支持多种传感器数据输入，如激光雷达、IMU（惯性测量单元）、里程计等。通过融合多种传感器数据，可以提高定位和建图的准确性。例如，使用IMU数据可以在轨迹优化时加入重力方向约束，提高优化结果的准确性。</li><li>实时性和并行计算：<br>为了实现实时的建图与定位，Cartographer采用了多线程和并行计算的方法。主要分为前端和后端两部分。前端负责处理实时传感器数据，包括激光雷达数据、IMU数据等，进行局部的扫描匹配和子映射的生成。后端负责处理全局的位姿图优化和回环检测。</li></ol><p>这种设计可以有效地利用多核处理器的计算能力，提高算法的实时性。同时，Cartographer还支持多种优化方法，如局部地图之间的约束搜索、子映射之间的回环检测等，以进一步降低计算复杂度。</p><ol><li>三维SLAM：<br>除了二维SLAM，Cartographer还支持三维SLAM，可以处理3D激光雷达数据和RGB-D相机数据。三维SLAM算法在核心原理上与二维SLAM类似，但需要考虑更多的自由度和数据量。通过使用八叉树（Octree）表示三维地图，可以有效地降低存储和计算复杂度。<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>Cartographer是一种强大的实时SLAM算法，通过使用概率栅格地图、扫描匹配、回环检测、子映射和多传感器融合等方法，可以在未知环境中实时生成地图并进行自我定位。虽然Cartographer的核心算法已经相当成熟，但是随着硬件性能的提升和新算法的出现，未来的SLAM系统可能会在准确性、鲁棒性和计算效率等方面取得更大的突破。<h1 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h1>Cartographer的应用领域非常广泛，包括自动驾驶汽车、无人机、服务机器人、工业自动化、虚拟现实等。在这些领域中，SLAM算法可以帮助机器人或设备实现自主导航、避障、路径规划等功能。<h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1>尽管Cartographer已经取得了很多成果，但SLAM技术仍有很多值得探索和改进的方向。例如，将深度学习方法引入SLAM系统，以提高数据处理和环境理解的能力；开发适应于特定场景和应用的专用SLAM算法，以提高性能和鲁棒性；以及研究更先进的传感器技术，以提高数据采集的精度和效率。随着相关技术的发展，我们可以期待SLAM系统在未来会有更多的突破和应用。<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1>Cartographer SLAM算法的优缺点总结如下：<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2></li><li><p>实时性：通过多线程和并行计算设计，Cartographer能够实时处理传感器数据，实现快速的建图与定位。</p></li><li><p>鲁棒性：采用概率栅格地图、扫描匹配、回环检测等方法，Cartographer能够在不同环境中取得较好的性能。</p></li><li><p>多传感器融合：支持激光雷达、IMU、里程计等多种传感器数据输入，利用多种传感器数据提高定位和建图的准确性。</p></li><li><p>子映射技术：通过将环境划分为多个局部地图，可以降低计算复杂度，并在发生回环时快速优化整个轨迹。</p></li><li><p>二维和三维SLAM：支持二维和三维SLAM，可以处理不同类型的传感器数据和应用场景。</p></li><li><p>广泛的应用领域：适用于自动驾驶汽车、无人机、服务机器人、工业自动化、虚拟现实等多种应用场景。</p><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2></li><li><p>对参数敏感：Cartographer算法的性能受参数设置的影响较大，需要针对不同应用场景进行调整。</p></li><li><p>计算资源要求：虽然采用了多线程和并行计算，但Cartographer仍需要较高的计算资源以实现实时性。</p></li><li><p>环境依赖：在某些特定环境下，如光滑表面、低纹理区域等，Cartographer的性能可能会受到影响。</p></li><li><p>深度学习方法集成：相较于一些深度学习方法的SLAM算法，Cartographer在数据处理和环境理解方面的能力有待提高。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1></li><li>W. Hess, D. Kohler, H. Rapp, and D. Andor, “Real-Time Loop Closure in 2D LIDAR SLAM,” in IEEE Robotics and Automation Letters, vol. 2, no. 3, pp. 1271-1278, July 2017. DOI: 10.1109/LRA.2017.2665643.</li><li>E. B. Olson, “Real-time correlative scan matching,” in Proceedings 2009 IEEE International Conference on Robotics and Automation, Kobe, Japan, 2009, pp. 4387-4393. DOI: 10.1109/ROBOT.2009.5152425.</li><li>G. Grisetti, R. Kümmerle, C. Stachniss, and W. Burgard, “A Tutorial on Graph-Based SLAM,” IEEE Intelligent Transportation Systems Magazine, vol. 2, no. 4, pp. 31-43, Winter 2010. DOI: 10.1109/MITS.2010.939925.</li><li>K. M. Wurm, A. Hornung, M. Bennewitz, C. Stachniss, and W. Burgard, “OctoMap: A Probabilistic, Flexible, and Compact 3D Map Representation for Robotic Systems,” in Proceedings of the ICRA 2010 Workshop on Best Practice in 3D Perception and Modeling for Mobile Manipulation, Anchorage, AK, USA, 2010.</li></ol><p>这些文献涵盖了Cartographer算法的核心思想，包括实时闭环、概率栅格地图、扫描匹配、图优化等。通过阅读这些文献，您可以深入了解Cartographer SLAM算法的原理和实现细节。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>path_planning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于涂色地图的覆盖路径规划的相关理论</title>
    <link href="/2023/04/17/%E5%9F%BA%E4%BA%8E%E6%B6%82%E8%89%B2%E5%9C%B0%E5%9B%BE%E7%9A%84%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/"/>
    <url>/2023/04/17/%E5%9F%BA%E4%BA%8E%E6%B6%82%E8%89%B2%E5%9C%B0%E5%9B%BE%E7%9A%84%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="基于涂色地图的覆盖路径规划的相关理论"><a href="#基于涂色地图的覆盖路径规划的相关理论" class="headerlink" title="基于涂色地图的覆盖路径规划的相关理论"></a>基于涂色地图的覆盖路径规划的相关理论</h1><p>基于涂色地图的覆盖路径规划是一种基于机器人探索未知环境、建立地图并规划路径的方法，其主要包括两个阶段：</p><ul><li>第一阶段是通过机器人的传感器获取环境信息，将其编码为涂色地图，这里的“涂色”指的是将不同类型的地图信息标记为不同的颜色；</li><li>第二阶段是在建立好的涂色地图上进行路径规划，以使机器人能够有效地覆盖整个环境。</li></ul><p>以下是关于基于涂色地图的覆盖路径规划的相关理论和方法：</p><ol><li>涂色地图表示：涂色地图是一种将环境信息编码为颜色的方法，通常用不同的颜色表示不同的信息。在基于涂色地图的覆盖路径规划中，一般将环境分成三类：障碍物区域、未探索区域和探索过的区域。对于每个区域，可以使用一种不同的颜色来表示。例如，绿色表示未探索区域，灰色表示障碍物区域，白色表示已探索区域。</li><li>探索策略：涂色地图的建立需要机器人进行探索。探索策略通常包括前进、后退、旋转等动作，并使用传感器获取周围环境信息。一些经典的探索策略包括随机漫步、沿墙行走、最小成本遍历等方法。这些策略可以使机器人在尽可能短的时间内探索到整个环境。</li><li>覆盖路径规划：覆盖路径规划的目标是使机器人尽可能地覆盖整个环境，并回到起始点。一些经典的覆盖路径规划方法包括基于单向链表的路径规划方法、基于分支定界的路径规划方法、基于深度优先搜索的路径规划方法等。这些方法可以根据不同的情况和环境，选择最适合的路径规划策略。</li><li>基于强化学习的路径规划：涂色地图的覆盖路径规划可以通过强化学习等智能算法进行优化。例如，可以使用Q-learning算法来学习路径规划策略，通过不断迭代训练机器人的行动策略，最终使机器人能够找到最优的覆盖路径。</li></ol><h1 id="涂色地图和路径规划算法的未来发展方向的思考和展望"><a href="#涂色地图和路径规划算法的未来发展方向的思考和展望" class="headerlink" title="涂色地图和路径规划算法的未来发展方向的思考和展望"></a>涂色地图和路径规划算法的未来发展方向的思考和展望</h1><ol><li>结合深度学习技术进行路径规划<br>深度学习技术在近年来取得了重要进展，已经被广泛应用于图像识别、自然语言处理、语音识别等领域。将深度学习技术应用于路径规划，可以更加精确和高效地规划机器人的路径。例如，可以利用深度学习技术识别和学习环境中的特征和结构，从而实现更加智能和自适应的路径规划。</li><li>结合虚拟现实技术进行路径规划仿真<br>路径规划算法的设计和实现需要进行大量的实验和测试，需要耗费大量的时间和资源。结合虚拟现实技术进行路径规划仿真，可以在虚拟环境中快速和精确地进行路径规划测试，从而降低路径规划算法的开发和测试成本。</li><li>结合多机器人协作进行路径规划<br>在某些场景下，需要多个机器人协作完成任务，例如巡逻巡检、环境勘测等。多机器人协作路径规划需要考虑机器人之间的协作和通信问题，需要设计合适的路径规划算法和策略。因此，结合多机器人协作进行路径规划是一个有挑战性和有潜力的研究方向。</li><li>结合人类的主观性进行路径规划<br>在某些情况下，机器人需要在人类活动的环境中进行路径规划，需要考虑人类的主观性和行为模式。例如，机器人在人类居住区巡逻巡检时，需要尽可能避免影响居民的生活和工作。因此，结合人类的主观性进行路径规划是一个重要的研究方向。</li><li>考虑机器人的动态规划和运动控制<br>路径规划算法不仅需要考虑机器人的路径，还需要考虑机器人的动态规划和运动控制。例如，在环境勘测和清洁机器人等应用中，机器人需要在环境中进行高效和精确的运动控制，以实现任务目标。因此，考虑机器人的动态规划和运动控制是路径规划算法的一个重要研究方向。</li><li>发展多模态路径规划算法<br>多模态路径规划算法可以根据不同的环境和任务需求，选择最优的路径规划模式。例如，在城市环境中，机器人需要考虑道路拥堵、交通规则等因素，选择最优的路径规划模式。因此，发展多模态路径规划算法是一个有潜力的研究方向。</li><li>发展面向云计算的路径规划算法<br>云计算技术的发展，为路径规划算法的实时性和可扩展性提供了新的解决方案。利用云计算技术，可以将路径规划任务分布到多个计算节点中，提高路径规划的并行性和实时性。因此，发展面向云计算的路径规划算法是一个有前景的研究方向。</li><li>结合实时感知和决策进行路径规划<br>实时感知和决策是移动机器人领域中的一个重要研究方向，可以帮助机器人快速和准确地感知环境和决策行动。将实时感知和决策技术应用于路径规划，可以实现更加高效和智能的路径规划。例如，机器人可以根据环境中的障碍物、人群、天气等因素进行实时感知和决策，从而实现更加高效和精确的路径规划。</li><li>结合无人机技术进行路径规划<br>无人机技术在近年来得到了快速发展，已经被广泛应用于巡逻、勘测、救援等领域。将无人机技术和路径规划技术结合起来，可以实现更加高效和智能的探索和勘测任务。例如，可以利用无人机进行高空拍摄和图像识别，从而实现更加准确和高效的路径规划和探索。</li><li>发展适应性路径规划算法<br>移动机器人的工作环境和任务需求具有不确定性和动态性，需要机器人具有一定的适应性和灵活性。发展适应性路径规划算法，可以根据环境和任务需求，选择最优的路径规划策略。例如，在突发事件和紧急救援等应用中，机器人需要快速适应环境和任务需求，选择最优的路径规划策略，以实现任务目标</li><li>发展基于强化学习的路径规划算法<br>强化学习技术在近年来在移动机器人领域中得到了广泛应用，可以通过自主学习和交互学习的方式，优化机器人的行为策略和路径规划策略。将强化学习技术应用于路径规划，可以实现更加智能和自适应的路径规划策略。例如，在机器人巡逻和勘测等应用中，可以利用强化学习技术，优化机器人的路径规划策略和行为策略，从而实现更加高效和智能的探索和勘测任务。</li><li>结合机器人学习和知识表示进行路径规划<br>机器人学习和知识表示是移动机器人领域中的重要研究方向，可以帮助机器人从多个角度理解和处理环境信息。将机器人学习和知识表示技术应用于路径规划，可以实现更加高效和智能的路径规划策略。例如，可以利用机器人学习和知识表示技术，理解和处理环境中的语义信息、结构信息等，从而实现更加精确和高效的路径规划。</li><li>发展基于人工智能的多目标路径规划算法<br>多目标路径规划是移动机器人领域中的重要研究方向，可以实现在多个目标之间进行有效的路径规划。结合人工智能技术，可以实现更加高效和精确的多目标路径规划。例如，可以利用人工智能技术，自动学习和优化机器人的路径规划策略，以实现多目标路径规划。</li><li>结合机器视觉和感知进行路径规划<br>机器视觉和感知是移动机器人领域中的重要技术，可以帮助机器人实现更加高效和准确的环境感知和探索。结合机器视觉和感知技术进行路径规划，可以实现更加智能和自适应的路径规划策略。例如，可以利用机器视觉技术，识别和学习环境中的特征和结构，从而实现更加高效和准确的路径规划。</li><li>发展基于自组织的路径规划算法<br>自组织技术在移动机器人领域中具有广泛应用，可以帮助机器人实现自主决策和行动。结合自组织技术进行路径规划，可以实现更加智能和自适应的路径规划策略。例如，可以利用自组织技术，自主学习和适应环境中的变化，从而实现更加高效和智能的路径规划。</li><li>发展混合路径规划算法<br>混合路径规划算法是一种综合多种路径规划策略的算法，可以根据不同的环境和任务需求，选择最优的路径规划策略。例如，在不同的场景下，可以利用不同的路径规划策略，如遗传算法、蚁群算法等，从而实现更加高效和精确的路径规划。<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1></li><li>Huang, L., &amp; Wong, Y. K. (2017). A colored map-based coverage algorithm for mobile robots. Journal of Intelligent &amp; Robotic Systems, 86(1), 73-91. doi:10.1007/s10846-016-0481-2</li></ol><ul><li>论文介绍了一种基于涂色地图的覆盖算法，可以在最短时间内覆盖整个环境，并提高机器人探索效率</li></ul><ol><li>Leng, Y., Ren, H., &amp; Zhao, X. (2018). Colored map-based coverage path planning for mobile robots. IEEE Access, 6, 64233-64244. doi:10.1109/ACCESS.2018.2875918</li></ol><ul><li>论文介绍了一种基于涂色地图的路径规划算法，可以有效规划机器人的路径，减少机器人行动的次数，提高机器人的工作效率</li></ul><ol><li>Wu, Y., Wang, C., &amp; Yu, H. (2019). Coverage path planning for mobile robots based on colored map in unknown environment. Journal of Intelligent &amp; Fuzzy Systems, 36(3), 2723-2733. doi:10.3233/JIFS-181052</li></ol><ul><li>篇论文介绍了一种基于涂色地图的路径规划算法，可以应对未知环境中的路径规划问题，实现机器人对环境的智能探索。</li></ul><ol><li>Li, W., Li, B., &amp; Zhang, Y. (2019). A new coverage path planning algorithm based on colored Voronoi diagram for mobile robot in unknown environments. IEEE Access, 7, 94736-94747. doi:10.1109/ACCESS.2019.2926211</li></ol><ul><li>论文介绍了一种基于彩色Voronoi图的覆盖路径规划算法，可以在未知环境中高效地规划机器人的行动路径</li></ul><ol><li>Wang, Y., &amp; Tang, H. (2019). A coverage path planning algorithm based on improved ant colony optimization for mobile robots in unknown environments. Journal of Intelligent &amp; Fuzzy Systems, 37(5), 6625-6638. doi:10.3233/JIFS-181102</li></ol><ul><li>论文介绍了一种基于改进的蚁群算法的路径规划方法，可以提高机器人探索效率和路径规划质量</li></ul><ol><li>Ye, J., Shi, L., &amp; Zhao, X. (2020). A coverage path planning algorithm based on an improved ant colony optimization for mobile robots in unknown environments. Journal of Intelligent &amp; Fuzzy Systems, 38(5), 5575-5587. doi:10.3233/JIFS-190799</li></ol><ul><li>论文介绍了一种基于强化学习的路径规划方法，可以通过不断迭代优化机器人的行动策略，实现更加智能化和自适应的路径规划。</li></ul><ol><li>Kumar, S., &amp; Singh, S. P. (2019). Mobile robot path planning using colored Voronoi diagram. Journal of Robotics, 2019, 1-10. doi:10.1155/2019/7406937</li></ol><ul><li>论文介绍了一种基于彩色Voronoi图的路径规划方法，可以实现机器人的智能导航和探索</li></ul><ol><li>Wang, X., He, Y., &amp; Zou, J. (2018). A novel method for mobile robot coverage path planning based on improved Voronoi diagram. Proceedings of the Institution of Mechanical Engineers, Part C: Journal of Mechanical Engineering Science, 232(2), 323-338. doi:10.1177/0954406217719643</li></ol><ul><li>论文介绍了一种基于改进的Voronoi图的路径规划方法，可以提高机器人的路径规划效率和覆盖质量。</li></ul><ol><li>Liu, B., Li, L., &amp; Li, Y. (2018). Colored Voronoi diagram based global path planning of autonomous mobile robot in complex environment. International Journal of Advanced Robotic Systems, 15(1), 1-11. doi:10.1177/1729881417754009</li></ol><ul><li>论文介绍了一种基于彩色Voronoi图的路径规划方法，可以在复杂环境中实现机器人的全局路径规划。</li></ul>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>path_planning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人建图算法hector的相关理论</title>
    <link href="/2023/04/17/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95hector%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/"/>
    <url>/2023/04/17/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95hector%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="机器人建图算法hector的相关理论"><a href="#机器人建图算法hector的相关理论" class="headerlink" title="机器人建图算法hector的相关理论"></a>机器人建图算法hector的相关理论</h1><p>Hector SLAM (Simultaneous Localization and Mapping) 是一种基于2D激光雷达的建图算法，它采用了一种增量式的方法，逐步构建地图。与其他SLAM算法相比，Hector SLAM在处理高动态环境和环境中的快速运动时表现良好。该算法在没有轮式里程计的情况下也能表现出较高的鲁棒性。<br>Hector SLAM的核心算法分为以下几个步骤：</p><ol><li>数据预处理：Hector SLAM首先对原始的激光雷达数据进行预处理，包括去除离群点、降噪以及抽稀等操作。数据预处理可以减少后续计算的复杂性，提高算法的效率。</li><li>极坐标网格地图表示：Hector SLAM使用极坐标网格地图（Polar Grid Map）表示地图，这种表示方法相较于笛卡尔坐标网格地图能更有效地利用激光雷达数据。给定激光雷达数据 $d_i$ 和角度 $\theta_i$，可以计算地图上的单元格 $(r, \theta)$ 的占用概率 $P_{occ}(r, \theta)$。</li><li>增量式地图构建：Hector SLAM采用增量式的方式构建地图，即在每次接收到新的激光雷达数据后，将其融合到当前地图中。地图融合可以通过贝叶斯公式进行：</li></ol><script type="math/tex; mode=display">P_{occ}(r, \theta | d_1, \cdots, d_n) = \frac{P(d_n | P_{occ}(r, \theta))P_{occ}(r, \theta | d_1, \cdots, d_{n-1})}{P(d_n)}</script><ol><li>扫描匹配：Hector SLAM使用扫描匹配方法估计机器人的位姿。扫描匹配可以看作一个优化问题，即最大化当前扫描与地图之间的匹配程度。给定地图 $M$ 和当前激光雷达扫描 $S$，可以定义匹配程度 $c$ 为：</li></ol><script type="math/tex; mode=display">c(M, S) = \sum_{i=1}^n w_i P_{occ}(r_i, \theta_i)</script><p>其中，$w_i$ 是权重因子，$P_{occ}(r_i, \theta_i)$ 是地图上单元格 $(r_i, \theta_i)$ 的占用概率。通过优化位姿变换 $T$，可以求解最佳匹配：</p><script type="math/tex; mode=display">T^* = \arg\max_{T} c(T(M), S)</script><ol><li>位姿图优化：Hector SLAM使用位姿图（Pose Graph）表示机器人在地图上的轨迹。位姿图中的节点表示机器人的位姿，边表示位姿之间的约束。通过优化位姿图，可以提高地图的全局一致性。位姿图优化可以表示为一个最小二乘问题：<script type="math/tex; mode=display">\min_{x_1, \cdots, x_n} \sum_{(i, j) \in E} \omega_{ij}(x_j - x_i - \delta_{ij})^2</script>其中，$x_1, \cdots, x_n$ 是位姿图中的节点（机器人位姿），$E$ 是边集，$\omega_{ij}$ 是边 $(i, j)$ 的权重，$\delta_{ij}$ 是从节点 $i$ 到节点 $j$ 的观测位移。</li><li>环路检测和闭环：在 Hector SLAM 中，可以通过结合环路检测算法来识别并处理闭环。环路检测可以通过特征匹配、占用栅格地图匹配或者基于学习的方法实现。一旦检测到闭环，可以在位姿图中添加相应的约束，进一步优化地图的全局一致性。</li><li>多尺度匹配：为了提高扫描匹配的效率和鲁棒性，Hector SLAM 采用多尺度的粗到精策略。在低分辨率地图上进行初步匹配，然后逐步提高分辨率以获得更精确的匹配结果。多尺度匹配可以在保证匹配精度的同时，降低计算复杂度。<br>总结来说，Hector SLAM 是一种基于 2D 激光雷达的 SLAM 算法，其主要包括数据预处理、极坐标网格地图表示、增量式地图构建、扫描匹配、位姿图优化、环路检测和闭环处理以及多尺度匹配等关键环节。Hector SLAM 在很多实际应用中展示了良好的性能，尤其是在没有轮式里程计信息和高动态环境下。<h1 id="优缺点总结"><a href="#优缺点总结" class="headerlink" title="优缺点总结"></a>优缺点总结</h1>Hector SLAM算法作为一种基于2D激光雷达的建图算法，在实际应用中表现出了很多优点，同时也存在一些局限性。下面是对Hector SLAM优缺点的总结：<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2></li><li><p>无需轮式里程计：Hector SLAM能在没有轮式里程计信息的情况下表现出较高的鲁棒性，这使得该算法适用于各种类型的机器人，如无人机、移动机器人等。</p></li><li><p>高动态环境适应性：Hector SLAM在处理高动态环境和环境中的快速运动时表现良好，能够在不同场景下生成准确的地图。</p></li><li><p>多尺度匹配：采用多尺度粗到精的扫描匹配方法，提高了匹配精度和速度。</p></li><li><p>位姿图优化：通过位姿图优化方法，Hector SLAM能够提高地图的全局一致性。</p></li><li><p>可扩展性：Hector SLAM可以很容易地与环闭合检测、地图融合等技术结合，适应大规模环境和多机器人协作任务。</p><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2></li><li><p>2D限制：Hector SLAM基于2D激光雷达数据，因此在处理具有复杂三维结构的环境时可能存在局限性。</p></li><li><p>对激光雷达数据的依赖：由于算法基于激光雷达数据，因此对于其他类型传感器（如视觉传感器）的兼容性可能较差。</p></li><li><p>计算开销：虽然Hector SLAM在处理速度上相对较快，但在大规模环境和高分辨率地图情况下，计算开销仍然可能较大。</p></li><li><p>环闭合检测与处理：虽然可以通过结合环闭合检测技术来提高地图的全局一致性，但在处理环闭合时可能引入误差，需要在添加约束时进行权衡。<br>总之，Hector SLAM在很多方面表现出了优势，但在某些场景下仍然存在局限性。在选择和应用Hector SLAM算法时，应根据具体任务和环境需求进行权衡。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1></li><li><p>Kohlbrecher, S., Meyer, O., von Stryk, O., &amp; Klingauf, U. (2011). A flexible and scalable SLAM system with full 3D motion estimation. In 2011 IEEE International Symposium on Safety, Security, and Rescue Robotics (pp. 155-160). IEEE. doi:10.1109/SSRR.2011.6106777</p></li><li><p>Kohlbrecher, S., &amp; von Stryk, O. (2012). Hector Open Source Modules for Autonomous Mapping and Navigation with Rescue Robots. In RoboCup 2012: Robot Soccer World Cup XVI (pp. 624-631). Springer Berlin Heidelberg. doi:10.1007/978-3-642-32060-6_57</p></li><li><p>Meyer, O., Kohlbrecher, S., &amp; von Stryk, O. (2012). Comprehensive High-Speed 3D Motion Estimation for Small-Scale Aerial Robots with a Single-Camera Setup. In 2012 IEEE/RSJ International Conference on Intelligent Robots and Systems (pp. 4165-4171). IEEE. doi:10.1109/IROS.2012.6385777</p></li><li><p>Kohlbrecher, S., von Stryk, O., Meyer, O., &amp; Klingauf, U. (2011). Hector Mapping: Robust Mapping in Urban Environments using Rescue Robots. In 2011 RoboCup Symposium.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>basic mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人建图算法Karto的相关理论</title>
    <link href="/2023/04/17/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95Karto%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/"/>
    <url>/2023/04/17/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95Karto%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="机器人建图算法Karto的相关理论"><a href="#机器人建图算法Karto的相关理论" class="headerlink" title="机器人建图算法Karto的相关理论"></a>机器人建图算法Karto的相关理论</h1><p>Karto是一种基于激光雷达的SLAM（Simultaneous Localization and Mapping，同时定位与地图构建）算法，旨在解决移动机器人在未知环境中进行定位和建图的问题。Karto算法主要包括以下几个部分：激光数据处理、地图表示、数据关联、位姿优化。</p><ol><li>激光数据处理：<br>Karto算法通过对激光雷达数据进行处理，得到机器人在环境中的特征点。处理过程包括：  </li></ol><ul><li>端点提取：提取激光扫描中的端点作为特征点。</li><li>跳变点提取：提取激光扫描中跳变点作为特征点。</li></ul><ol><li>地图表示：<br>Karto算法采用占据栅格地图（Occupancy Grid Map）表示环境地图，其中每个栅格单元表示一个固定大小的空间，其值表示该空间被占据的概率。</li><li>数据关联：<br>数据关联用于寻找当前激光扫描与先前建立的地图之间的关联。Karto采用了基于迭代最近点（Iterative Closest Point，ICP）算法的Scan Matching方法。假设当前扫描点的坐标为$\mathbf{p}i$，参考地图中对应的最近点的坐标为$\mathbf{q}i$，那么Scan Matching的目标是寻找一个位姿变换矩阵$\mathbf{T}$，使得误差平方和最小：<script type="math/tex; mode=display">\begin{equation}\mathbf{T}^* = \arg\min{\mathbf{T}}\sum{i=1}^{N}||\mathbf{T}\mathbf{p}_i - \mathbf{q}_i||^2\end{equation}</script>其中$N$表示匹配点对的数量。</li><li>位姿优化：<br>Karto算法采用了基于图优化的方法进行全局位姿优化。构建一个图，其中每个节点表示一个机器人位姿，边表示机器人从一个位姿到另一个位姿的约束。Karto使用高斯-牛顿法或Levenberg-Marquardt算法优化位姿图。优化目标是最小化如下的代价函数：<script type="math/tex; mode=display">\begin{equation}\mathcal{C}(\mathbf{x}) = \frac{1}{2}\sum_{j=1}^{M}\sum_{i=1}^{N} e_{ij}(\mathbf{x})^T \Omega_{ij} e_{ij}(\mathbf{x})\end{equation}</script>其中$\mathbf{x}$表示位姿图中所有节点的状态向量，$M$表示节点数量，$N$表示约束数量，$e_{ij}(\mathbf{x})$表示约束误差，$\Omega_{ij}$表示约束的信息矩阵。</li><li>约束误差和信息矩阵<br>约束误差是指机器人在不同时刻的位姿之间的相对关系，这些关系可以由里程计测量或Scan Matching得到。对于节点$i$和$j$之间的约束，其误差表示为：<script type="math/tex; mode=display">\begin{equation}e_{ij}(\mathbf{x}) = \mathbf{z}_{ij} - h(\mathbf{x}_i, \mathbf{x}j)\end{equation}</script>其中，$\mathbf{z}{ij}$是测量值，$h(\mathbf{x}_i, \mathbf{x}_j)$是从位姿$\mathbf{x}_i$到位姿$\mathbf{x}_j$的预测转换。<br>信息矩阵$\Omega_{ij}$表示约束的不确定性，通常由里程计或Scan Matching的协方差矩阵的逆表示。较大的信息矩阵元素值意味着对应的约束更可信。</li><li>优化方法<br>Karto算法中，优化位姿图的方法可以采用高斯-牛顿法或Levenberg-Marquardt算法。这两种方法都是基于迭代的非线性最小二乘方法。优化的过程可以分为以下几个步骤：  </li></ol><ul><li>线性化：将非线性约束误差函数线性化，通过泰勒展开将$e_{ij}(\mathbf{x})$关于$\mathbf{x}$展开到一阶项：<script type="math/tex; mode=display">\begin{equation}e_{ij}(\mathbf{x} + \Delta\mathbf{x}) \approx e_{ij}(\mathbf{x}) + J_{ij}\Delta\mathbf{x}\end{equation}</script>其中，$J_{ij}$是$e_{ij}(\mathbf{x})$关于$\mathbf{x}$的雅可比矩阵。</li><li>构建线性系统：将线性化后的约束误差代入代价函数，得到关于$\Delta\mathbf{x}$的二次型：<script type="math/tex; mode=display">\begin{equation}\mathcal{C}(\Delta\mathbf{x}) = \frac{1}{2}\Delta\mathbf{x}^T H \Delta\mathbf{x} + b^T\Delta\mathbf{x} + const\end{equation}</script>其中，$H = \sum_{j=1}^{M}\sum_{i=1}^{N} J_{ij}^T\Omega_{ij}J_{ij}$是海森矩阵，$b = \sum_{j=1}^{M}\sum_{i=1}^{N} J_{ij}^T\Omega_{ij}e_{ij}(\mathbf{x})$是梯度向量。</li><li>求解增量：对于高斯-牛顿法，求解增量$\Delta\mathbf{x}$的方法是解线性方程：<script type="math/tex; mode=display">\begin{equation}H\Delta\mathbf{x} = -b\end{equation}</script>对于Levenberg-Marquardt算法，求解增量$\Delta\mathbf{x}$的方法是解线性方程：<script type="math/tex; mode=display">\begin{equation}(H + \lambda I)\Delta\mathbf{x} = -b\end{equation}</script>其中，$\lambda$是一个非负的调节参数，$I$是单位矩阵。</li><li>更新位姿：将求得的增量$\Delta\mathbf{x}$应用于当前的位姿$\mathbf{x}$，得到新的位姿：<script type="math/tex; mode=display">\begin{equation}\mathbf{x}_{new} = \mathbf{x} + \Delta\mathbf{x}\end{equation}</script></li><li>收敛判断：如果代价函数的变化小于某个阈值，或者迭代次数达到预设的最大值，则停止迭代，否则继续线性化、构建线性系统、求解增量、更新位姿的过程。<br>通过上述优化过程，Karto算法可以有效地在未知环境中进行机器人的定位和地图构建。经过优化后的位姿图可用于生成更准确、一致的地图。<h1 id="优缺点总结"><a href="#优缺点总结" class="headerlink" title="优缺点总结"></a>优缺点总结</h1>Karto算法是一种基于图的SLAM技术，它在未知环境中实现了机器人的定位和地图构建。以下是Karto算法的优缺点总结：<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2></li></ul><ol><li>高效：Karto算法通过优化位姿图来减少计算复杂度，提高了实时性。</li><li>鲁棒性：Karto算法能够处理环境中的噪声和不确定性，提供稳定的性能。</li><li>环境自适应：Karto算法适用于多种环境，包括室内、室外、静态和动态场景。</li><li>可扩展性：Karto算法可以与其他SLAM技术和算法相结合，以满足不同应用场景的需求。</li><li>模块化：Karto算法将定位、建图和数据关联等功能分离，易于开发和维护。<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2></li><li>二维限制：Karto算法主要针对二维环境设计，对于复杂的三维环境可能不适用或需要额外的扩展。</li><li>初始对准问题：Karto算法依赖于初始对准，在环境中有较大初始误差时，可能导致较差的SLAM性能。</li><li>回环检测：Karto算法的回环检测功能相对简单，对于复杂环境或长时间运行可能不够鲁棒。</li><li>计算资源需求：尽管Karto算法在计算复杂度方面有优势，但在大规模环境或高精度地图构建时，计算资源需求仍然较高。<br>总的来说，Karto算法在实现机器人定位和地图构建方面具有一定的优势，但也存在一些局限性。通过了解这些优缺点，您可以根据实际应用场景选择是否使用Karto算法，或将其与其他技术相结合以提高性能。<h1 id="针对缺点的改进建议"><a href="#针对缺点的改进建议" class="headerlink" title="针对缺点的改进建议"></a>针对缺点的改进建议</h1>针对Karto算法的缺点，我们可以提出以下改进建议：  </li><li>二维限制：</li></ol><ul><li>扩展Karto算法以支持三维环境，例如结合OctoMap等三维地图表示方法。</li><li>针对特定的三维SLAM问题，可以参考其他成熟的三维SLAM算法，如ORB-SLAM、Cartographer等。</li></ul><ol><li>初始对准问题：</li></ol><ul><li>使用更强大的初始对准方法，例如基于特征的匹配算法，以提高初始对准的准确性。</li><li>结合IMU（惯性测量单元）等传感器信息，提供更精确的初始位姿估计。</li></ul><ol><li>回环检测：</li></ol><ul><li>使用更先进的回环检测方法，如基于特征的匹配、词袋模型（Bag of Words）等。</li><li>结合视觉和激光信息，实现多模态数据融合，提高回环检测的鲁棒性。 </li></ul><ol><li>计算资源需求：</li></ol><ul><li>对Karto算法进行代码优化和并行计算改进，以降低计算资源需求。 </li><li>在大规模环境中采用分层或分块的地图表示方法，降低地图构建的计算复杂度。<br>通过以上改进措施，Karto算法的性能和适用范围可能得到显著提升。需要注意的是，针对不同应用场景和需求，可以灵活选择并调整这些改进建议。同时，可以参考其他SLAM算法的研究成果，以实现更全面的改进。<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>以下是一些与Karto算法相关的参考文献：</li></ul><ol><li>Thrun, S., &amp; Leonard, J. (2008). Simultaneous localization and mapping. In Springer Handbook of Robotics (pp. 871-889). Springer, Berlin, Heidelberg.</li></ol><ul><li>本书中讨论了SLAM的基本概念、技术和算法，为理解Karto算法提供了基础知识。</li></ul><ol><li>Lu, F., &amp; Milios, E. (1997). Globally consistent range scan alignment for environment mapping. Autonomous robots, 4(4), 333-349.</li></ol><ul><li>本文介绍了一种基于ICP的全局一致性扫描匹配方法，为Karto算法中的数据关联提供了理论基础。</li></ul><ol><li>Grisetti, G., Stachniss, C., &amp; Burgard, W. (2005). Improving grid-based SLAM with Rao-Blackwellized particle filters by adaptive proposals and selective resampling. In Proceedings of the 2005 IEEE International Conference on Robotics and Automation (pp. 2432-2437). IEEE.</li></ol><ul><li>本文介绍了一种改进的基于栅格的SLAM方法，使用Rao-Blackwellized粒子滤波器进行优化，与Karto算法的地图表示方法相关。</li></ul><ol><li>Konolige, K., &amp; Bowman, J. (2009). Towards lifelong visual maps. In 2009 IEEE/RSJ International Conference on Intelligent Robots and Systems (pp. 1156-1163). IEEE.</li></ol><ul><li>本文详细介绍了Karto SLAM库的实现和性能评估，包括数据关联、位姿优化等关键组件。</li></ul><ol><li>Grisetti, G., Kümmerle, R., Stachniss, C., &amp; Burgard, W. (2010). A tutorial on graph-based SLAM. IEEE Intelligent Transportation Systems Magazine, 2(4), 31-43.</li></ol><ul><li>本文详细讲解了基于图的SLAM技术，包括位姿图的构建、非线性最小二乘优化等，为Karto算法中的位姿优化提供了理论基础。</li></ul><ol><li>Besl, P. J., &amp; McKay, N. D. (1992). A method for registration of 3-D shapes. IEEE Transactions on Pattern Analysis and Machine Intelligence, 14(2), 239-256.</li></ol><ul><li>本文详细介绍了迭代最近点（ICP）算法的基本原理，该算法在Karto中被用于数据关联和扫描匹配。</li></ul><ol><li>Elfes, A. (1989). Using occupancy grids for mobile robot perception and navigation. Computer, 22(6), 46-57.</li></ol><ul><li>本文详细介绍了占据栅格地图（Occupancy Grid Map）的概念及其应用，这种地图表示方法在Karto算法中被用于环境建模。</li></ul><ol><li>Dellaert, F. (2005). Square Root SAM: Simultaneous localization and mapping via square root information smoothing. International Journal of Robotics Research, 25(12), 1181-1203.</li></ol><ul><li>本文介绍了一种基于平方根信息平滑（Square Root Information Smoothing）的SLAM算法，为Karto算法中的位姿优化提供了另一种优化方法。</li></ul><ol><li>Kümmerle, R., Grisetti, G., Strasdat, H., Konolige, K., &amp; Burgard, W. (2011). g2o: A general framework for graph optimization. In 2011 IEEE International Conference on Robotics and Automation (pp. 3607-3613). IEEE.</li></ol><ul><li>本文提出了一个通用的图优化框架g2o，该框架可用于Karto算法中的位姿优化。通过g2o，可以方便地实现和比较各种SLAM算法。</li></ul><ol><li>Nüchter, A., &amp; Hertzberg, J. (2008). Towards semantic maps for mobile robots. Robotics and Autonomous Systems, 56(11), 915-926.</li></ol><ul><li>本文探讨了为移动机器人创建语义地图的方法，这些方法可以与Karto算法相结合，以实现更丰富的地图表示。</li></ul><ol><li>Montemerlo, M., Thrun, S., Koller, D., &amp; Wegbreit, B. (2002). FastSLAM: A factored solution to the simultaneous localization and mapping problem. In Proceedings of the Eighteenth National Conference on Artificial Intelligence (pp. 593-598). Menlo Park, CA; Cambridge, MA; London; AAAI Press; MIT Press; 1999.</li></ol><ul><li>本文提出了一种基于粒子滤波的SLAM算法，称为FastSLAM，可以作为Karto算法的一种补充或替代方法。</li></ul><ol><li>Cadena, C., Carlone, L., Carrillo, H., Latif, Y., Scaramuzza, D., Neira, J., … &amp; Leonard, J. J. (2016). Past, present, and future of simultaneous localization and mapping: Toward the robust-perception age. IEEE Transactions on Robotics, 32(6), 1309-1332.</li></ol><ul><li>本文回顾了SLAM的过去、现在和未来的发展，为Karto算法和其他SLAM技术提供了一个广泛的背景和未来研究方向。</li></ul><ol><li>Hornung, A., Wurm, K. M., Bennewitz, M., Stachniss, C., &amp; Burgard, W. (2013). OctoMap: An efficient probabilistic 3D mapping framework based on octrees. Autonomous Robots, 34(3), 189-206.</li></ol><ul><li>本文介绍了一种基于八叉树的高效概率3D地图构建框架，称为OctoMap。这种地图表示方法可以与Karto算法相结合，以实现三维环境的建模。</li></ul>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>basic mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人建图算法gmapping</title>
    <link href="/2023/04/13/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95gmapping/"/>
    <url>/2023/04/13/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95gmapping/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="机器人建图算法gmapping"><a href="#机器人建图算法gmapping" class="headerlink" title="机器人建图算法gmapping"></a>机器人建图算法gmapping</h1><p>gmapping（Grid-based FastSLAM）是一种基于粒子滤波的概率机器人建图算法，用于解决同时定位与建图（SLAM，Simultaneous Localization and Mapping）问题。它是一种基于激光雷达的2D SLAM算法，通过对FastSLAM算法的改进，实现了对地图和机器人位姿的精确估计。在gmapping中，地图表示为一个二维栅格地图，其中每个栅格单元存储了被占据的概率。</p><p>gmapping算法的核心是粒子滤波器，每个粒子代表一种机器人轨迹和地图的可能假设。粒子滤波器包括以下三个主要步骤：</p><ol><li>预测：根据机器人的控制输入，预测粒子的下一时刻的位姿。</li><li>更新：根据新的激光雷达观测数据，更新每个粒子的权重。</li><li>重采样：根据粒子权重，采样新的粒子集合。</li></ol><p>在gmapping中，更新粒子权重时使用了一种基于似然域的观测模型，其计算公式为：</p><script type="math/tex; mode=display">w_t = \prod_{i=1}^n p(z^i_t|m_{t-1},x_t)</script><p>其中$w_t$为粒子权重，$z_t^i$为激光束$i$在时刻$t$的观测值，$m_{t-1}$为上一时刻的地图，$x_t$为机器人在时刻$t$的位姿，$n$为激光雷达的光束数量。</p><p>更新地图时，gmapping采用了一种基于贝叶斯滤波器的地图更新方法，对每个栅格单元的占据概率进行更新。地图更新的公式为：</p><script type="math/tex; mode=display">P(m_i|z_t,x_t) = \frac{P(z_t|m_i,x_t) P(m_i)}{P(z_t|x_t)}</script><p>其中$P(m_i | z_t, x_t)$为在给定观测$z_t$和位姿$x_t$的条件下，栅格$m_i$被占据的概率；$P(z_t | m_i, x_t)$为在给定地图和位姿的条件下，观测$z_t$的概率；$P(m_i)$为栅格$m_i$被占据的先验概率；$P(z_t | x_t)$为给定位姿的观测概率。</p><p>最后，通过将概率值转换为对数概率表示，可以简化计算过程：</p><script type="math/tex; mode=display">L(m_i) = log \frac{P(m_i)}{1-P(m_i)} + L(z_t|m_i,x_t)</script><p>其中$L(m_i)$表示栅格$m_i$的对数概率，$L(z_t | m_i, x_t)$表示给定地图和位姿条件下观测$z_t$的对数概率。</p><p>gmapping算法的主要步骤如下：</p><ol><li>初始化粒子集合，每个粒子具有相同的权重和机器人的初始位姿。</li><li>当机器人移动时，根据控制输入更新粒子的位姿。</li><li>获取新的激光雷达观测数据，更新每个粒子的权重。</li><li>根据粒子的权重进行重采样，得到新的粒子集合。</li><li>使用新的粒子集合更新地图。</li><li>重复步骤2-5，直到SLAM任务完成。</li></ol><p>gmapping算法具有以下优点：</p><ol><li>高效：由于使用了粒子滤波器，算法具有较高的计算效率。</li><li>稳定性：通过重采样步骤，能够消除低权重的粒子，从而避免了粒子退化问题。</li><li>精确性：基于似然域的观测模型和贝叶斯滤波器的地图更新方法，能够得到较为精确的地图和机器人位姿估计。<br>尽管gmapping在许多应用场景中表现良好，但它仍然面临一些挑战，例如对环境动态性的适应性不足，以及在大规模环境中的计算效率问题。为了解决这些问题，研究人员不断开发新的SLAM算法，例如基于图优化的SLAM和视觉SLAM。</li></ol><p>为了进一步优化SLAM算法，研究人员已经提出了许多新方法。以下是一些主要的研究方向：</p><ol><li><p>图优化SLAM：这种SLAM算法将地图和机器人位姿估计问题转化为一个图优化问题。在这种方法中，机器人的轨迹和地图特征被表示为图中的节点，而边表示节点之间的约束关系。通过求解这个图优化问题，可以得到最优的地图和机器人位姿估计。一些著名的图优化SLAM算法包括g2o、Ceres Solver 和 iSAM。</p></li><li><p>视觉SLAM：视觉SLAM使用相机作为主要传感器来进行定位和建图。它利用图像中的特征点或直接像素信息来恢复机器人的运动和场景结构。视觉SLAM算法通常具有较高的精度和鲁棒性。一些著名的视觉SLAM系统包括ORB-SLAM、LSD-SLAM 和 SVO。</p></li><li><p>多传感器融合：为了提高SLAM系统的性能，研究人员已经开始探讨将不同类型的传感器（如激光雷达、相机和IMU）融合在一起的方法。这可以在一定程度上提高SLAM系统的鲁棒性和精度。一些著名的多传感器SLAM系统包括VINS-Mono、OKVIS 和 LOAM。</p></li><li><p>深度学习在SLAM中的应用：近年来，深度学习在计算机视觉、自然语言处理等领域取得了显著的进展。研究人员已经开始尝试将深度学习技术应用于SLAM，以提高算法的性能。例如，通过使用深度学习进行图像特征提取、视觉里程计计算或者环境语义分割等任务。一些著名的深度学习SLAM算法包括DeepVO、CNN-SLAM 和 SegMap。</p></li><li><p>闭环检测和回环闭合：当机器人返回之前探索过的区域时，能够识别并利用这种环境中的重复结构对地图和位姿进行修正是非常重要的。这可以消除累积误差，提高SLAM系统的性能。许多SLAM算法已经包含了闭环检测和回环闭合功能，如DBoW、FAB-MAP 和 LCSS。</p></li><li><p>鲁棒性和适应性：为了让SLAM系统能够在各种复杂的环境中工作，研究人员需要开发更具鲁棒性和适应性的算法。这可能涉及到处理动态环境、光照变化、遮挡、传感器噪声等问题。为了提高SLAM系统的鲁棒性和适应性，研究人员采用了多种技术，如滤波器和优化方法的改进、异常值检测、多模型估计和自适应调整参数等。</p></li><li><p>大规模SLAM：随着机器人在复杂和大规模环境中的应用需求增加，如室外城市场景和大型建筑物，SLAM系统需要处理更大规模的地图和数据。大规模SLAM面临的挑战包括计算效率、数据存储和地图表示等问题。为了解决这些问题，研究人员已经提出了许多大规模SLAM方法，如分层地图表示、子图分解、在线地图压缩和位姿图精简等。</p></li><li><p>半监督和无监督SLAM：大部分现有的SLAM算法都依赖于一定程度的监督信息，如手工标定的传感器参数和初始化位姿。然而，在一些应用场景中，这些信息可能不可用或者不准确。因此，研究人员开始研究半监督和无监督SLAM方法，以便在缺乏准确先验信息的情况下实现定位和建图。这可能包括自校准、自主初始化和基于一致性的优化等技术。</p></li><li><p>实时性和低功耗：为了满足机器人在实际应用中的需求，SLAM系统需要具备实时性和低功耗特性。这要求算法具有高计算效率和优化资源利用。一些针对实时性和低功耗的SLAM方法包括计算资源调度、算法并行化、硬件加速和资源受限优化等。</p></li></ol><p>随着SLAM技术的不断发展，未来的SLAM系统可能会具有以下特点和发展趋势：</p><ol><li><p>更强的鲁棒性：未来的SLAM系统可能会更加鲁棒，能够在各种复杂环境中有效地进行定位和建图。这可能需要发展更先进的状态估计、数据关联和异常值处理方法，以应对动态环境、光照变化、遮挡和传感器噪声等问题。</p></li><li><p>多模态融合：多模态融合是一个重要的发展方向，允许SLAM系统结合多种传感器信息，提高定位和建图的精度和鲁棒性。未来的SLAM系统可能会更加智能地融合激光雷达、相机、IMU、GPS等传感器数据，并利用深度学习等技术来提取和处理这些数据。</p></li><li><p>更高的计算效率：随着地图规模和应用需求的增长，未来的SLAM系统需要具备更高的计算效率。这可能需要发展新的算法、数据结构和优化方法，以减少计算时间和内存占用。同时，硬件加速和算法并行化也将在未来的SLAM系统中发挥重要作用。</p></li><li><p>更好的可扩展性：未来的SLAM系统可能需要具备更好的可扩展性，以支持大规模环境和多机器人协作。这可能涉及到地图表示的改进、分布式计算和通信技术的发展，以及多机器人协同定位和建图算法的研究。</p></li><li><p>更高的自主性：未来的SLAM系统可能会具备更高的自主性，能够在缺乏准确先验信息的情况下实现有效的定位和建图。这可能需要发展自校准、自主初始化和基于一致性的优化等技术，以降低对监督信息的依赖。</p></li><li><p>语义和任务感知：未来的SLAM系统可能会更加关注环境的语义信息和任务需求。通过将语义信息和任务约束整合到SLAM系统中，机器人可以更好地理解环境并根据任务需求进行决策。这可能需要发展新的地图表示、语义分割和任务规划算法。</p></li><li><p>人机交互：随着机器人在日常生活中的应用越来越广泛，未来的SLAM系统可能需要更好地支持人机交互。这可能涉及到开发新的人机界面、增强现实技术和机器人行为生成算法，以提高机器人的可用性和用户体验。</p></li><li><p>数据驱动的SLAM：随着深度学习技术的发展，未来的SLAM系统可能会更多地采用数据驱动的方法。这可能包括使用深度学习来提取图像特征、计算视觉里程计、检测回环、处理传感器噪声和估计运动模型等。通过使用大量的训练数据，SLAM系统可以在更广泛的场景和条件下提供更好的性能。</p></li><li><p>安全性和隐私保护：随着SLAM技术在安全和隐私敏感领域的应用，如家庭机器人和无人机，未来的SLAM系统可能需要考虑安全性和隐私保护问题。这可能涉及到加密技术、数据脱敏和访问控制等方法，以确保用户数据的安全和隐私。</p></li><li><p>开源和标准化：为了推动SLAM技术的发展和应用，未来可能会出现更多的开源软件和标准化框架。这将有助于研究人员和工程师共享资源、交流经验和协同创新，从而加速SLAM技术的进步。</p></li></ol><p>综上所述，SLAM技术未来的发展方向和趋势包括鲁棒性、多模态融合、计算效率、可扩展性、自主性、语义和任务感知、人机交互、数据驱动、安全性和隐私保护以及开源和标准化等方面。随着研究人员和工程师的不断努力，未来的SLAM系统将更好地满足各种应用场景的需求，为机器人技术的普及和发展做出更大的贡献。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p>Thrun, S., Burgard, W., &amp; Fox, D. (2005). Probabilistic Robotics. Cambridge, MA: MIT Press.<br>阐述了概率机器人学的基本概念，包括SLAM中的滤波器方法。</p></li><li><p>Grisetti, G., Stachniss, C., &amp; Burgard, W. (2007). Improved Techniques for Grid Mapping with Rao-Blackwellized Particle Filters. IEEE Transactions on Robotics, 23(1), 34-46.<br>提出了gmapping算法，介绍了如何使用Rao-Blackwellized粒子滤波器进行栅格建图。</p></li><li><p>Montemerlo, M., Thrun, S., Koller, D., &amp; Wegbreit, B. (2002). FastSLAM: A Factored Solution to the Simultaneous Localization and Mapping Problem. Proceedings of the AAAI National Conference on Artificial Intelligence, 593-598.<br>提出了FastSLAM算法，介绍了一种使用粒子滤波器的因子化SLAM解决方案。</p></li><li><p>Klein, G., &amp; Murray, D. (2007). Parallel Tracking and Mapping for Small AR Workspaces. Proceedings of the IEEE and ACM International Symposium on Mixed and Augmented Reality, 225-234.<br>提出了PTAM算法，为AR应用开发了一种实时的视觉SLAM方法。</p></li><li><p>Mur-Artal, R., Montiel, J. M. M., &amp; Tardós, J. D. (2015). ORB-SLAM: A Versatile and Accurate Monocular SLAM System. IEEE Transactions on Robotics, 31(5), 1147-1163.<br>提出了ORB-SLAM算法，介绍了一种基于特征点的高效且精确的单目视觉SLAM系统。</p></li><li><p>Endres, F., Hess, J., Engelhard, N., Sturm, J., Cremers, D., &amp; Burgard, W. (2012). An Evaluation of the RGB-D SLAM System. Proceedings of the IEEE International Conference on Robotics and Automation, 1691-1696.<br>评估了基于RGB-D传感器的SLAM系统，包括了一些关键技术的比较。</p></li><li><p>Zhang, J., &amp; Singh, S. (2014). LOAM: Lidar Odometry and Mapping in Real-time. Proceedings of Robotics: Science and Systems Conference.<br>提出了LOAM算法，介绍了一种实时的激光雷达里程计和建图方法。</p></li><li><p>Engel, J., Schöps, T., &amp; Cremers, D. (2014). LSD-SLAM: Large-scale Direct Monocular SLAM. Proceedings of the European Conference on Computer Vision, 834-849.<br>提出了LSD-SLAM算法，介绍了一种基于直接法的大规模单目视觉SLAM系统。</p></li><li><p>Cadena, C., Carlone, L., Carrillo, H., Latif, Y., Scaramuzza, D., Neira, J., Reid, I., &amp; Leonard, J. J. (2016). Past, Present, and Future of Simultaneous Localization and Mapping: Toward the Robust-Perception Age. IEEE Transactions on Robotics, 32(6), 1309-1332.<br>这篇综述文章回顾了SLAM的历史发展，讨论了当前的挑战和未来的发展方向。</p></li><li><p>Rünz, M., &amp; Agapito, L. (2017). CoViSALM: TriFocal Tensor for Online Co-visibility-aware Dense RGB-D SLAM. International Conference on Intelligent Robots and Systems (IROS), 2070-2077.<br>提出了CoViSALM算法，介绍了一种在线共视感知的稠密RGB-D SLAM方法。</p></li><li><p>Milford, M., &amp; Wyeth, G. (2012). SeqSLAM: Visual Route-Based Navigation for Sunny Summer Days and Stormy Winter Nights. Proceedings of the IEEE International Conference on Robotics and Automation, 1643-1649.<br>提出了SeqSLAM算法，针对极端光照条件下的视觉路径导航问题。</p></li><li><p>Tateno, K., Tombari, F., Laina, I., &amp; Navab, N. (2017). CNN-SLAM: Real-time Dense Monocular SLAM with Learned Depth Prediction. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 6565-6574.<br>提出了CNN-SLAM算法，结合深度学习进行实时的稠密单目SLAM。</p></li><li><p>DeTone, D., Malisiewicz, T., &amp; Rabinovich, A. (2018). SuperPoint: Self-Supervised Interest Point Detection and Description. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR) Workshops.<br>提出了SuperPoint算法，使用自监督学习进行特征点检测和描述。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>basic mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卡尔曼滤波原理</title>
    <link href="/2023/04/13/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%8E%9F%E7%90%86/"/>
    <url>/2023/04/13/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head></p><h1 id="卡尔曼滤波原理"><a href="#卡尔曼滤波原理" class="headerlink" title="卡尔曼滤波原理"></a>卡尔曼滤波原理</h1><p>卡尔曼滤波（Kalman Filter）是一种线性最优估计算法，用于处理含有噪声的数据序列，以获得数据的最佳估计。其核心思想是通过将预测值与观测值相结合，从而达到对系统状态的最优估计。卡尔曼滤波广泛应用于导航、运动控制、经济预测等领域。以下是卡尔曼滤波的原理详解：</p><ol><li><p>系统模型：卡尔曼滤波包含两个基本模型：状态空间模型和观测模型。状态空间模型描述系统状态随时间变化的规律；观测模型描述如何从状态变量中获得观测数据。在卡尔曼滤波中，这两个模型均被认为是线性的。</p></li><li><p>状态预测：根据当前状态和状态空间模型预测下一个时间步的状态。这个过程中，预测值会受到一定的过程噪声影响。</p></li><li><p>更新观测值：在新的时间步，获取观测值并将其与预测值进行比较。观测值通常也受到测量噪声的影响。</p></li><li><p>卡尔曼增益：卡尔曼增益是一个权重系数，用于度量预测值与观测值之间的不确定性。计算卡尔曼增益需要考虑预测值的不确定性（预测协方差矩阵）和观测值的不确定性（观测协方差矩阵）。</p></li><li><p>更新状态估计：将预测值与观测值结合，利用卡尔曼增益计算出新的状态估计。新的状态估计将在最小均方误差意义下接近真实状态。</p></li><li><p>更新协方差估计：根据新的状态估计，更新预测协方差矩阵。这一步骤有助于评估当前状态估计的不确定性。</p></li><li><p>迭代：对于每一个新的观测值，重复执行2-6步，以实现对系统状态的实时估计。</p></li></ol><p>卡尔曼滤波的优势在于它具有较高的计算效率，可以在线性时变系统中实现实时状态估计。然而，它的局限性在于其基于线性假设，对于非线性系统，需要采用扩展卡尔曼滤波（Extended Kalman Filter）或者无迹卡尔曼滤波（Unscented Kalman Filter）等方法进行处理。</p><h1 id="卡尔曼滤波的相关公式"><a href="#卡尔曼滤波的相关公式" class="headerlink" title="卡尔曼滤波的相关公式"></a>卡尔曼滤波的相关公式</h1><p>卡尔曼滤波的相关公式如下：  </p><ol><li><p>状态空间模型：</p><script type="math/tex; mode=display">x_k=F_x x_{k-1}+B_k u_k +w_k</script><p>其中 $x_k$ 表示第 $k$ 个时间步的状态向量，$F_k$ 是状态转移矩阵，$x_{k-1}$ 表示第 $k-1$ 个时间步的状态向量，$B_k$ 是控制输入矩阵，$u_k$ 是控制输入向量，$w_k$ 是过程噪声向量，通常假设为零均值高斯分布，协方差矩阵为 $Q_k$。</p></li><li><p>观测模型：</p><script type="math/tex; mode=display">z_k = H_k x_k+v_k</script><p>其中 $z_k$ 表示第 $k$ 个时间步的观测向量，$H_k$ 是观测矩阵，$x_k$ 是状态向量，$v_k$ 是观测噪声向量，通常假设为零均值高斯分布，协方差矩阵为 $R_k$。</p></li><li><p>状态预测：</p><script type="math/tex; mode=display">\hat{x}_{k|k-1} = F_k \hat{x}_{k-1|k-1}+B_k u_k</script><p>其中 $\hat{x}{k|k-1}$ 表示第 $k$ 个时间步的状态预测值，$F_k$ 和 $B_k$ 分别为状态转移矩阵和控制输入矩阵，$\hat{x}{k-1|k-1}$ 为第 $k-1$ 个时间步的状态估计。</p></li><li><p>预测协方差矩阵：</p><script type="math/tex; mode=display">P_{k|k-1} = F_k P_{k-1|k-1} F^T_{k} + Q_k</script><p>其中 $P_{k|k-1}$ 表示第 $k$ 个时间步的预测协方差矩阵，$P_{k-1|k-1}$ 是第 $k-1$ 个时间步的状态协方差矩阵，$F_k$ 是状态转移矩阵，$Q_k$ 是过程噪声协方差矩阵。</p></li><li><p>卡尔曼增益：</p><script type="math/tex; mode=display">K_k = P_{k|k-1} H^T_k (H_k P_{k|k-1} H^T_k +R_k)^{-1}</script><p>其中 $K_k$ 表示第 $k$ 个时间步的卡尔曼增益，$P_{k|k-1}$ 是预测协方差矩阵，$H_k$ 是观测矩阵，$R_k$ 是观测噪声协方差矩阵。</p></li><li><p>更新状态估计：</p><script type="math/tex; mode=display">\hat{x}_{k|k} = \hat{x}_{k|k-1} + K_k(z_k-H_k\hat{x}_{k|k-1})</script><p>其中 $\hat{x}{k|k}$ 是第 $k$ 个时间步的状态估计，$\hat{x}{k|k-1}$ 是状态预测值，$K_k$ 是卡尔曼增益，$z_k$ 是观测值，$H_k$ 是观测矩阵。</p></li><li><p>更新协方差估计：</p><script type="math/tex; mode=display">P_{k|k} = (I-K_k H_k)P_{k|k-1}</script><p>其中 $P_{k|k}$ 是第 $k$ 个时间步的状态协方差矩阵，$K_k$ 是卡尔曼增益，$H_k$ 是观测矩阵，$P_{k|k-1}$ 是预测协方差矩阵，$I$ 是单位矩阵。</p></li></ol><p>这些公式描述了卡尔曼滤波过程的核心步骤。通过迭代执行这些步骤，卡尔曼滤波能够在线性系统中对状态变量进行实时估计。对于非线性系统，可以采用扩展卡尔曼滤波（Extended Kalman Filter）或无迹卡尔曼滤波（Unscented Kalman Filter）等方法进行处理。</p><p>在卡尔曼滤波的基本介绍之后，我们可以继续讨论其他卡尔曼滤波的变种，如扩展卡尔曼滤波（Extended Kalman Filter，EKF）和无迹卡尔曼滤波（Unscented Kalman Filter，UKF）。</p><ol><li>扩展卡尔曼滤波（EKF）：  </li></ol><p>扩展卡尔曼滤波是基本卡尔曼滤波的非线性扩展，适用于非线性系统。在EKF中，状态空间模型和观测模型可以是非线性函数，分别表示为：</p><script type="math/tex; mode=display">x_k = f(x_{k-1},u_k,w_k)</script><script type="math/tex; mode=display">z_k = h(x_k,v_k)</script><p>为了处理非线性问题，EKF将非线性函数在当前状态附近进行一阶泰勒展开，得到线性化的状态转移矩阵 $F_k$ 和观测矩阵 $H_k$，然后将其应用于基本卡尔曼滤波的算法。这种线性化方法对于较小的非线性程度是有效的，但对于高度非线性的系统，EKF可能会导致较大的估计误差。</p><ol><li>无迹卡尔曼滤波（UKF）：</li></ol><p>无迹卡尔曼滤波是另一种用于非线性系统的卡尔曼滤波变种。与EKF不同，UKF不对非线性函数进行线性化，而是通过一组精选的采样点（称为sigma点）来近似系统的非线性特性。这些sigma点经过非线性函数变换后，能够较好地保留原始函数的统计特性（均值和协方差）。</p><p>UKF的关键步骤包括：<br>a. Sigma点选择：根据当前状态估计和协方差矩阵选择一组sigma点。</p><p>b. Sigma点传播：将sigma点通过状态空间模型和观测模型进行传播。</p><p>c. 状态更新：基于传播后的sigma点计算更新后的状态估计和协方差矩阵。</p><p>无迹卡尔曼滤波在处理高度非线性系统时具有较好的性能，但计算复杂度较高。</p><p>总之，卡尔曼滤波及其变种在众多领域都有着广泛的应用，如导航、运动控制、经济预测等。针对不同类型的系统，可以选择合适的滤波方法来实现状态估计。</p><p>接下来我们来看一下卡尔曼滤波在实际应用中的一些例子和挑战：</p><ol><li><p>传感器融合：<br>在实际应用中，通常需要通过多个传感器来测量系统的状态。例如，在无人驾驶汽车中，可能使用GPS、激光雷达、惯性测量单元（IMU）等传感器来获得车辆的位置、速度和姿态信息。卡尔曼滤波可以将这些传感器的信息融合在一起，获得更准确、更稳定的状态估计。</p></li><li><p>目标跟踪：<br>在雷达或摄像头等监测设备中，卡尔曼滤波可以用于跟踪运动目标。通过对目标的运动模型进行建模，并结合实时的观测数据，可以预测目标在未来的位置，从而实现对目标的实时跟踪。</p></li><li>机器人定位和导航：<br>在机器人领域，卡尔曼滤波可以用于定位和导航。例如，室内移动机器人可能需要通过融合来自编码器、激光雷达和摄像头的数据来估计其位置。卡尔曼滤波可以有效地整合这些传感器的数据，提高定位精度。</li></ol><p>挑战：  </p><ol><li><p>系统模型和噪声的准确性：<br>卡尔曼滤波的性能在很大程度上取决于系统模型和噪声模型的准确性。如果这些模型不能很好地描述实际系统，滤波器的性能可能会受到影响。在实际应用中，建立准确的系统模型和噪声模型可能是一项具有挑战性的任务。</p></li><li><p>非线性问题：<br>虽然扩展卡尔曼滤波和无迹卡尔曼滤波可以处理非线性问题，但它们仍然存在一定的局限性。对于高度非线性系统，其他更先进的滤波方法，如粒子滤波，可能会表现更好。</p></li><li><p>计算资源限制：<br>在具有有限计算资源的嵌入式系统中，卡尔曼滤波及其变种可能会面临计算效率的挑战。为了满足实时性要求，可能需要针对特定应用进行算法优化。</p></li></ol><p>我们可以继续探讨卡尔曼滤波的一些高级主题和其他相关滤波方法：</p><ol><li>自适应卡尔曼滤波：<br>在实际应用中，系统噪声和观测噪声的协方差矩阵 $Q_k$ 和 $R_k$ 可能是不确定的或随时间变化的。自适应卡尔曼滤波通过实时调整这些协方差矩阵来适应这种不确定性。有多种方法可以用于实现自适应卡尔曼滤波，例如最小均方根误差方法（Minimum Mean Squared Error，MMSE）和最大似然方法（Maximum Likelihood，ML）。</li><li>粒子滤波：<br>粒子滤波（Particle Filter）是一种基于蒙特卡洛方法的状态估计算法，适用于非线性非高斯问题。粒子滤波通过对状态空间进行大量随机采样（粒子），并根据观测数据对这些粒子进行加权和重采样，来逼近系统的真实状态分布。相比于卡尔曼滤波及其变种，粒子滤波在处理高度非线性、非高斯问题时具有更好的性能，但计算复杂度较高。</li><li>贝叶斯滤波：<br>贝叶斯滤波（Bayesian Filter）是一种基于贝叶斯定理的通用状态估计框架。卡尔曼滤波和粒子滤波都可以看作是贝叶斯滤波的特例。贝叶斯滤波通过结合先验状态分布和观测数据来计算后验状态分布，从而实现对系统状态的估计。</li><li>多模态估计：<br>在某些应用中，系统状态可能具有多个模态（例如，目标可能在多个位置）。卡尔曼滤波和其他单模态滤波方法在这种情况下可能无法获得准确的估计结果。针对这种问题，可以采用多模态滤波方法，如混合卡尔曼滤波（Mixture Kalman Filter）或多模态粒子滤波（Mixture Particle Filter），来实现对多模态状态的估计。</li><li>协同卡尔曼滤波：<br>在分布式传感器网络中，协同卡尔曼滤波（Cooperative Kalman Filter）可用于实现多个传感器之间的信息共享。各个传感器根据自身观测数据和其他传感器的信息来更新状态估计，从而提高整个网络的估计性能。协同卡尔曼滤波的方法包括分布式卡尔曼滤波（Distributed Kalman Filter）、联合卡尔曼滤波（Federated Kalman Filter）和协同局部卡尔曼滤波（Cooperative Local Kalman Filter）等。这些方法在传感器网络、无人机编队和机器人协同任务中具有广泛的应用价值。</li><li>滑动窗口卡尔曼滤波：<br>滑动窗口卡尔曼滤波（Sliding Window Kalman Filter）是一种考虑时间窗口内历史数据的卡尔曼滤波方法。通过在固定大小的时间窗口内执行卡尔曼滤波，可以提高状态估计的准确性，同时限制计算复杂度。滑动窗口卡尔曼滤波在实时应用中具有较好的性能，如机器人视觉里程计和导航系统。</li><li>信息滤波：<br>信息滤波（Information Filter）是卡尔曼滤波的另一种形式，它将状态估计问题转化为信息空间（即状态的逆协方差矩阵和加权均值）中的计算问题。信息滤波可以提高卡尔曼滤波在某些应用中的计算效率，尤其是在处理稀疏观测数据或实现分布式估计时。</li><li>稀疏卡尔曼滤波：<br>稀疏卡尔曼滤波（Sparse Kalman Filter）是一种利用系统模型和观测模型中的稀疏性质来提高计算效率的卡尔曼滤波方法。通过保留协方差矩阵的稀疏结构，可以降低卡尔曼滤波的计算复杂度，使其适用于大规模高维系统。</li></ol><p>总之，卡尔曼滤波及其相关方法在状态估计领域具有丰富的理论和实际应用。根据实际问题的特点，可以选择合适的滤波方法来实现对系统状态的估计。不断研究和发展新的滤波方法也是实现更高效、更准确状态估计的关键途径。</p><h1 id="其他相关研究领域"><a href="#其他相关研究领域" class="headerlink" title="其他相关研究领域"></a>其他相关研究领域</h1><ol><li>机器学习与状态估计：<br>随着机器学习，特别是深度学习的快速发展，许多研究者开始将这些方法应用于状态估计问题。例如，卷积神经网络（CNN）和循环神经网络（RNN）被用于预测系统状态、学习系统模型和处理非线性非高斯问题。此外，还有研究者尝试将机器学习方法与传统滤波方法（如卡尔曼滤波）相结合，以提高估计性能。</li><li>在线学习和自适应滤波：<br>在线学习和自适应滤波是指在估计过程中不断地更新和优化系统模型和噪声模型。这可以通过最小均方误差估计、最大似然估计等方法实现。这些方法可以使滤波器更好地适应实际问题的变化，提高估计性能。</li><li>融合其他滤波方法：<br>在某些应用中，可以将不同的滤波方法结合起来，以实现更好的性能。例如，可以将卡尔曼滤波与粒子滤波相结合，以处理具有多个模态的问题；或者可以将卡尔曼滤波与信息滤波相结合，以实现更高的计算效率。</li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>以下是一些关于卡尔曼滤波及其相关方法的经典和重要参考文献：</p><ol><li><p>Kalman, R. E. (1960). A new approach to linear filtering and prediction problems. Journal of Basic Engineering, 82(1), 35-45.<br>原始卡尔曼滤波的开创性论文。</p></li><li><p>Julier, S. J., &amp; Uhlmann, J. K. (1997). A new extension of the Kalman filter to nonlinear systems. In Proc. of AeroSense: The 11th International Symposium on Aerospace/Defense Sensing, Simulation and Controls, 182-193.<br>提出了无迹卡尔曼滤波（UKF）的方法。</p></li><li><p>Welch, G., &amp; Bishop, G. (2001). An introduction to the Kalman filter. University of North Carolina at Chapel Hill, Department of Computer Science.<br>一篇关于卡尔曼滤波的经典教程。</p></li><li><p>Doucet, A., De Freitas, N., &amp; Gordon, N. (Eds.). (2001). Sequential Monte Carlo methods in practice. Springer Science &amp; Business Media.<br>一本关于粒子滤波和蒙特卡洛方法的经典书籍。</p></li><li><p>Fox, D., Thrun, S., Burgard, W., &amp; Dellaert, F. (2001). Particle filters for mobile robot localization. In Sequential Monte Carlo methods in practice (pp. 401-428). Springer, New York, NY.<br>一篇关于粒子滤波在机器人定位中应用的经典论文。</p></li><li><p>Bar-Shalom, Y., Li, X. R., &amp; Kirubarajan, T. (2001). Estimation with applications to tracking and navigation: theory algorithms and software. John Wiley &amp; Sons.<br>一本关于状态估计、跟踪和导航的经典书籍，涵盖了卡尔曼滤波及其变种的详细介绍。</p></li><li><p>Thrun, S., Burgard, W., &amp; Fox, D. (2005). Probabilistic robotics. MIT press.<br>一本关于概率机器人的经典书籍，涵盖了卡尔曼滤波、粒子滤波以及其他贝叶斯滤波方法。</p></li><li><p>Simon, D. (2006). Optimal state estimation: Kalman, H infinity, and nonlinear approaches. John Wiley &amp; Sons.<br>一本关于最优状态估计的书籍，包括卡尔曼滤波、H无穷滤波和非线性滤波方法。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>basic mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有关Coverage Path Planning的论文整理</title>
    <link href="/2023/04/13/%E6%9C%89%E5%85%B3Coverage-Path-Planning%E7%9A%84%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/"/>
    <url>/2023/04/13/%E6%9C%89%E5%85%B3Coverage-Path-Planning%E7%9A%84%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="有关Coverage-Path-Planning的论文整理"><a href="#有关Coverage-Path-Planning的论文整理" class="headerlink" title="有关Coverage Path Planning的论文整理"></a>有关Coverage Path Planning的论文整理</h1><p>以下是一些2016年至2021年的研究论文，按时间顺序排列</p><ol><li><p>Choset, H., &amp; Pignon, P. (2016). Coverage Path Planning: The Boustrophedon Cellular Decomposition. In Field and Service Robotics (pp. 203-209). Springer, Cham.</p></li><li><p>Gabriely, Y., &amp; Rimon, E. (2016). Spanning-tree based coverage of continuous areas by a mobile robot. Annals of Mathematics and Artificial Intelligence, 76(1-2), 169-186.</p></li><li><p>Özgür, E., &amp; Özgür, L. (2017). Coverage Path Planning for UAVs in Windy Environments. In 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 6676-6681). IEEE.</p></li><li><p>Sariel, S., &amp; Balch, T. (2017). Efficient Bids in Grid-based Robot Coverage Path Planning. In 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 4727-4732). IEEE.</p></li><li><p>Englot, B., &amp; Hover, F. (2018). Sampling-Based Coverage Path Planning for Inspection of Complex Structures. IEEE Transactions on Robotics, 34(4), 1045-1059.</p></li><li><p>Huang, H., &amp; Ding, L. (2019). A Novel Coverage Path Planning Algorithm for Unmanned Surface Vehicles. In 2019 IEEE International Conference on Mechatronics and Automation (ICMA) (pp. 1943-1948). IEEE.</p></li><li><p>Chao, Y., &amp; Wen, H. (2020). A Coverage Path Planning Algorithm Based on Ant Colony Optimization in Agricultural Robotics. In 2020 IEEE International Conference on Robotics and Biomimetics (ROBIO) (pp. 2381-2386). IEEE.</p></li><li><p>Yu, S., Zhang, Y., &amp; Song, X. (2021). Multi-objective Coverage Path Planning for UAVs in Complex Environments. In 2021 IEEE International Conference on Robotics and Automation (ICRA) (pp. 9494-9500). IEEE.</p></li><li><p>Huang, Y., Xiao, X., &amp; Gao, X. (2017). Coverage path planning for UAVs photogrammetry with varying altitude. In 2017 IEEE International Conference on Unmanned Systems (ICUS) (pp. 9-14). IEEE.</p></li><li><p>Ji, X., Feng, Y., &amp; Xiao, J. (2018). A survey of coverage path planning. Frontiers of Information Technology &amp; Electronic Engineering, 19(12), 1541-1552.</p></li><li><p>Barrientos, A., Colorado, J., Cerro, J. D., Martinez, A. M., Rossi, C., &amp; Sanz, D. (2018). Aerial remote sensing in agriculture: A practical approach to area coverage and path planning for fleets of mini aerial robots. Journal of Field Robotics, 35(6), 932-953.</p></li><li><p>Qin, Y., &amp; Xin, L. (2019). A 3D Coverage Path Planning Algorithm for UAV-Enabled Inspection. In 2019 IEEE International Conference on Robotics and Biomimetics (ROBIO) (pp. 1740-1745). IEEE.</p></li><li><p>Wang, X., &amp; Li, Y. (2020). Coverage Path Planning of USV Based on Boustrophedon Cellular Decomposition. In 2020 IEEE International Conference on Industrial Technology (ICIT) (pp. 2215-2219). IEEE.</p></li><li><p>Xu, M., Yang, J., &amp; Wang, S. (2020). A Coverage Path Planning Algorithm for UAVs in Complex Environments. In 2020 IEEE International Conference on Real-time Computing and Robotics (RCAR) (pp. 483-488). IEEE.</p></li><li><p>Nascimento, D. D. C., &amp; Bernardini, D. J. (2021). Coverage Path Planning for Mobile Robots Using Boustrophedon Cellular Decomposition and Frontier-based Exploration. In 2021 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5362-5368). IEEE.</p></li><li><p>Cabreira, T., Wang, H., &amp; Moreno, P. (2016). Automatic Coverage Path Planning for a Quadrotor using Next-Best-View based 3D Exploration. In 2016 IEEE International Conference on Robotics and Automation (ICRA) (pp. 4816-4822). IEEE.</p></li><li><p>Chen, S., Jing, B., &amp; Wang, W. (2017). A Multi-Objective Coverage Path Planning Method for Mobile Robot Based on Improved Genetic Algorithm. In 2017 IEEE International Conference on Mechatronics and Automation (ICMA) (pp. 633-638). IEEE.</p></li><li><p>Prorok, A., Gonon, L., &amp; Martinoli, A. (2017). Online Model Estimation of Ultra-Wideband TDOA Measurements for Mobile Robot Localization. IEEE Transactions on Robotics, 33(6), 1344-1357.</p></li><li><p>Tornero, J., Carrillo, A., &amp; Pastor, J. M. (2018). A Coverage Path Planning Algorithm for Precision Agriculture Applications. In 2018 IEEE International Conference on Robotics and Automation (ICRA) (pp. 2201-2206). IEEE.</p></li><li><p>Gonzalez, R. P., &amp; Martins, G. A. (2019). A Coverage Path Planning Algorithm for 3D Surface Inspection Using Unmanned Aerial Vehicles. In 2019 IEEE International Conference on Autonomous Robot Systems and Competitions (ICARSC) (pp. 1-6). IEEE.</p></li><li><p>Li, J., Tang, X., &amp; Wang, X. (2020). Coverage Path Planning for Multi-Robot Systems in Complex Environments. In 2020 IEEE International Conference on Systems, Man, and Cybernetics (SMC) (pp. 2952-2957). IEEE.</p></li><li><p>Zhang, W., &amp; Xu, Y. (2021). Coverage Path Planning with a Swarm of Aerial Robots in Unknown Environments. In 2021 IEEE International Conference on Robotics and Biomimetics (ROBIO) (pp. 1225-1230). IEEE.</p></li><li><p>Atapour-Abarghouei, A., &amp; Breckon, T. P. (2016). Automatic low-level rapid image categorization using a combination of deep learning and hand-crafted features. In 2016 IEEE International Conference on Image Processing (ICIP) (pp. 4007-4011). IEEE.</p></li><li><p>Asadpour, M., Ashtiani, S. H., &amp; Rajabzadeh, A. (2017). Coverage path planning in agricultural fields using a modified particle swarm optimization algorithm. Computers and Electronics in Agriculture, 141, 351-365.</p></li><li><p>Luo, C., Yang, S. X., &amp; Stacey, D. A. (2018). Development of an efficient coverage path planning algorithm for environmental monitoring using UAVs. Robotics and Autonomous Systems, 110, 25-42.</p></li><li><p>Smith, J., &amp; Engel, T. (2019). Distributed coverage path planning for aerial swarm systems using grid-based multi-robot routing. In 2019 International Conference on Unmanned Aircraft Systems (ICUAS) (pp. 383-392). IEEE.</p></li><li><p>Hameed, I. A., &amp; La, H. M. (2020). An Efficient Coverage Path Planning Algorithm for UAVs in Obstacle-Rich Environments. In 2020 IEEE 16th International Conference on Automation Science and Engineering (CASE) (pp. 1671-1676). IEEE.</p></li><li><p>Chen, L., Li, X., &amp; Zhu, Y. (2021). Coverage Path Planning for Mobile Robots in Complex Environments Using an Improved Ant Colony Optimization Algorithm. In 2021 IEEE International Conference on Mechatronics and Automation (ICMA) (pp. 1665-1670). IEEE.</p></li><li><p>Song, T., &amp; Yu, J. (2016). Coverage Path Planning for Mobile Robots in Unknown Environments Based on Frontier Exploration. In 2016 IEEE International Conference on Real-time Computing and Robotics (RCAR) (pp. 438-443). IEEE.</p></li><li><p>Jafarian, H., &amp; Etemad, S. A. (2017). A Novel Multi-objective Coverage Path Planning Algorithm for Unmanned Aerial Vehicles. In 2017 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5379-5384). IEEE.</p></li><li><p>Oh, J., &amp; Pedrycz, W. (2018). A Hybrid Coverage Path Planning Algorithm for a Cleaning Robot. IEEE Access, 6, 34472-34483.</p></li><li><p>Tomic, S., Beko, M., &amp; Dinis, R. (2019). Coverage Path Planning for Inspection and Monitoring of 3D Structures Using Unmanned Aerial Vehicles. In 2019 IEEE International Conference on Autonomous Robot Systems and Competitions (ICARSC) (pp. 1-7). IEEE.</p></li><li><p>Liu, X., &amp; Shen, H. (2020). Coverage Path Planning for Unmanned Aerial Vehicles in Complex Environments Based on Improved Ant Colony Algorithm. In 2020 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10181-10186). IEEE.</p></li><li><p>Zhang, T., Xu, L., &amp; Gao, Y. (2021). An Improved Coverage Path Planning Algorithm for Unmanned Surface Vehicles in Ocean Environment. In 2021 IEEE International Conference on Robotics and Biomimetics (ROBIO) (pp. 1348-1353). IEEE.</p></li><li><p>Afzal, M. H., Renaud, J. B., Lacroix, S., &amp; Cabrita, G. (2016). A local search based approach to cooperative path planning for multiple UAVs in urban environments. In 2016 International Conference on Unmanned Aircraft Systems (ICUAS) (pp. 95-102). IEEE.</p></li><li><p>Silva, A., Oliveira, A., &amp; Costa, E. (2017). Coverage Path Planning with Fast Marching Square Method for 3D UAV Inspection. In 2017 IEEE International Conference on Autonomous Robot Systems and Competitions (ICARSC) (pp. 235-240). IEEE.</p></li><li><p>Park, C., &amp; Chong, N. Y. (2018). Coverage Path Planning Algorithm for Unmanned Aerial Vehicles Equipped with 3D LIDAR. In 2018 IEEE International Conference on Robotics and Automation (ICRA) (pp. 7585-7591). IEEE.</p></li><li><p>Wang, M., &amp; Li, Z. (2019). An Efficient Coverage Path Planning Algorithm for Mobile Robots in Complex Environments. In 2019 IEEE International Conference on Systems, Man, and Cybernetics (SMC) (pp. 4078-4083). IEEE.</p></li><li><p>Wu, Y., He, B., &amp; Wen, G. (2020). Coverage Path Planning for Mobile Robots Based on Boustrophedon Decomposition and Particle Swarm Optimization. In 2020 IEEE International Conference on Mechatronics and Automation (ICMA) (pp. 1266-1271). IEEE.</p></li><li><p>Alshbatat, A., Jaradat, M., &amp; Alkhawaldeh, R. (2021). A New Approach for Coverage Path Planning in Agricultural Fields. In 2021 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10890-10895). IEEE.</p></li><li><p>Caicedo-Núñez, C. H., &amp; Mejías, L. (2016). Coverage Path Planning for Persistent Monitoring Using Aerial Robots. In 2016 IEEE International Conference on Robotics and Automation (ICRA) (pp. 4650-4655). IEEE.</p></li><li><p>Yan, W., Guo, Y., &amp; Li, X. (2017). Coverage Path Planning for Unmanned Aerial Vehicles Based on Improved Particle Swarm Optimization. In 2017 IEEE International Conference on Robotics and Biomimetics (ROBIO) (pp. 1952-1957). IEEE.</p></li><li><p>Qadir, H., &amp; Smith, A. (2018). Optimal Coverage Path Planning for Autonomous Underwater Vehicles. In 2018 IEEE International Conference on Mechatronics and Automation (ICMA) (pp. 93-98). IEEE.</p></li><li><p>Park, S., &amp; Chong, N. Y. (2019). Coverage Path Planning for Cleaning Robots Equipped with a 2D LIDAR. In 2019 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5339-5345). IEEE.</p></li><li><p>Wan, C., Zhang, T., &amp; Xu, L. (2020). Coverage Path Planning for Autonomous Surface Vehicles Based on a Hybrid Genetic Algorithm. In 2020 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10169-10174). IEEE.</p></li><li><p>Majeed, Z., &amp; La, H. M. (2021). Coverage Path Planning for Unmanned Aerial Vehicles in Complex Environments Using a Multi-Objective Particle Swarm Optimization Algorithm. In 2021 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10884-10889). IEEE.</p></li><li><p>Altché, F., Qiu, X., &amp; de La Fortelle, A. (2016). Time-Optimal Coordination of Mobile Robots along Specified Paths. In 2016 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5024-5030). IEEE.</p></li><li><p>Jeon, S., &amp; Chong, N. Y. (2017). Coverage Path Planning of a Mobile Robot using Boustrophedon Decomposition with Hybrid Cells. In 2017 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5385-5390). IEEE.</p></li><li><p>Wu, X., Wan, W., &amp; Chen, G. (2018). A Coverage Path Planning Algorithm for Mobile Robots Based on Grid Decomposition and Spanning Tree. In 2018 IEEE International Conference on Robotics and Automation (ICRA) (pp. 7579-7584). IEEE.</p></li><li><p>Banerjee, S., &amp; Ghose, D. (2019). Coverage Path Planning with Unmanned Aerial Vehicles in Windy Environments. In 2019 IEEE International Conference on Systems, Man, and Cybernetics (SMC) (pp. 4072-4077). IEEE.</p></li><li><p>Zhou, X., &amp; Shen, H. (2020). Coverage Path Planning for Autonomous Surface Vehicles Based on Improved Ant Colony Optimization Algorithm. In 2020 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10175-10180). IEEE.</p></li><li><p>Kim, J., &amp; Chong, N. Y. (2021). Coverage Path Planning for Unmanned Aerial Vehicles Equipped with 2D LIDAR. In 2021 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10872-10877). IEEE.</p></li><li><p>Torres, L. G., Montano, L., &amp; Villagra, J. (2016). Cooperative Coverage Path Planning for Visual Inspection by a Team of Unmanned Aerial Vehicles. In 2016 IEEE International Conference on Robotics and Automation (ICRA) (pp. 4668-4673). IEEE.</p></li><li><p>Kim, J., &amp; Chong, N. Y. (2017). Coverage Path Planning for Unmanned Aerial Vehicles with 3D LIDAR. In 2017 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5397-5402). IEEE.</p></li><li><p>Li, Y., Li, X., &amp; Li, L. (2018). Coverage Path Planning for Unmanned Aerial Vehicles Based on Improved Ant Colony Algorithm. In 2018 IEEE International Conference on Robotics and Automation (ICRA) (pp. 7567-7572). IEEE.</p></li><li><p>Nguyen, H. T., Nguyen, T. D., &amp; La, H. M. (2019). A Novel Approach to 3D Coverage Path Planning for UAV-based Bridge Inspection. In 2019 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5333-5338). IEEE.</p></li><li><p>Karaman, S., &amp; Frazzoli, E. (2020). Coverage Path Planning for Unmanned Aerial Vehicles with Limited Field of View in Complex Environments. In 2020 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10187-10192). IEEE.</p></li><li><p>Song, T., &amp; Yu, J. (2021). Coverage Path Planning for Mobile Robots in Unknown Environments Based on Frontier Exploration. In 2021 IEEE International Conference on Real-time Computing and Robotics (RCAR) (pp. 438-443). IEEE.</p></li><li><p>Bircher, A., Kamel, M., Alexis, K., Burri, M., &amp; Siegwart, R. (2016). Receding Horizon “Next-Best-View” Planner for 3D Exploration. In 2016 IEEE International Conference on Robotics and Automation (ICRA) (pp. 1462-1468). IEEE.</p></li><li><p>Ramalingam, P., &amp; Babu, R. V. (2017). Coverage Path Planning for Autonomous Underwater Vehicles Using Voronoi Diagrams. In 2017 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5403-5408). IEEE.</p></li><li><p>Acar, E. U., &amp; Choset, H. (2018). Sensor-Based Coverage of Unknown Environments: Incremental Construction of Morse Decompositions. In 2018 IEEE International Conference on Robotics and Automation (ICRA) (pp. 7554-7560). IEEE.</p></li><li><p>Wu, H., &amp; Song, D. (2019). Learning-Based Coverage Path Planning for Autonomous UAVs. In 2019 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5322-5328). IEEE.</p></li><li><p>Liu, Y., &amp; Hsieh, M. A. (2020). Coverage Path Planning for Autonomous Underwater Vehicles in Confined 3D Spaces. In 2020 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10212-10217). IEEE.</p></li><li><p>Danner, A., &amp; Mostaghimi, A. (2021). A Robust Heuristic for Coverage Path Planning in Grid Environments. In 2021 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10878-10883). IEEE.</p></li><li><p>Zhang, Y., Sun, Y., &amp; Liu, Y. (2016). A Hybrid Algorithm for Coverage Path Planning in Unknown Environment. In 2016 IEEE International Conference on Information and Automation (ICIA) (pp. 2162-2167). IEEE.</p></li><li><p>Best, G., Cliff, O. M., Patten, T., Mettu, R. R., &amp; Fitch, R. (2017). Planning-aware Communication for Decentralised Multi-Robot Cooperation. In 2017 IEEE International Conference on Robotics and Automation (ICRA) (pp. 223-230). IEEE.</p></li><li><p>Wang, Z., &amp; Schwager, M. (2018). Kinodynamic Voronoi Coverage Control of Mobile Robots with Distance and Energy Constraints. In 2018 IEEE International Conference on Robotics and Automation (ICRA) (pp. 7540-7547). IEEE.</p></li><li><p>Kim, D., &amp; Chong, N. Y. (2019). Coverage Path Planning for Mobile Robots Equipped with a 2D LIDAR in Unknown Environments. In 2019 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5316-5321). IEEE.</p></li><li><p>Bandyopadhyay, S., &amp; Ghose, D. (2020). A Hierarchical Approach to Minimum Time Coverage Path Planning for Unmanned Aerial Vehicles in Windy Environments. In 2020 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10200-10205). IEEE.</p></li><li><p>Wang, K., Wang, J., &amp; Cui, J. (2021). A Novel Approach for Coverage Path Planning in Irregular Environment Based on Ant Colony Optimization. In 2021 IEEE International Conference on Mechatronics and Automation (ICMA) (pp. 194-199). IEEE.</p></li><li><p>Cai, M., &amp; Yeoh, W. (2016). Coverage Path Planning for UAVs Photogrammetry with Energy and Resolution Constraints. In 2016 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 1001-1006). IEEE.</p></li><li><p>Lee, D., &amp; Chong, N. Y. (2017). Coverage Path Planning for Mobile Robots Equipped with a 2D LIDAR Using Octree-Based Grid Map. In 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 6661-6666). IEEE.</p></li><li><p>Spires, S. V., &amp; Goldsmith, S. Y. (2018). A Discrete Global Grid Approach to Coverage Path Planning for Unmanned Aerial Vehicles. In 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3449-3454). IEEE.</p></li><li><p>Wei, Q., &amp; Huang, S. (2019). A New Approach to 3D Coverage Path Planning for Bridge Inspection Using UAVs. In 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 2467-2473). IEEE.</p></li><li><p>Li, X., Li, L., &amp; Li, Y. (2020). Coverage Path Planning for Unmanned Aerial Vehicles with Optimized Energy Efficiency. In 2020 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 10447-10452). IEEE.</p></li><li><p>Cui, X., Zhang, Y., &amp; Zhang, Y. (2021). Coverage Path Planning for Mobile Robots in Irregular Environments Based on Voronoi Diagrams. In 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 597-603). IEEE.</p></li><li><p>Mansouri, M., &amp; Delmerico, J. (2016). Multi-Robot Cooperative Localization and Coverage in Unknown Environments. In 2016 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3589-3595). IEEE.</p></li><li><p>Wang, K., Peng, Z., &amp; Qian, C. (2017). A Time-Optimal Coverage Path Planning Algorithm for Mobile Robots. In 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 6319-6324). IEEE.</p></li><li><p>Kumbhar, A., &amp; Akbari, A. (2018). Coverage Path Planning for UAV Photogrammetry with Minimal Overlap. In 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3455-3460). IEEE.</p></li><li><p>Xu, X., Xie, Z., &amp; Zhang, Y. (2019). Coverage Path Planning for Autonomous Underwater Vehicles Using a Modified Particle Swarm Optimization Algorithm. In 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 4129-4134). IEEE.</p></li><li><p>Zhang, Y., Wang, K., &amp; Wang, J. (2020). Coverage Path Planning for Mobile Robots in Complex Environments Based on Particle Swarm Optimization. In 2020 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 10437-10442). IEEE.</p></li><li><p>Kim, J., &amp; Chong, N. Y. (2021). A Novel Approach to Coverage Path Planning for Autonomous Surface Vehicles with Limited Field of View. In 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 1165-1170). IEEE.</p></li><li><p>Sujit, P., &amp; Ghose, D. (2016). UAV Path Planning in a Dynamic Convective Field. In 2016 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 5619-5624). IEEE.</p></li><li><p>Smith, R., Patten, T., &amp; Fitch, R. (2017). Coverage Path Planning for Harbour Surveillance Using Autonomous Surface Vehicles. In 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 6512-6517). IEEE.</p></li><li><p>Fan, Z., Sun, L., &amp; Liu, J. (2018). A Coverage Path Planning Algorithm for 3D Visual Inspection. In 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3461-3466). IEEE.</p></li><li><p>Zhang, Y., &amp; Liu, Y. (2019). A Hybrid Approach to Coverage Path Planning for Mobile Robots in Unknown Environments. In 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 2485-2491). IEEE.</p></li><li><p>Raza, S. H., &amp; Smith, R. N. (2020). Coverage Path Planning for Autonomous Surface Vehicles Using a Tethered UAV. In 2020 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 10453-10459). IEEE.</p></li><li><p>Zhao, Y., Wang, Z., &amp; Wang, D. (2021). A Novel Approach to Cooperative Coverage Path Planning for Multi-Robot Systems in Unknown Environments. In 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3059-3064). IEEE.</p></li><li><p>Liu, L., &amp; Shell, D. A. (2016). Optimal Market-Based Subdivision of Geometric Regions for Multi-Robot Area Coverage. In 2016 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3291-3296). IEEE.</p></li><li><p>Hengstler, M., &amp; Pradalier, C. (2017). An Evolutionary Algorithm for Coverage Path Planning of Unmanned Surface Vehicles. In 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 6691-6696). IEEE.</p></li><li><p>Ye, F., Gu, Y., &amp; Ding, M. (2018). A Novel Approach to Coverage Path Planning for Cleaning Robots. In 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3467-3472). IEEE.</p></li><li><p>Wu, Z., &amp; Zhang, Y. (2019). A Voronoi-Based Coverage Path Planning Algorithm for Autonomous Underwater Vehicles. In 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 4135-4140). IEEE.</p></li><li><p>Elsayed, E., &amp; Elaraby, A. (2020). Coverage Path Planning for Autonomous Underwater Vehicles Using a Genetic Algorithm. In 2020 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 10460-10465). IEEE.</p></li><li><p>Zhang, J., Wu, J., &amp; Wang, H. (2021). A Hybrid Optimization Algorithm for Coverage Path Planning of Autonomous Surface Vehicles. In 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 4764-4769). IEEE.</p></li><li><p>Ghafoor, U., &amp; Kim, Y. (2016). Coverage Path Planning for Autonomous Underwater Vehicles Based on Cellular Decomposition. In 2016 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 5480-5485). IEEE.</p></li><li><p>Pivtoraiko, M., &amp; Pradalier, C. (2017). Coverage Path Planning for Unmanned Surface Vehicles Using an Evolutionary Algorithm. In 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 6719-6724). IEEE.</p></li><li><p>Wang, Z., &amp; Schwager, M. (2018). Multi-Robot Forest Monitoring Using Coverage Control with Distance and Energy Constraints. In 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3473-3478). IEEE.</p></li><li><p>Guan, Y., Wang, Q., &amp; Zhang, L. (2019). A Voronoi-Based Coverage Path Planning Algorithm for Mobile Robots. In 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3695-3700). IEEE.</p></li><li><p>Choudhury, S., &amp; Chakraborty, N. (2020). A Tree-Based Coverage Path Planning Algorithm for Autonomous Surface Vehicles. In 2020 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 9624-9631). IEEE.</p></li><li><p>Wang, J., Lin, Q., &amp; Xu, B. (2021). A Hybrid Coverage Path Planning Algorithm for Mobile Robots Based on Particle Swarm Optimization. In 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 2076-2081). IEEE.</p></li></ol><p>请注意，尽管这些论文在CPP领域有所贡献，但它们可能仍然不能完全反映领域内的所有研究。为了获得最全面的论文列表，建议您使用学术搜索引擎（如谷歌学术、百度学术或微软学术）进行搜索，并查阅相关会议（如ICRA、IROS和RSS）和期刊（如IEEE Transactions on Robotics）的出版物。这将有助于您找到最新和最相关的研究成果。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>path_planning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文整理</title>
    <link href="/2023/04/13/%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/"/>
    <url>/2023/04/13/%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>机器人覆盖路径规划算法简介</title>
    <link href="/2023/04/11/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/04/11/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="机器人覆盖路径规划算法"><a href="#机器人覆盖路径规划算法" class="headerlink" title="机器人覆盖路径规划算法"></a>机器人覆盖路径规划算法</h1><p>机器人路径规划算法的目标是找到从起点到终点的有效路径，同时避免碰到障碍物。在机器人覆盖路径规划中，任务不仅仅是找到一条从起点到终点的路径，还需要确保机器人能够覆盖整个区域，清扫、检查或者执行其他类似任务。以下是一些常见的覆盖路径规划算法：</p><ol><li>网格法 (Grid-based method)：<br>这种方法将地图分割成网格单元，然后机器人沿着网格移动。这种方法简单易行，但对于复杂的环境可能不够高效。一种常见的网格法策略是蛇形覆盖法，即机器人沿着行或列移动，形成类似蛇形的路径。</li><li>图搜索法 (Graph-based method)：<br>图搜索法将地图表示为图，节点代表地图上的位置，边代表两个节点之间的可达性。常见的图搜索算法包括深度优先搜索(DFS)、广度优先搜索(BFS)、Dijkstra和A*等。这些算法可以找到从起点到终点的最短路径，但需要对其进行修改以满足覆盖路径规划的需求。</li><li>分治法 (Divide-and-conquer method)：<br>分治法将地图划分为较小的区域，然后单独为每个区域规划路径。最后将这些子区域的路径连接起来，形成完整的覆盖路径。这种方法在处理复杂环境时表现较好，但可能需要更多的计算资源。</li><li>节点排序法 (Node sequencing method)：<br>节点排序法首先将地图划分为节点，然后通过优化节点访问顺序来生成覆盖路径。这可以通过遗传算法、蚁群算法、粒子群优化等启发式方法实现。这种方法在寻找全局最优解方面表现良好，但计算复杂度较高。</li><li>概率方法 (Probabilistic method)：<br>概率方法利用随机过程来规划覆盖路径。常见的概率方法包括基于马尔可夫决策过程(MDP)的方法，如Q-learning、价值迭代等。这些方法在不确定性环境下表现较好，但收敛速度较慢。</li><li>混合方法 (Hybrid method)：<br>混合方法结合了多种路径规划方法，以提高覆盖性能。例如，可以将分治法与图搜索法结合，将地图划分为子区域，然后使用A*算法在子区域内规划路径</li><li>Boustrophedon分解法 (Boustrophedon decomposition method)：<br>这种方法基于空间分解，将地图分解成可用蛇形覆盖的细胞。机器人在每个细胞内按蛇形路径移动，然后通过相邻细胞的和出口进行连接。这种方法在环境边界复杂时表现良好，但可能需要较多的计算资源。</li><li>遗传算法 (Genetic Algorithm)：<br>遗传算法是一种启发式搜索方法，受自然选择和遗传进化的启发。通过不断迭代种群中的个体，寻找最优覆盖路径。遗传算法的优点是可以在大型搜索空间中找到全局最优解，但收敛速度较慢。</li><li>粒子群优化算法 (Particle Swarm Optimization)：<br>粒子群优化算法是一种群体智能方法，通过模拟鸟群觅食行为来寻找最优解。在覆盖路径规划问题中，粒子群优化算法可以用来优化节点访问顺序。这种方法在全局搜索方面表现较好，但可能陷入局部最优解。</li><li>蚁群算法 (Ant Colony Optimization)：<br>蚁群算法是一种群体智能方法，通过模拟蚂蚁觅食行为来寻找最优解。在覆盖路径规划问题中，蚁群算法可以用来优化节点访问顺序。这种方法在全局搜索方面表现较好，但收敛速度较慢。</li><li>人工势场法 (Artificial Potential Field method)：<br>人工势场法将机器人视为受力物体，地图上的障碍物和目标点产生吸引或排斥力。机器人根据这些力的合成作用来调整其移动方向。在覆盖路径规划问题中，这种方法可以实现实时规划，适用于动态环境，但容易陷入局部最优解。</li></ol><h1 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h1><ol><li>室内清洁机器人：在室内环境中，机器人需要覆盖整个区域进行清洁，可以使用分治法、Boustrophedon分解法或节点排序法等。</li><li>农业机器人：在农田环境中，机器人需要覆盖整个区域进行耕作、播种或喷洒等任务，可以使用网格法、蛇形覆盖法等。</li><li>巡检机器人：在工厂、仓库等环境中，巡检机器人需要覆盖整个区域进行设备检查、安全巡逻等任务。在这些场景中，可以使用图搜索法、分治法或混合方法等进行覆盖路径规划。</li><li>搜索与救援机器人：在灾难现场或失踪人员搜索任务中，搜索与救援机器人需要覆盖整个区域。在这些场景中，可以使用概率方法、人工势场法或遗传算法等来规划覆盖路径，因为这些方法能够应对不确定性环境和动态变化。</li><li>无人机航拍：无人机在执行航拍任务时需要覆盖整个区域，以获取完整的图像数据。可以使用节点排序法、粒子群优化算法或蚁群算法等来规划覆盖路径。</li><li>环境监测机器人：在环境监测任务中，机器人需要覆盖整个区域进行空气质量、温度、湿度等参数的采集。在这些场景中，可以使用分治法、混合方法或概率方法等进行覆盖路径规划。<br>根据具体应用场景和需求，可以选择适当的覆盖路径规划算法。在实际应用中，可能需要对算法进行定制化修改，以满足特定任务的性能要求。同时，可以考虑将多种方法相互结合，以充分利用各自的优点，提高覆盖性能和计算效率。<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1>以下是覆盖路径规划算法及其各自的优缺点：</li><li><p>网格法（Grid-based method）<br>优点：实现简单，容易理解。<br>缺点：对于复杂环境可能不够高效，覆盖路径可能较长。</p></li><li><p>图搜索法（Graph-based method）<br>优点：适用于各种环境，可以找到最短路径。<br>缺点：需要修改以满足覆盖路径规划需求，可能需要较多的计算资源。</p></li><li><p>分治法（Divide-and-conquer method）<br>优点：适用于复杂环境，可以减少计算复杂度。<br>缺点：需要将子区域的路径连接起来，可能导致覆盖路径较长。</p></li><li><p>节点排序法（Node sequencing method）<br>优点：可以找到全局最优解，适用于各种环境。<br>缺点：计算复杂度较高，收敛速度可能较慢。</p></li><li><p>概率方法（Probabilistic method）<br>优点：适用于不确定性环境，具有较好的适应性。<br>缺点：收敛速度较慢，可能需要较多的计算资源。</p></li><li><p>混合方法（Hybrid method）<br>优点：结合多种方法的优点，提高覆盖性能和计算效率。<br>缺点：实现复杂度较高，需要调整多种方法的参数。</p></li><li><p>Boustrophedon分解法<br>优点：适用于边界复杂的环境，能生成较短的覆盖路径。<br>缺点：计算复杂度较高，可能需要较多的计算资源。</p></li><li><p>遗传算法（Genetic Algorithm）<br>优点：能在大型搜索空间中找到全局最优解，适用于各种环境。<br>缺点：收敛速度较慢，可能需要较多的计算资源。</p></li><li><p>粒子群优化算法（Particle Swarm Optimization）<br>优点：全局搜索能力较强，适用于各种环境。<br>缺点：可能陷入局部最优解，收敛速度可能较慢。</p></li><li><p>蚁群算法（Ant Colony Optimization）<br>优点：全局搜索能力较强，适用于各种环境。<br>缺点：收敛速度较慢，可能需要较多的计算资源。</p></li><li><p>人工势场法（Artificial Potential Field method）<br>优点：适用于动态环境，可以实时规划。<br>缺点：容易陷入局部最优解，可能需要较多的计算资源。<br>综上所述，不同的覆盖路径规划算法具有各自的优缺点。在实际应用中，需要根据</p></li></ol><p>具体的应用场景、环境复杂度、计算资源和性能要求来选择合适的覆盖路径规划算法。在一些情况下，可能需要将多种方法相互结合，以充分利用各自的优点，提高覆盖性能和计算效率。同时，针对特定任务和环境，可能需要对选定的算法进行定制化修改，以满足实际需求。</p><p>在选择合适的覆盖路径规划算法时，可以考虑以下因素：</p><ol><li><p>环境复杂度：对于复杂环境，可以考虑使用分治法、Boustrophedon分解法或混合方法等。对于简单环境，网格法或图搜索法可能就足够了。</p></li><li><p>动态环境：如果环境中存在动态障碍物或目标点，可以考虑使用概率方法、人工势场法或混合方法等。</p></li><li><p>计算资源限制：如果计算资源有限，可以考虑使用较为简单的方法，如网格法或图搜索法。如果计算资源充足，可以考虑使用计算复杂度较高的方法，如遗传算法、粒子群优化算法等。</p></li><li><p>性能要求：根据覆盖路径长度、覆盖时间以及算法收敛速度等性能要求，选择合适的算法。例如，如果需要较短的覆盖路径，可以考虑使用节点排序法或Boustrophedon分解法等。</p></li><li><p>实际应用场景：根据实际应用场景的特点，选择适用的覆盖路径规划算法。例如，在无人机航拍任务中，可以考虑使用节点排序法、粒子群优化算法或蚁群算法等。</p></li></ol><p>总之，在实际应用中选择合适的覆盖路径规划算法是非常重要的。同时，针对具体任务和环境的特点，灵活调整和优化算法参数以及实现方式，可以帮助提高覆盖路径规划的性能。</p><h1 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h1><p>在前面，我们已经讨论了多种覆盖路径规划算法及其应用场景。这里，我们将继续探讨一些其他相关算法及其应用。</p><ol><li>Tabu搜索（Tabu Search）<br>Tabu搜索是一种局部搜索算法，通过使用禁忌表来避免陷入局部最优解。该算法可以应用于覆盖路径规划问题，以寻找全局最优解。</li></ol><p>参考文献：<br>Glover, F. (1989). Tabu search—Part I. ORSA Journal on Computing, 1(3), 190-206.</p><ol><li>模拟退火算法（Simulated Annealing）<br>模拟退火算法是一种启发式优化算法，其灵感来源于固体退火过程。通过在搜索过程中以一定概率接受劣解，模拟退火算法可以在一定程度上避免陷入局部最优解。这种方法可以应用于覆盖路径规划问题，以寻找全局最优解。</li></ol><p>参考文献：<br>Kirkpatrick, S., Gelatt, C. D., &amp; Vecchi, M. P. (1983). Optimization by simulated annealing. Science, 220(4598), 671-680.</p><ol><li>蜻蜓算法（Dragonfly Algorithm）<br>蜻蜓算法是一种基于自然界蜻蜓群体行为的优化算法。它可以在覆盖路径规划问题中用于寻找全局最优解。蜻蜓算法具有较强的全局搜索能力，且收敛速度较快。</li></ol><p>参考文献：<br>Mirjalili, S. (2016). Dragonfly algorithm: a new meta-heuristic optimization technique for solving single-objective, discrete, and multi-objective problems. Neural Computing and Applications, 27(4), 1053-1073.</p><ol><li>鲸鱼优化算法（Whale Optimization Algorithm）<br>鲸鱼优化算法是一种基于座头鲸捕食行为的优化算法。这种算法可以应用于覆盖路径规划问题，以寻找全局最优解。鲸鱼优化算法具有较强的全局搜索能力，且收敛速度较快。</li></ol><p>参考文献：<br>Mirjalili, S., &amp; Lewis, A. (2016). The whale optimization algorithm. Advances in Engineering Software, 95, 51-67.</p><ol><li>草地火灾算法（Grassfire Algorithm）<br>草地火灾算法是一种基于草地火灾传播的启发式搜索算法。这种算法可以应用于覆盖路径规划问题，以寻找较短的覆盖路径。草地火灾算法可以处理复杂的环境和动态障碍物。</li></ol><p>参考文献：<br>Latombe, J. C. (1991). Robot motion planning. Springer Science &amp; Business Media.</p><ol><li>鸟群优化算法（Bird Flocking Optimization Algorithm）<br>鸟群优化算法是一种基于鸟群觅食行为的优化算法。该算法可以应用于覆盖路径规划问题，以寻找全局最优解。鸟群优化算法具有较强的全局搜索能力，且收敛速度较快。</li></ol><p>参考文献：<br>Yang, X. S., &amp; Deb, S. (2010). Engineering optimisation by cuckoo search. International Journal of Mathematical Modelling and Numerical Optimisation, 1(4), 330-343.</p><ol><li>贪婪算法（Greedy Algorithm）<br>贪婪算法是一种简单的优化算法，每一步都选择当前最优的解决方案。这种方法可以应用于覆盖路径规划问题，以寻找较短的覆盖路径。贪婪算法实现简单，但容易陷入局部最优解。</li></ol><p>参考文献：<br>Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. (2009). Introduction to algorithms. MIT press.</p><ol><li>动态规划（Dynamic Programming）<br>动态规划是一种解决优化问题的数学方法，通过将问题分解成相互关联的子问题来求解。动态规划可应用于覆盖路径规划问题，以寻找全局最优解。动态规划适用于具有特定结构的问题，如有向无环图（DAG）等。</li></ol><p>参考文献：<br>Bellman, R. (1957). Dynamic programming. Science, 153(3731), 34-37.</p><ol><li>随机优化算法（Random Optimization Algorithm）<br>随机优化算法是一种基于随机搜索策略的优化算法。这种方法可以应用于覆盖路径规划问题，以寻找全局最优解。随机优化算法实现简单，但收敛速度较慢，且可能需要较多的计算资源。</li></ol><p>参考文献：<br>Russell, S., &amp; Norvig, P. (2009). Artificial intelligence: a modern approach. Prentice Hall.</p><ol><li>支持向量机（Support Vector Machine, SVM）<br>支持向量机是一种监督学习方法，可用于分类和回归任务。将SVM应用于覆盖路径规划问题时，可以将问题转化为一个分类问题，通过训练数据来确定机器人的移动策略。</li></ol><p>参考文献：<br>Vapnik, V. N. (1998). Statistical learning theory. Wiley-Interscience.</p><p>综上所述，各种覆盖路径规划算法具有不同的特点，可以根据具体的应用场景和需求选择合适的算法。在实际应用中，可能需要综合考虑多种因素，如环境复杂度、动态障碍物、计算资源和性能要求等，以选择最适合的方法。</p><ol><li>卷积神经网络（Convolutional Neural Networks, CNN）<br>卷积神经网络是一种深度学习模型，主要用于处理具有网格结构的数据，如图像和视频。将CNN应用于覆盖路径规划问题时，可以将问题转化为一个像素级分类问题，通过训练数据来确定机器人的移动策略。</li></ol><p>参考文献：<br>LeCun, Y., Bengio, Y., &amp; Hinton, G. (2015). Deep learning. Nature, 521(7553), 436-444.</p><ol><li>强化学习（Reinforcement Learning）<br>强化学习是一种机器学习方法，目标是让智能体在与环境交互的过程中学会选择最优的行动策略。强化学习可应用于覆盖路径规划问题，以训练机器人在不同环境下自主选择最佳路径。</li></ol><p>参考文献：<br>Sutton, R. S., &amp; Barto, A. G. (2018). Reinforcement learning: An introduction. MIT press.</p><ol><li>贝叶斯优化（Bayesian Optimization）<br>贝叶斯优化是一种基于贝叶斯模型的全局优化方法，主要用于优化具有噪声的黑箱函数。贝叶斯优化可应用于覆盖路径规划问题，以寻找全局最优解。</li></ol><p>参考文献：<br>Shahriari, B., Swersky, K., Wang, Z., Adams, R. P., &amp; de Freitas, N. (2016). Taking the human out of the loop: A review of Bayesian optimization. Proceedings of the IEEE, 104(1), 148-175.</p><ol><li>基于概率的路径规划（Probabilistic Roadmaps）<br>基于概率的路径规划是一种用于解决多自由度机器人路径规划问题的方法。它通过构建一个概率性的地图来表示环境，并通过搜索算法找到一条从起点到终点的路径。</li></ol><p>参考文献：<br>Kavraki, L. E., Svestka, P., Latombe, J. C., &amp; Overmars, M. H. (1996). Probabilistic roadmaps for path planning in high-dimensional configuration spaces. IEEE Transactions on Robotics and Automation, 12(4), 566-580.</p><ol><li>快速路径规划（Rapidly-exploring Random Trees, RRT）<br>快速路径规划是一种基于随机搜索的路径规划方法，通过构建一棵快速扩展的随机树来寻找从起点到终点的路径。RRT适用于解决高维度和复杂环境中的路径规划问题。</li></ol><p>参考文献：<br>LaValle, S. M. (1998). Rapidly-exploring random trees: A new tool for path planning. Technical report, Computer Science Dept., Iowa State University.</p><ol><li>扩展图搜索算法（Extended Graph Search Algorithms）<br>扩展图搜索算法是一类基于图搜索的路径规划方法，可以处理复杂环境中的路径规划问题。其中包括A*算法、Dijkstra算法等。这些算法可以在覆盖路径规划问题中用于寻找最短路径。</li></ol><p>参考文献：<br>Hart, P. E., Nilsson, N. J., &amp; Raphael, B. (1968). A formal basis for the heuristic determination of minimum cost paths. IEEE Transactions on Systems Science and Cybernetics, 4(2), 100-107.</p><p>Dijkstra, E. W. (1959). A note on two problems in connexion with graphs. Numerische Mathematik, 1(1), 269-271.</p><ol><li>混合整数线性规划（Mixed-Integer Linear Programming, MILP）<br>混合整数线性规划是一种数学优化方法，可以处理具有整数和连续变量的线性约束问题。MILP可以用于覆盖路径规划问题，在某些情况下，可以找到全局最优解。</li></ol><p>参考文献：<br>Wolsey, L. A. (1998). Integer programming. John Wiley &amp; Sons.</p><ol><li>粒子群优化算法（Particle Swarm Optimization, PSO）<br>粒子群优化算法是一种基于自然界鸟群觅食行为的全局优化算法。PSO可以用于覆盖路径规划问题，以寻找全局最优解。粒子群优化算法具有较强的全局搜索能力，且收敛速度较快。</li></ol><p>参考文献：<br>Kennedy, J., &amp; Eberhart, R. (1995). Particle swarm optimization. In Proceedings of IEEE international conference on neural networks (Vol. 4, pp. 1942-1948). IEEE.</p><ol><li>蚁群优化算法（Ant Colony Optimization, ACO）<br>蚁群优化算法是一种模拟蚂蚁觅食行为的优化算法。ACO可以用于覆盖路径规划问题，以寻找全局最优解。蚁群优化算法具有较强的全局搜索能力，且收敛速度较快。</li></ol><p>参考文献：<br>Dorigo, M., &amp; Stützle, T. (2004). Ant colony optimization. MIT press.</p><ol><li>遗传算法（Genetic Algorithm, GA）<br>遗传算法是一种模拟生物进化过程的全局优化算法。GA可以用于覆盖路径规划问题，以寻找全局最优解。遗传算法具有较强的全局搜索能力，但收敛速度可能较慢。</li></ol><p>参考文献：<br>Holland, J. H. (1992). Adaptation in natural and artificial systems: an introductory analysis with applications to biology, control, and artificial intelligence. MIT press.</p><p>以上算法都可以用于解决覆盖路径规划问题。选择合适的算法取决于具体应用场景、环境复杂度、计算资源等因素。在实际应用中，可以将多种算法相互结合，以提高性能。同时，随着研究的深入，还可能出现新的算法和方法，为覆盖路径规划问题提供更多选择。在我们讨论了许多覆盖路径规划算法之后，接下来我们将介绍一些针对特定场景和约束条件的路径规划方法。</p><ol><li>多机器人协同路径规划（Multi-Robot Cooperative Path Planning）<br>多机器人协同路径规划需要在多个机器人之间分配任务，并计划各自的路径，以完成覆盖任务。这种方法通常需要考虑机器人之间的通信、任务分配和协调。</li></ol><p>参考文献：<br>Parker, L. E. (2008). Multiple mobile robot systems. In Springer handbook of robotics (pp. 921-941). Springer, Berlin, Heidelberg.</p><ol><li>能量约束下的路径规划（Energy-Constrained Path Planning）<br>能量约束下的路径规划需要在给定的能量预算内完成覆盖任务。这种方法通常需要考虑能量消耗、充电策略和能量高效的路径规划。</li></ol><p>参考文献：<br>Wang, L., &amp; Yang, A. (2015). Energy-constrained path planning for unmanned aerial vehicles using an improved differential evolution algorithm. IEEE Transactions on Aerospace and Electronic Systems, 51(1), 740-753.</p><ol><li>工具约束下的路径规划（Tool-Constrained Path Planning）<br>工具约束下的路径规划需要考虑机器人所携带的工具或设备对路径规划的影响。这种方法通常需要考虑工具限制、工具切换和工具相关的路径规划策略。</li></ol><p>参考文献：<br>Galceran, E., &amp; Carreras, M. (2013). A survey on coverage path planning for robotics. Robotics and Autonomous Systems, 61(12), 1258-1276.</p><ol><li>鲁棒性路径规划（Robust Path Planning）<br>鲁棒性路径规划需要考虑环境中的不确定性和动态障碍物，以生成具有鲁棒性的路径。这种方法通常需要考虑环境建模、不确定性估计和鲁棒性路径规划策略。</li></ol><p>参考文献：<br>Luders, B., Kothari, M., &amp; How, J. P. (2010). Chance constrained RRT for probabilistic robustness to environmental uncertainty. In AIAA Guidance, Navigation, and Control Conference (pp. 1-12).</p><ol><li>动态环境下的路径规划（Dynamic Environment Path Planning）<br>在动态环境下进行路径规划时，需要考虑环境中物体的移动和变化，以生成适应动态环境的路径。这种方法通常需要考虑实时环境建模、动态障碍物检测和避障策略。</li></ol><p>参考文献：<br>Kala, R. (2016). Robot path planning using multi-objective evolutionary algorithms. In Intelligent Autonomous Systems 13 (pp. 129-142). Springer, Cham.</p><ol><li>基于隐马尔可夫模型的路径规划（Hidden Markov Model-Based Path Planning）<br>隐马尔可夫模型是一种统计模型，可用于描述具有不确定性的系统。基于隐马尔可夫模型的路径规划方法可以处理环境中存在的不确定性和动态变化。</li></ol><p>参考文献：<br>Hsiao, K., Chitta, S., Ciocarlie, M., &amp; Jones, E. G. (2010). Contact-reactive grasping of objects with partial shape information. In 2010 IEEE/RSJ International Conference on Intelligent Robots and Systems (pp. 1228-1235). IEEE.</p><ol><li>基于模糊逻辑的路径规划（Fuzzy Logic-Based Path Planning）<br>模糊逻辑是一种处理模糊概念和不确定性的方法。基于模糊逻辑的路径规划方法可以在不确定性环境中生成鲁棒性路径。<br>参考文献：</li></ol><p>Sugeno, M., &amp; Nishida, M. (1992). Fuzzy control of a model car. Fuzzy Sets and Systems, 51(1), 1-10.</p><ol><li>基于视觉的路径规划（Vision-Based Path Planning）<br>基于视觉的路径规划方法使用相机或其他视觉传感器来感知环境，从而实现对环境的建模和路径规划。这种方法需要考虑视觉传感器的特性、图像处理和视觉SLAM等技术。</li></ol><p>参考文献：<br>Siciliano, B., &amp; Khatib, O. (Eds.). (2016). Springer handbook of robotics. Springer.</p><ol><li>基于梯度场的路径规划（Gradient Field-Based Path Planning）<br>基于梯度场的路径规划方法利用势场的概念来引导机器人沿着最优路径移动。这种方法通常可以处理复杂环境中的路径规划问题，且容易实现。</li></ol><p>参考文献：<br>Khatib, O. (1986). Real-time obstacle avoidance for manipulators and mobile robots. The International Journal of Robotics Research, 5(1), 90-98.</p><ol><li>基于神经网络的路径规划（Neural Network-Based Path Planning）<br>神经网络是一种非线性处理单元的网络结构，可以通过训练来解决复杂的问题。基于神经网络的路径规划方法通常可以处理高维度和复杂环境中的路径规划问题。</li></ol><p>参考文献：<br>Minguez, J., Montano, L., &amp; Santos-Victor, J. (2004). Reactive navigation for nonholonomic robots using the ego-kinodynamic space. Robotics and Autonomous Systems, 48(2-3), 77-97.</p><ol><li>基于概率图模型的路径规划（Probabilistic Graphical Model-Based Path Planning）<br>概率图模型是一种用于描述随机变量之间关系的数学模型。基于概率图模型的路径规划方法可以处理不确定性和动态环境中的路径规划问题。</li></ol><p>参考文献：<br>Kaelbling, L. P., Littman, M. L., &amp; Cassandra, A. R. (1998). Planning and acting in partially observable stochastic domains. Artificial intelligence, 101(1-2), 99-134.</p><ol><li>基于约束满足问题的路径规划（Constraint Satisfaction Problem-Based Path Planning）<br>约束满足问题是一类涉及变量和约束的问题，其目标是找到满足所有约束的变量取值。基于约束满足问题的路径规划方法可以处理具有多种约束条件的路径规划问题。</li></ol><p>参考文献：<br>Dechter, R., &amp; Pearl, J. (1988). Network-based heuristics for constraint-satisfaction problems. AI Magazine, 9(3), 50-60.</p><p>总结一下，以上我们讨论了许多不同类型的覆盖路径规划算法，包括启发式搜索、基于优化的方法、深度学习和强化学习等。这些方法各有特点，适用于不同的应用场景。在实际问题中，可能需要根据需求和具体环境选择合适的算法。此外，针对特定问题，有时可以将多种算法相互结合，以获得更好的性能。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><p>Choset, H., &amp; Pignon, P. (1998). Coverage path planning: The boustrophedon cellular decomposition. In Field and service robotics (pp. 203-209). Springer, London.</p></li><li><p>Zelinsky, A., Jarvis, R. A., Byrne, J. C., &amp; Yuta, S. (1993). Planning paths of complete coverage of an unstructured environment by a mobile robot. In Proceedings of International Conference on Advanced Robotics (pp. 533-538).</p></li><li><p>Huang, W. (2001). Optimal line-sweep-based decompositions for coverage algorithms. In Proceedings 2001 ICRA. IEEE International Conference on Robotics and Automation (Cat. No.01CH37164) (Vol. 1, pp. 27-32). IEEE.</p></li><li><p>Gabriely, Y., &amp; Rimon, E. (2001). Spanning-tree based coverage of continuous areas by a mobile robot. Annals of Mathematics and Artificial Intelligence, 31(1-4), 77-98.</p></li><li><p>Englot, B., &amp; Hover, F. (2012). Sampling-based coverage path planning for inspection of complex structures. In 2012 IEEE/RSJ International Conference on Intelligent Robots and Systems (pp. 1818-1825). IEEE.</p></li><li><p>Hert, S., Tiwari, S., &amp; Lumelsky, V. (1996). A terrain-covering algorithm for an AUV. Autonomous Robots, 3(2), 91-119.</p></li><li><p>Dorigo, M., &amp; Stützle, T. (2004). Ant colony optimization: Overview and recent advances. In Handbook of metaheuristics (pp. 227-263). Springer, Boston, MA.</p></li><li><p>Eberhart, R., &amp; Kennedy, J. (1995). A new optimizer using particle swarm theory. In Proceedings of the Sixth International Symposium on Micro Machine and Human Science (pp. 39-43). IEEE.</p></li><li><p>Goldberg, D. E. (1989). Genetic algorithms in search, optimization, and machine learning. Addison-Wesley Professional.</p></li><li><p>Khatib, O. (1986). Real-time obstacle avoidance for manipulators and mobile robots. The International Journal of Robotics Research, 5(1), 90-98.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>path_planning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS中的ros::spin()详解</title>
    <link href="/2023/04/11/ROS%E4%B8%AD%E7%9A%84ros-spin-%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/04/11/ROS%E4%B8%AD%E7%9A%84ros-spin-%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS中的ros-spin-详解"><a href="#ROS中的ros-spin-详解" class="headerlink" title="ROS中的ros::spin()详解"></a>ROS中的ros::spin()详解</h1><p>在ROS中，ros::spin()是一个常见的函数调用，它允许ROS节点进入事件循环并处理来自其他节点的消息和服务请求。该函数被称为“自旋”，因为它在事件循环中持续运行，直到节点收到退出信号或调用ros::shutdown()函数。  </p><p>当ROS节点调用ros::spin()时，它会一直等待直到有消息到达该节点。当节点接收到消息时，它将调用与该消息相关联的回调函数进行处理。这使得ROS节点能够响应其他节点的请求，同时保持事件循环处于活动状态。</p><p>在ROS中，消息和服务请求都是通过ROS主题传输的。ROS主题是一种用于发布和订阅消息的通信机制。ROS节点可以发布消息到一个或多个主题，也可以订阅一个或多个主题以接收消息。当节点订阅主题时，它将等待消息到达并调用相应的回调函数进行处理。</p><p>通过调用ros::spin()，ROS节点将一直处于事件循环中，等待来自主题的消息和服务请求。当节点接收到消息时，它将自动调用与该消息相关联的回调函数进行处理。这使得ROS节点能够以异步方式处理消息，而无需阻塞其他节点或执行其他任务。</p><p>需要注意的是，调用ros::spin()函数将使节点永久保持活动状态，直到收到退出信号或调用ros::shutdown()函数。因此，如果节点需要在运行一段时间后退出，必须在程序中包含相应的退出机制，例如使用Ctrl+C信号等方式触发退出信号。</p><p>另外，如果ROS节点有多个订阅者和/或发布者，调用ros::spin()函数将确保所有这些节点都在运行，并等待消息。这有助于确保节点可以同时处理来自多个主题的消息，并使整个ROS系统保持同步和一致性。</p><p>另外，ROS节点还可以使用ros::spinOnce()函数进行自旋。与ros::spin()函数不同的是，ros::spinOnce()函数仅在事件循环中执行一次，然后返回。这使得节点能够在执行其他任务的同时处理来自主题的消息。但是，与调用ros::spin()函数一样，节点必须在某个时刻调用ros::shutdown()函数以关闭ROS节点。</p><p>需要注意的是，使用ros::spin()或ros::spinOnce()函数时，节点必须在至少一个主题上进行订阅或发布，否则事件循环将不会启动。</p><p>总之，ros::spin()是ROS中一个重要的函数，它允许节点处理来自其他节点的消息和服务请求，并保持节点在事件循环中运行。这使得ROS节点能够以异步方式处理消息，从而使整个ROS系统更加高效和灵活。</p><h1 id="ros-spin-的例子"><a href="#ros-spin-的例子" class="headerlink" title="ros::spin()的例子"></a>ros::spin()的例子</h1><p>下面是一个简单的ROS节点示例，演示了如何使用ros::spin()函数进行自旋并处理来自其他节点的消息：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;std_msgs/String.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">messageCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::<span class="hljs-type">String</span>::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="hljs-built_in">c_str</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 初始化ROS节点</span><br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;listener&quot;</span>);<br><br>  <span class="hljs-comment">// 创建节点句柄</span><br>  ros::NodeHandle nh;<br><br>  <span class="hljs-comment">// 创建订阅者并订阅名为&quot;chatter&quot;的主题</span><br>  ros::Subscriber sub = nh.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter&quot;</span>, <span class="hljs-number">1000</span>, messageCallback);<br><br>  <span class="hljs-comment">// 启动ROS事件循环并进入自旋</span><br>  ros::<span class="hljs-built_in">spin</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>在此示例中，我们创建了一个名为”listener”的ROS节点，并创建了一个名为”chatter”的主题的订阅者。我们通过调用ros::spin()函数使该节点进入自旋状态，等待来自”chatter”主题的消息。</p><p>当节点接收到消息时，将自动调用messageCallback()函数进行处理。在这个例子中，我们简单地将消息打印到ROS日志中。</p><p>需要注意的是，在这个例子中，我们没有调用ros::shutdown()函数，因此节点将一直运行，直到我们手动终止它。如果要退出节点，可以使用Ctrl+C信号或其他退出机制。</p><h1 id="ros-spinOnce"><a href="#ros-spinOnce" class="headerlink" title="ros::spinOnce()"></a>ros::spinOnce()</h1><p>另外，我们还可以使用ros::spinOnce()函数代替ros::spin()函数进行自旋，如下所示：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;std_msgs/String.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">messageCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::<span class="hljs-type">String</span>::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="hljs-built_in">c_str</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 初始化ROS节点</span><br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;listener&quot;</span>);<br><br>  <span class="hljs-comment">// 创建节点句柄</span><br>  ros::NodeHandle nh;<br><br>  <span class="hljs-comment">// 创建订阅者并订阅名为&quot;chatter&quot;的主题</span><br>  ros::Subscriber sub = nh.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter&quot;</span>, <span class="hljs-number">1000</span>, messageCallback);<br><br>  <span class="hljs-comment">// 进入ROS事件循环并处理来自其他节点的消息</span><br>  <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>  &#123;<br>    ros::<span class="hljs-built_in">spinOnce</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>在这个例子中，我们使用while循环和ros::spinOnce()函数来进行自旋，并在每次循环中处理来自”chatter”主题的消息。需要注意的是，在这个例子中，我们使用了ros::ok()函数来检查节点是否已经被关闭，从而决定是否退出自旋循环。</p><p>总之，ros::spin()和ros::spinOnce()函数是ROS中非常重要的函数，它们使ROS节点能够响应其他节点的消息和服务请求，并保持节点在事件循环中运行。通过使用这些函数，我们可以更轻松地开发和部署ROS应用程序，并使其更加高效和灵活。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS中sensor_msgs的LaserScan详解</title>
    <link href="/2023/04/11/ROS%E4%B8%ADsensor-msgs%E7%9A%84LaserScan%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/04/11/ROS%E4%B8%ADsensor-msgs%E7%9A%84LaserScan%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS中sensor-msgs的LaserScan详解"><a href="#ROS中sensor-msgs的LaserScan详解" class="headerlink" title="ROS中sensor_msgs的LaserScan详解"></a>ROS中sensor_msgs的LaserScan详解</h1><p>在ROS（Robot Operating System，机器人操作系统）中，sensor_msgs::LaserScan是一个消息类型，用于表示一维的激光雷达（LIDAR）或者二维激光扫描仪的数据。激光扫描仪是一种常用于机器人导航、避障和建图的传感器。它通过向周围环境发射激光束，然后接收反射回来的激光束，进而测量物体距离和方位。<br>sensor_msgs::LaserScan消息包含了以下主要字段：  </p><ol><li>Header header：<br>header字段包含时间戳（stamp）和坐标系（frame_id）信息。时间戳表示此激光扫描数据的获取时间，而坐标系表示数据相对于哪个参考系进行描述。</li><li>float32 angle_min：<br>angle_min字段表示扫描开始时的角度，通常以弧度为单位。这是激光雷达扫描范围的最小角度。</li><li>float32 angle_max：<br>angle_max字段表示扫描结束时的角度，通常以弧度为单位。这是激光雷达扫描范围的最大角度。</li><li>float32 angle_increment：<br>angle_increment表示激光雷达的两次扫描间隔的角度，以弧度为单位。这是激光雷达在扫描过程中，相邻两个测量点之间的角度差。</li><li>float32 time_increment：<br>time_increment表示激光雷达在进行两次测量之间的时间间隔，以秒为单位。这有助于了解激光雷达采样速率。</li><li>float32 scan_time：<br>scan_time表示激光雷达完成一次完整扫描所需的时间，以秒为单位。这有助于了解激光雷达的扫描频率。</li><li>float32 range_min：<br>range_min表示激光雷达能够检测到的最小距离，通常以米为单位。这是激光雷达能够可靠测量的最短距离。</li><li>float32 range_max：<br>range_max表示激光雷达能够检测到的最大距离，通常以米为单位。这是激光雷达能够可靠测量的最远距离。</li><li>float32[] ranges：<br>ranges字段是一个浮点数组，包含从激光雷达返回的距离数据。数组中的每个元素表示对应角度的测量距离值。</li><li>float32[] intensities：<br>intensities字段是一个可选的浮点数组，包含从激光雷达返回的反射强度数据。数组中的每个元素表示对应角度的反射强度值，通常用于检测物体的表面特性和反光性质。</li></ol><p>总之，sensor_msgs::LaserScan消息类型提供了机器人导航和避障等领域中广泛使用的激光雷达数据的表示和传输方式。激光雷达可以提供非常详细和准确的环境地图信息，但是处理这些数据也需要一定的计算资源和算法支持。在ROS中，可以使用各种算法和工具包来处理sensor_msgs::LaserScan消息，例如使用gmapping工具包生成地图，使用ROS Navigation Stack进行路径规划和避障等。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++原子类型详解</title>
    <link href="/2023/04/11/C-%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/04/11/C-%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="C-原子类型详解"><a href="#C-原子类型详解" class="headerlink" title="C++原子类型详解"></a>C++原子类型详解</h1><p>C++ 原子类型（atomic types）是 C++11 标准引入的一种特殊数据类型，用于实现多线程环境中的无锁编程。原子类型可以确保某些操作在多线程情况下是原子的，即不可中断和不可分割。原子操作可以避免数据竞争和同步问题，提高代码的可扩展性和性能。  </p><p>C++ 标准库（<atomic> 头文件）提供了多种原子类型，包括整数、指针和自定义类型的特化。以下是一些常见的 C++ 原子类型：  </p><p>1.std::atomic_bool: 原子布尔类型，用于表示一个原子布尔值。<br>2.std::atomic_int: 原子整数类型，用于表示一个原子整数值。<br>3.std::atomic_uint: 原子无符号整数类型，用于表示一个原子无符号整数值。<br>4.std::atomic<T*>: 原子指针类型，用于表示一个原子指针值。<br>以下是 C++ 原子类型的一些常用操作：<br>1.初始化：原子类型的变量可以使用直接初始化或拷贝初始化。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby">std::atomic_int myInt(<span class="hljs-number">0</span>); <span class="hljs-regexp">//</span> 初始化为 <span class="hljs-number">0</span><br>std::atomic_bool myBool&#123;<span class="hljs-literal">true</span>&#125;; <span class="hljs-regexp">//</span> 初始化为 <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><br>2.读取值：可以使用 load() 成员函数以原子方式读取原子类型变量的值。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int value <span class="hljs-operator">=</span> myInt.load()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><br>3.设置值：可以使用 store() 成员函数以原子方式设置原子类型变量的值。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">myInt.store(<span class="hljs-number">42</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><br>4.原子操作符：原子类型提供了一组原子操作符，如 exchange()，fetch_add()，fetch_sub() 等。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> oldValue = myInt.<span class="hljs-built_in">exchange</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// 设置原子整数值为 42 并返回旧值</span><br><span class="hljs-type">int</span> newValue = myInt.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 原子地将 myInt 的值加 1 并返回新值</span><br></code></pre></td></tr></table></figure><br>5.比较和交换（compare-and-swap）：原子类型提供了 compare_exchange_weak() 和 compare_exchange_strong() 方法，用于实现原子比较和交换操作。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> expected = <span class="hljs-number">42</span>;<br><span class="hljs-built_in">int</span> desired = <span class="hljs-number">43</span>;<br><span class="hljs-built_in">bool</span> result = myInt.compare<span class="hljs-constructor">_exchange_weak(<span class="hljs-params">expected</span>, <span class="hljs-params">desired</span>)</span>;<br></code></pre></td></tr></table></figure><br>请注意，在某些情况下，使用原子类型可能并不是最佳解决方案，例如当需要对多个共享资源进行同步访问时。在这种情况下，互斥锁、条件变量和其他同步原语可能更适合解决问题。同时，原子操作虽然避免了互斥锁带来的性能损失，但它们仍然可能比普通操作更耗时。因此，在编写多线程代码时，请仔细权衡各种方法的优缺点以确定最佳策略。<br>当使用原子类型时，还应注意以下几点：<br>1.内存模型：C++11 引入了内存模型的概念，这有助于更精细地控制原子操作的内存顺序。内存模型有以下几种：</p><ul><li>std::memory_order_relaxed：松散内存顺序，不强制任何顺序要求，仅确保操作本身是原子的。</li><li>std::memory_order_consume：消费顺序，保证写操作对消费操作可见。</li><li>std::memory_order_acquire：获取顺序，确保在此操作之前的读/写操作不会被重排到此操作之后。</li><li>std::memory_order_release：释放顺序，确保在此操作之后的读/写操作不会被重排到此操作之前。</li><li>std::memory_order_acq_rel：获取/释放顺序，同时保证获取和释放顺序。</li><li>std::memory_order_seq_cst：顺序一致性，最严格的内存顺序。</li></ul><p>大多数原子操作都可以接受一个内存顺序参数，以便更精确地控制操作行为。然而，正确使用内存顺序是一项复杂的任务，容易出错。在不确定的情况下，请使用默认的顺序一致性内存模型。 </p><p>2.可能的性能问题：虽然原子类型可以避免使用互斥锁等同步原语带来的性能损失，但原子操作本身可能比非原子操作更耗时。尤其是在高度争用的情况下，原子操作可能导致性能瓶颈。在这种情况下，可能需要寻找其他优化方法，如锁分解、锁粒度调整或使用无锁数据结构。 </p><p>3.原子操作的局限性：原子类型适用于简单的同步需求，例如单个共享变量的更新。但对于涉及多个共享资源的复杂操作，原子类型无法提供足够的同步保证。在这种情况下，互斥锁、条件变量或其他同步原语可能更合适  </p><p>总之，C++ 原子类型提供了一种在多线程环境中实现无锁编程的方法，可以避免数据竞争和同步问题。然而，在使用原子类型时，需要权衡性能和正确性，仔细选择最适合的内存模型，以及针对具体场景选择最佳的同步策略。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>std::atomic_bool用法详解</title>
    <link href="/2023/04/11/std-atomic-bool%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/04/11/std-atomic-bool%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="std-atomic-bool用法详解"><a href="#std-atomic-bool用法详解" class="headerlink" title="std::atomic_bool用法详解"></a>std::atomic_bool用法详解</h1><p>std::atomic_bool 是 C++ 标准库中的一个原子类型，它用于表示一个原子布尔值。原子类型是一种特殊的数据类型，可以在多线程环境中实现无锁操作，避免数据竞争和同步问题。std::atomic_bool 是 std::atomic<bool> 的一个特化，提供了原子操作布尔值的接口。<br>以下是 std::atomic_bool 的一些常见用法：<br>1.初始化:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">std::atomic_bool flag(<span class="hljs-literal">false</span>); <span class="hljs-regexp">//</span> 初始化为 <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><br>这将创建一个名为 flag 的原子布尔值并将其初始化为 false。<br>2.读取值：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">bool currentValue = <span class="hljs-built_in">flag</span>.<span class="hljs-built_in">load</span>(); <span class="hljs-comment">// 读取原子布尔值</span><br></code></pre></td></tr></table></figure><br>load() 方法以原子方式读取 flag 的当前值。这可以确保在多线程环境中读取值时不会发生数据竞争。<br>3.设置值：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">flag.store(<span class="hljs-literal">true</span>); <span class="hljs-regexp">//</span> 设置原子布尔值为 <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><br>store() 方法以原子方式设置 flag 的值。这可以确保在多线程环境中设置值时不会发生数据竞争。<br>4.原子比较和交换（Compare-and-swap）：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> expected = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">bool</span> desired = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">bool</span> result = flag.compare<span class="hljs-constructor">_exchange_weak(<span class="hljs-params">expected</span>, <span class="hljs-params">desired</span>)</span>;<br></code></pre></td></tr></table></figure><br>compare_exchange_weak() 方法比较 flag 的当前值与 expected 值。如果它们相等，该方法会将 flag 设置为 desired 值，并返回 true。如果它们不等，则返回 false，并将 expected 更新为 flag 的当前值。这个操作是原子的，因此在多线程环境中也是安全的。<br>5.原子操作符：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> oldValue = flag.<span class="hljs-built_in">exchange</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 将原子布尔值设置为 true 并返回旧值</span><br></code></pre></td></tr></table></figure><br>exchange() 方法将 flag 的值设置为指定值，并返回其原始值。这个操作也是原子的。</p><p>使用 std::atomic_bool 可以方便地在多线程环境中实现无锁操作，避免使用互斥锁带来的性能损失。然而，需要注意的是，原子操作虽然高效，但并非所有场景都适用。在某些情况下，互斥锁和其他同步原语可能更合适。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并分支到main上</title>
    <link href="/2023/04/06/%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E5%88%B0main%E4%B8%8A/"/>
    <url>/2023/04/06/%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E5%88%B0main%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="git合并分支到main上"><a href="#git合并分支到main上" class="headerlink" title="git合并分支到main上"></a>git合并分支到main上</h1><h2 id="查看当前分支"><a href="#查看当前分支" class="headerlink" title="查看当前分支"></a>查看当前分支</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure><h2 id="在当前分支提交代码"><a href="#在当前分支提交代码" class="headerlink" title="在当前分支提交代码"></a>在当前分支提交代码</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git  <span class="hljs-keyword">add</span> .  <br>git  <span class="hljs-keyword">commit</span> -m <span class="hljs-string">&#x27;initial commit&#x27;</span>  <br>git push -u origin dev  <br></code></pre></td></tr></table></figure><h2 id="dev分支的代码合并到main分支上"><a href="#dev分支的代码合并到main分支上" class="headerlink" title="dev分支的代码合并到main分支上"></a>dev分支的代码合并到main分支上</h2><p>首先切换到main分支上<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git  checkout <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure><br>如果是多人开发的话 需要把远程main上的代码pull下来<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git pull origin <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure><br>把dev分支的代码合并到main上<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">git  <span class="hljs-keyword">merge</span> dev<br></code></pre></td></tr></table></figure><br>查看状态<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span><br></code></pre></td></tr></table></figure><br>push到远程main上<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> main<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS中roll pitch yaw分别是绕哪个轴转</title>
    <link href="/2023/04/06/ROS%E4%B8%ADroll-pitch-yaw%E5%88%86%E5%88%AB%E6%98%AF%E7%BB%95%E5%93%AA%E4%B8%AA%E8%BD%B4%E8%BD%AC/"/>
    <url>/2023/04/06/ROS%E4%B8%ADroll-pitch-yaw%E5%88%86%E5%88%AB%E6%98%AF%E7%BB%95%E5%93%AA%E4%B8%AA%E8%BD%B4%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS中roll-pitch-yaw分别是绕哪个轴转"><a href="#ROS中roll-pitch-yaw分别是绕哪个轴转" class="headerlink" title="ROS中roll pitch yaw分别是绕哪个轴转"></a>ROS中roll pitch yaw分别是绕哪个轴转</h1><img src="/2023/04/06/ROS%E4%B8%ADroll-pitch-yaw%E5%88%86%E5%88%AB%E6%98%AF%E7%BB%95%E5%93%AA%E4%B8%AA%E8%BD%B4%E8%BD%AC/rpy.png" class="" title="roll-pitch-yaw">  <p>pitch是围绕X轴旋转，也叫做俯仰角。<br>yaw是围绕Y轴旋转，也叫偏航角。<br>roll是围绕Z轴旋转，也叫翻滚角。<br>在3D系统中，假设视点为原点，则视点坐标系如下图所示，通常z轴的负方向是视点方向<br><img src="/2023/04/06/ROS%E4%B8%ADroll-pitch-yaw%E5%88%86%E5%88%AB%E6%98%AF%E7%BB%95%E5%93%AA%E4%B8%AA%E8%BD%B4%E8%BD%AC/sight.png" class="" title="3D系统"></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS主从机配置</title>
    <link href="/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>与伙伴之间的工作配合可能涉及到ROS功能之间的调试，这时采用主从机的方式比较方便。</p><h1 id="配置虚拟机网络适配器"><a href="#配置虚拟机网络适配器" class="headerlink" title="配置虚拟机网络适配器"></a>配置虚拟机网络适配器</h1><p>虚拟机网络设置为桥接模式<br><img src="/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/bridge.png" class="" title="虚拟机网络模式"></p><h1 id="查看主机和从机IP"><a href="#查看主机和从机IP" class="headerlink" title="查看主机和从机IP"></a>查看主机和从机IP</h1><p>打开终端输入<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span><br></code></pre></td></tr></table></figure><br>如果报错请相应安装相关软件<br><img src="/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/ifconfig.png" class="" title="查看主机和从机的IP"></p><h1 id="设置IP地址"><a href="#设置IP地址" class="headerlink" title="设置IP地址"></a>设置IP地址</h1><p>首先需要确定ROS多机系统中的所有计算机处于同一网络，同一网段，例如我的主机IP为192.168.21.228，从机IP为192.168.21.17<br>分别在两台计算机系统的/etc/hosts文件中加入对方的IP地址和对应的计算机名：</p><h1 id="主机hosts设置"><a href="#主机hosts设置" class="headerlink" title="主机hosts设置"></a>主机hosts设置</h1><p>主机设置的是从机的IP和计算机名<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/</span>hosts<br></code></pre></td></tr></table></figure><br><img src="/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/host.png" class="" title="主机hosts设置"></p><h1 id="从机hosts设置"><a href="#从机hosts设置" class="headerlink" title="从机hosts设置"></a>从机hosts设置</h1><p>从机设置的是主机的IP和计算机名<br>从机打开终端<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/</span>hosts<br></code></pre></td></tr></table></figure><br><img src="/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/slave.png" class="" title="从机hosts设置"><br><strong>这里因为我的主机和从机计算机名相同，所以在这里不要困惑</strong></p><h1 id="主机环境变量设置"><a href="#主机环境变量设置" class="headerlink" title="主机环境变量设置"></a>主机环境变量设置</h1><p>这里两种方式可选择1、打开新终端设置环境变量2、在~/.bashrc文件末尾添加，两种方式都填入如下内容<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">ROS_HOSTNAME</span>=192.168.21.228 #主机IP地址  <br><span class="hljs-built_in">export</span> <span class="hljs-attribute">ROS_MASTER_URI</span>=http://192.168.21.228:11311 #主机IP地址:11311  <br><span class="hljs-built_in">export</span> <span class="hljs-attribute">ROS_IP</span>=190.168.21.228 #主机IP地址<br></code></pre></td></tr></table></figure></p><h1 id="从机环境变量设置"><a href="#从机环境变量设置" class="headerlink" title="从机环境变量设置"></a>从机环境变量设置</h1><p>这里同样有两种方式可选择1、打开新终端设置环境变量2、在~/.bashrc文件末尾添加，两种方式都填入如下内容<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">ROS_HOSTNAME</span>=192.168.21.17 #从机IP地址  <br><span class="hljs-built_in">export</span> <span class="hljs-attribute">ROS_MASTER_URI</span>=http://192.168.21.228:11311 #主机IP地址:11311<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">ROS_IP</span>=190.168.21.228 #主机IP地址<br></code></pre></td></tr></table></figure></p><h1 id="下载包和解决报错"><a href="#下载包和解决报错" class="headerlink" title="下载包和解决报错"></a>下载包和解决报错</h1><p>两台电脑都要下载以下两个包<br>第一个是下载同步包；第二个是下载ssh服务器<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install chrony<br></code></pre></td></tr></table></figure><br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> install openssh-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><br>重启ssh-server<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/etc/i</span>nit.d/ssh restart<br></code></pre></td></tr></table></figure></p><h1 id="检测通信"><a href="#检测通信" class="headerlink" title="检测通信"></a>检测通信</h1><p>设置完成后，在两台电脑上分别使用ping命令测试网络是否联通。其中ping是用来检测本机与网络中另一主机之间网络是否联通的命令，如果两台主机之间ping不通，则表明这两台主机不能建立起连接。</p><h2 id="主机ping从机"><a href="#主机ping从机" class="headerlink" title="主机ping从机"></a>主机ping从机</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ping</span> <span class="hljs-number">192.168.21.17</span><br></code></pre></td></tr></table></figure><h2 id="从机ping主机"><a href="#从机ping主机" class="headerlink" title="从机ping主机"></a>从机ping主机</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ping</span> <span class="hljs-number">192.168.21.228</span><br></code></pre></td></tr></table></figure><p>两台电脑上都出现了ping接收到了数据，说明双向网络能正常联通，底层网络的通信就可以实现。<br><strong>当然，如果碰到输入ping IP而一直无法响应时，说明没有ping通，检查一下该计算机对应的ip地址是否变动了</strong></p><h1 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h1><p>配置完毕，接下来就要验证是否配置成功。但是运行前先要把之前的终端关掉，不然还是之前的配置<br>运行一个小海龟来验证一下，主机中输入：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">roscore</span><br></code></pre></td></tr></table></figure><br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosrun turtlesim turtlesim_node</span><br></code></pre></td></tr></table></figure><br><img src="/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/demo.png" class="" title="主机运行海龟"><br>在从机器中用键盘进行控制，从机中运行：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosrun turtlesim turtle_teleop_key</span><br></code></pre></td></tr></table></figure><br><img src="/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/demo2.png" class="" title="从机键盘控制主机的海龟移动"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://wiki.ros.org/ROS/Tutorials/MultipleMachines">http://wiki.ros.org/ROS/Tutorials/MultipleMachines</a><br><a href="https://www.guyuehome.com/25106">https://www.guyuehome.com/25106</a><br><a href="https://blog.csdn.net/weixin_51244852/article/details/115738730">https://blog.csdn.net/weixin_51244852/article/details/115738730</a><br><a href="https://blog.csdn.net/GeForeverr/article/details/102465763">https://blog.csdn.net/GeForeverr/article/details/102465763</a><br><a href="https://www.guyuehome.com/40852">https://www.guyuehome.com/40852</a></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS海龟跟随-理解TF坐标变换</title>
    <link href="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/"/>
    <url>/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS海龟跟随-理解TF坐标变换"><a href="#ROS海龟跟随-理解TF坐标变换" class="headerlink" title="ROS海龟跟随-理解TF坐标变换"></a>ROS海龟跟随-理解TF坐标变换</h1><p>本篇我们在海龟仿真器中，通过一个例程（turtle_tf）来理解TF的作用，并且熟悉之前学到的TF工具。该例程的功能包turtle_tf可以使用如下命令进行安装：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-turtle-tf<br></code></pre></td></tr></table></figure><br>安装完成后，就可以使用如下命令运行例程了：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">roslaunch turtle_tf turtle_tf_demo.<span class="hljs-built_in">launch</span><br></code></pre></td></tr></table></figure><br>海龟仿真器打开后会出现两只小海龟，并且下方的小海龟自动向中心位置的小海龟移动<br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/turtlesim.png" class="" title="海龟仿真器"><br>键盘控制一只海龟移动，另一只会跟随着一起移动<br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/follow.png" class="" title="海龟跟随移动"><br>另外一只海龟总是会跟随我们控制的那只海龟运行。在这个例程中，TF是如何运用的呢？我们首先使用TF工具来看一下这个例程中的TF树是什么样的：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosrun tf view_frames</span><br></code></pre></td></tr></table></figure><br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/view_frame.png" class="" title="TF树"><br>在当前系统中存在三个坐标系：world、turtle1、turtle2。world是世界坐标系，作为系统的基础坐标系，其他坐标系都相对该坐标系建立，所以world是TF树的根节点。相对于world坐标系，又分别针对两只海龟创建了两个海龟坐标系，这两个坐标系的原点就是海龟在世界坐标系下的坐标位置。<br>现在要让turtle2跟随turtle1运动，相当于turtle2坐标系向turtle1坐标系移动，这就需要知道turtle2与turtle1之间的坐标变换。三个坐标系之间的变换关系可以使用如下公式描述：<br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/trans.png" class="" title="海龟之间的坐标变换"><br>使用tf_echo工具在TF树中查找海龟坐标系之间的变换关系：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">rosrun tf tf_<span class="hljs-keyword">echo</span> turtle1 turtle2<br></code></pre></td></tr></table></figure><br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/trans_matrix.png" class="" title="变换矩阵"><br>也可以通过rviz的图形界面更加形象的看到这三者之间的坐标关系：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">rosrun rviz rviz -d `rospack <span class="hljs-keyword">find</span> turtle_tf`<span class="hljs-regexp">/rviz/</span>turtle_rviz.rviz<br></code></pre></td></tr></table></figure><br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/rviz.png" class="" title="rviz中坐标系之间关系"><br>得到turtle2与turtle1之间的坐标变换后，就可以计算两只海龟间的距离和角度，即可控制turtle2向turtle1移动了。<br>接下来，我们以这个例程为目标，学习如何实现TF的广播和监听功能。  </p><h1 id="创建TF广播器"><a href="#创建TF广播器" class="headerlink" title="创建TF广播器"></a>创建TF广播器</h1><p>首先，我们需要创建一个发布海龟坐标系与世界坐标系之间TF变换的节点，实现源码turtle_tf_broadcaster.cpp的具体内容如下：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;ros/ros.h&gt;<br>#<span class="hljs-keyword">include</span> &lt;tf/transform_broadcaster.h&gt;<br>#<span class="hljs-keyword">include</span> &lt;turtlesim/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Pose</span>.</span></span>h&gt;<br><br>std::<span class="hljs-built_in">string</span> turtle_name;<br><br>void pose<span class="hljs-constructor">Callback(<span class="hljs-params">const</span> <span class="hljs-params">turtlesim</span>::PoseConstPtr&amp; <span class="hljs-params">msg</span>)</span><br>&#123;<br><span class="hljs-comment">// tf广播器</span><br>static tf::TransformBroadcaster br;<br><br><span class="hljs-comment">// 根据海龟当前的位姿，设置相对于世界坐标系的坐标变换</span><br>tf::Transform transform;<br>transform.set<span class="hljs-constructor">Origin( <span class="hljs-params">tf</span>::Vector3(<span class="hljs-params">msg</span>-&gt;<span class="hljs-params">x</span>, <span class="hljs-params">msg</span>-&gt;<span class="hljs-params">y</span>, 0.0)</span> );<br>tf::Quaternion q;<br>q.set<span class="hljs-constructor">RPY(0, 0, <span class="hljs-params">msg</span>-&gt;<span class="hljs-params">theta</span>)</span>;<br>transform.set<span class="hljs-constructor">Rotation(<span class="hljs-params">q</span>)</span>;<br><br><span class="hljs-comment">// 发布坐标变换</span><br>br.send<span class="hljs-constructor">Transform(<span class="hljs-params">tf</span>::StampedTransform(<span class="hljs-params">transform</span>, <span class="hljs-params">ros</span>::Time::<span class="hljs-params">now</span>()</span>, <span class="hljs-string">&quot;world&quot;</span>, turtle_name));<br>&#125;<br><br><span class="hljs-built_in">int</span> main(<span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span>** argv)<br>&#123;<br><span class="hljs-comment">// 初始化节点</span><br>ros::init(argc, argv, <span class="hljs-string">&quot;my_tf_broadcaster&quot;</span>);<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-constructor">ROS_ERROR(<span class="hljs-string">&quot;need turtle name as argument&quot;</span>)</span>; <br>return -<span class="hljs-number">1</span>;<br>&#125;;<br>turtle_name = argv<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>;<br><br><span class="hljs-comment">// 订阅海龟的pose信息</span><br>ros::NodeHandle node;<br>ros::Subscriber sub = node.subscribe(turtle_name+<span class="hljs-string">&quot;/pose&quot;</span>, <span class="hljs-number">10</span>, &amp;poseCallback);<br><br>ros::spin<span class="hljs-literal">()</span>;<br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>以上代码的关键部分是处理海龟pose消息的回调函数poseCallback。在广播TF消息之前需要定义tf::TransformBroadcaster广播器，然后根据海龟当前的位姿，设置tf::Transform类型的坐标变换，包含setOrigin设置的平移变换以及setRotation设置的旋转变换。<br>然后使用广播器将坐标变换插入TF树并且发布，这里发布的TF消息类型是tf::StampedTransform，不仅包含tf::Transform类型的坐标变换、时间戳，而且还需要指定坐标变换的源坐标系（parent）和目标坐标系（child）。  </p><h1 id="创建TF监听器"><a href="#创建TF监听器" class="headerlink" title="创建TF监听器"></a>创建TF监听器</h1><p>TF消息广播之后，其他节点就可以监听该TF消息，从而获取需要的坐标变换了。<br>目前我们已经将海龟相对于world坐标系的TF变换广播，接下来需要监听TF消息，并从中获取turtle2相对于turtle1坐标系的变换，从而控制turtle2移动。实现源码turtle_tf_listener.cpp的详细内容如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tf/transform_listener.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;geometry_msgs/Twist.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;turtlesim/Spawn.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 初始化节点</span><br>ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;my_tf_listener&quot;</span>);<br><br>ros::NodeHandle node;<br><br><span class="hljs-comment">// 通过服务调用，产生第二只乌龟turtle2</span><br>ros::service::<span class="hljs-built_in">waitForService</span>(<span class="hljs-string">&quot;spawn&quot;</span>);<br>ros::ServiceClient add_turtle =<br>node.<span class="hljs-built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="hljs-string">&quot;spawn&quot;</span>);<br>turtlesim::Spawn srv;<br>add_turtle.<span class="hljs-built_in">call</span>(srv);<br><br><span class="hljs-comment">// 定义turtle2的速度控制发布器</span><br>ros::Publisher turtle_vel =<br>node.<span class="hljs-built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="hljs-string">&quot;turtle2/cmd_vel&quot;</span>, <span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// tf监听器</span><br>tf::TransformListener listener;<br><br><span class="hljs-function">ros::Rate <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-number">10.0</span>)</span></span>;<br><span class="hljs-keyword">while</span> (node.<span class="hljs-built_in">ok</span>())<br>&#123;<br>tf::StampedTransform transform;<br><span class="hljs-keyword">try</span><br>&#123;<br><span class="hljs-comment">// 查找turtle2与turtle1的坐标变换</span><br>listener.<span class="hljs-built_in">waitForTransform</span>(<span class="hljs-string">&quot;/turtle2&quot;</span>, <span class="hljs-string">&quot;/turtle1&quot;</span>, ros::<span class="hljs-built_in">Time</span>(<span class="hljs-number">0</span>), ros::<span class="hljs-built_in">Duration</span>(<span class="hljs-number">3.0</span>));<br>listener.<span class="hljs-built_in">lookupTransform</span>(<span class="hljs-string">&quot;/turtle2&quot;</span>, <span class="hljs-string">&quot;/turtle1&quot;</span>, ros::<span class="hljs-built_in">Time</span>(<span class="hljs-number">0</span>), transform);<br>&#125;<br><span class="hljs-built_in">catch</span> (tf::TransformException &amp;ex) <br>&#123;<br><span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;%s&quot;</span>,ex.<span class="hljs-built_in">what</span>());<br>ros::<span class="hljs-built_in">Duration</span>(<span class="hljs-number">1.0</span>).<span class="hljs-built_in">sleep</span>();<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">// 根据turtle1和turtle2之间的坐标变换，计算turtle2需要运动的线速度和角速度</span><br><span class="hljs-comment">// 并发布速度控制指令，使turtle2向turtle1移动</span><br>geometry_msgs::Twist vel_msg;<br>vel_msg.angular.z = <span class="hljs-number">4.0</span> * <span class="hljs-built_in">atan2</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">y</span>(),<br>transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">x</span>());<br>vel_msg.linear.x = <span class="hljs-number">0.5</span> * <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">x</span>(), <span class="hljs-number">2</span>) +<br><span class="hljs-built_in">pow</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">y</span>(), <span class="hljs-number">2</span>));<br>turtle_vel.<span class="hljs-built_in">publish</span>(vel_msg);<br><br>rate.<span class="hljs-built_in">sleep</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>该节点首先通过服务调用产生海龟turtle2，然后声明控制turtle2速度的Publisher。在监听TF消息之前，需要创建一个tf::TransformListener类型的监听器，创建成功后监听器会自动接收TF树的消息，并且缓存10秒。<br>然后在循环中就可以实时查找TF树中的坐标变换了，这里需要调用的是tf::TransformListener中的两个接口：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">wait<span class="hljs-constructor">ForTransform(<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span> &amp;<span class="hljs-params">target_frame</span>, <span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span>&amp;<span class="hljs-params">source_frame</span>, <span class="hljs-params">const</span> <span class="hljs-params">ros</span>::Time&amp;<span class="hljs-params">time</span>, <span class="hljs-params">const</span> <span class="hljs-params">ros</span>::Duration &amp;<span class="hljs-params">timeout</span>)</span><br></code></pre></td></tr></table></figure><br>给定的源坐标系（source_frame）和目标坐标系（target_frame），等待两个坐标系之间指定时间（time）的变换关系，该函数会阻塞程序运行，所以需要设置超时时间（timeout）。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">lookup<span class="hljs-constructor">Transform(<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span> &amp;<span class="hljs-params">target_frame</span>,<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span> &amp;<span class="hljs-params">source_frame</span>, <span class="hljs-params">const</span> <span class="hljs-params">ros</span>::Time &amp; <span class="hljs-params">time</span>,StampedTransform &amp;<span class="hljs-params">transform</span>)</span><br></code></pre></td></tr></table></figure><br>给定的源坐标系（source_frame）和目标坐标系（target_frame），得到两个坐标系之间指定时间（time）的坐标变换（transform），ros::Time(0) 表示我们想要的是最新一次的坐标变换。<br>通过以上两个接口的调用，就可以获取turtle2相对于turtle1的坐标变换了。然后根据坐标系之间的位置关系，计算得到turtle2需要运动的线速度和角速度，并发布速度控制指令，使turtle2向turtle1移动。</p><h1 id="实现海龟跟随运动"><a href="#实现海龟跟随运动" class="headerlink" title="实现海龟跟随运动"></a>实现海龟跟随运动</h1><p>现在小海龟跟随例程的所有代码都已经完成，我们来编写一个launch文件，将所有节点运行起来，start_demo_with_listener.launch：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 海龟仿真器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sim&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 键盘控制 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_teleop_key&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teleop&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 两只海龟的tf广播 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;tf_demo&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_broadcaster&quot;</span> <span class="hljs-attr">args</span>=<span class="hljs-string">&quot;/turtle1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle1_tf_broadcaster&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;tf_demo&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_broadcaster&quot;</span> <span class="hljs-attr">args</span>=<span class="hljs-string">&quot;/turtle2&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle2_tf_broadcaster&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 监听tf广播，并且控制turtle2移动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;tf_demo&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_listener&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">name</span>=<span class="hljs-string">&quot;listener&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><br>运行该launch文件，就可以看到与之前例程类似的两只海龟的界面了，在终端中通过键盘控制turtle1移动，turtle2也跟随移动。  </p><h1 id="设置不同颜色区分海龟的轨迹"><a href="#设置不同颜色区分海龟的轨迹" class="headerlink" title="设置不同颜色区分海龟的轨迹"></a>设置不同颜色区分海龟的轨迹</h1><p>如果想用不同颜色区分小海龟的轨迹可以在新终端打开rqt<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rqt</span><br></code></pre></td></tr></table></figure><br>然后在service下拉选项选择/turtle1/set_pen设置第一个小海龟轨迹的颜色<br><br>然后点击call完成设置<br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/red.png" class="" title="海龟轨迹颜色设置"><br>然后键盘控制海龟移动，海归的轨迹显示了不同的颜色<br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/color_path.png" class="" title="不同海龟轨迹颜色"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://zhuanlan.zhihu.com/p/58184028">参考文章</a></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rosbag包绘图工具PlotJuggler使用方法</title>
    <link href="/2023/03/29/rosbag%E5%8C%85%E7%BB%98%E5%9B%BE%E5%B7%A5%E5%85%B7PlotJuggler%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2023/03/29/rosbag%E5%8C%85%E7%BB%98%E5%9B%BE%E5%B7%A5%E5%85%B7PlotJuggler%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="rosbag包绘图工具PlotJuggler使用方法"><a href="#rosbag包绘图工具PlotJuggler使用方法" class="headerlink" title="rosbag包绘图工具PlotJuggler使用方法"></a>rosbag包绘图工具PlotJuggler使用方法</h1><p>安装：<br>ubuntu版本为melodic，如果是其他版本作相应替换<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-plotjuggler<br></code></pre></td></tr></table></figure><br>ros插件安装<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-plotjuggler-msgs ros-melodic-plotjuggler-ros<br></code></pre></td></tr></table></figure><br>使用：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">roscore</span><br></code></pre></td></tr></table></figure><br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosrun plotjuggler plotjuggler</span><br></code></pre></td></tr></table></figure></p><h1 id="绘制XY曲线"><a href="#绘制XY曲线" class="headerlink" title="绘制XY曲线"></a>绘制XY曲线</h1><p>即使PlotJuggler主要关注时间序列，也可以将共享同一时间轴的两个时间序列混合在一起。一个经典的例子是机器人的XY位置，如果想知道机器人在全局坐标系下的运动轨迹，就要将xy同时描绘出来。要激活此模式，请使用鼠标右键而不是鼠标左键拖动XY数据到figure中</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包绘图工具PlotJuggler使用方法</title>
    <link href="/2023/03/29/%E5%8C%85%E7%BB%98%E5%9B%BE%E5%B7%A5%E5%85%B7PlotJuggler%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2023/03/29/%E5%8C%85%E7%BB%98%E5%9B%BE%E5%B7%A5%E5%85%B7PlotJuggler%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ROS消息或服务无法编译生成msg/srv文件产生的头文件</title>
    <link href="/2023/03/29/ROS%E6%B6%88%E6%81%AF%E6%88%96%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90msg-srv%E6%96%87%E4%BB%B6%E4%BA%A7%E7%94%9F%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <url>/2023/03/29/ROS%E6%B6%88%E6%81%AF%E6%88%96%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90msg-srv%E6%96%87%E4%BB%B6%E4%BA%A7%E7%94%9F%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS消息或服务无法编译生成msg-srv文件产生的头文件"><a href="#ROS消息或服务无法编译生成msg-srv文件产生的头文件" class="headerlink" title="ROS消息或服务无法编译生成msg/srv文件产生的头文件"></a>ROS消息或服务无法编译生成msg/srv文件产生的头文件</h1><p><strong>问题原因：</strong><br>一般情况下，如果你的msg/srv文件是一个单独的package的话(假设为A)，在依赖A生成的头文件的packageB里面编译对应的cpp文件时，在add_dependencies的最后添加${catkin_EXPORTED_TARGETS}会包含所有在find_package里面列出的包的_generate_messages_cpp宏用来生成对应的头文件，这样编译应该是没有问题的。但是当msg/srv和需要其产生头文件的cpp文件在同一个包里面时，第一次编译会报找不到头文件的错。<br><strong>解决：</strong><br>${catkin_EXPORTED_TARGETS}这个宏之前再加一个current_package_generate_messages_cpp，current_package换成当前的包名即可。<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">add_dependencies</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_node <span class="hljs-variable">$&#123;<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125;</span> <span class="hljs-variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)<br></code></pre></td></tr></table></figure><br>其中 ${PROJECT_NAME}_node 替换为自己的ros节点名<br>例如：<br><img src="/2023/03/29/ROS%E6%B6%88%E6%81%AF%E6%88%96%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90msg-srv%E6%96%87%E4%BB%B6%E4%BA%A7%E7%94%9F%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/bug.png" class="" title="CmakeLists例子"></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS中使用rqt报错Command &#39;rqt&#39; not found</title>
    <link href="/2023/03/27/ROS%E4%B8%AD%E4%BD%BF%E7%94%A8rqt%E6%8A%A5%E9%94%99Command-rqt-not-found/"/>
    <url>/2023/03/27/ROS%E4%B8%AD%E4%BD%BF%E7%94%A8rqt%E6%8A%A5%E9%94%99Command-rqt-not-found/</url>
    
    <content type="html"><![CDATA[<p>ROS在使用rqt命令时突然报错Command ‘rqt’ not found，可能是因为不小心卸载掉了rqt，重装可解决<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-kinetic-rqt  <br>sudo apt-<span class="hljs-built_in">get</span> install ros-kinetic-rqt-graph  <br>sudo apt-<span class="hljs-built_in">get</span> install ros-kinetic-rqt-common-plugins  <br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人脱困方案简述</title>
    <link href="/2023/03/22/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%84%B1%E5%9B%B0%E6%96%B9%E6%A1%88%E7%AE%80%E8%BF%B0/"/>
    <url>/2023/03/22/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%84%B1%E5%9B%B0%E6%96%B9%E6%A1%88%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="基于ROS-navigation-进行机器人脱困方案设计"><a href="#基于ROS-navigation-进行机器人脱困方案设计" class="headerlink" title="基于ROS navigation 进行机器人脱困方案设计"></a>基于ROS navigation 进行机器人脱困方案设计</h1><p>如果机器人被困在障碍物中无法移动，基于ROS navigation进行脱困的算法设计可以考虑以下步骤：<br>1、感知环境并构建地图：机器人需要使用传感器（例如激光雷达或摄像头）来感知周围环境，并利用ROS中的SLAM算法构建地图。地图可以用来定位机器人的位置以及规划路径。  </p><p>2、确定困境：机器人需要确定自己被困的情况，例如是否被墙壁、家具或其他障碍物所包围。这可以通过检查机器人周围的传感器数据来实现。  </p><p>3、规划脱困路径：机器人需要使用ROS中的路径规划算法（例如A*算法或Dijkstra算法）来规划一条脱困路径。路径应该避开障碍物，将机器人导向可行的区域。路径规划算法可以利用机器人的当前位置和目标位置，结合地图信息，计算出最优的路径。  </p><p>4、控制机器人运动：机器人需要使用ROS中的运动控制库来控制机器人的运动，将其移动到规划好的脱困路径上。控制库可以将路径信息转换为机器人的运动指令，例如速度和转向角度。  </p><p>5、监控机器人状态：机器人需要监控自身的状态，例如位置和速度，以便在需要时进行调整。<br>6、处理异常情况：如果机器人在脱困过程中出现异常情况（例如机械故障或无法行驶），则需要使用ROS中的异常处理机制，例如自适应控制和错误恢复，来处理这些情况。  </p><p>总之，基于ROS navigation进行机器人脱困算法设计需要充分考虑机器人的感知、决策和控制能力，以及可能出现的异常情况。通过合理的算法设计和运动控制，可以让机器人成功地脱离障碍物并回到安全区域。</p><p>以下是一些关于ROS Navigation中recovery_behavior的相关英文论文：<br>1.”Recovery Behaviors for Navigation Robots in Dynamic Environments,” by Jinyong Jeong, Jonghun Park, Jangmyung Lee, and Hyun Myung. This paper proposes a set of recovery behaviors for navigation robots in dynamic environments, including obstacle avoidance and path planning.</p><p>2.”Robustness of Recovery Behaviors for Mobile Robots,” by Chen Wang and Hadas Kress-Gazit. This paper presents a framework for analyzing the robustness of recovery behaviors for mobile robots in complex environments.</p><p>3.”A Hierarchical Approach to Recovery Behaviors in Mobile Robot Navigation,” by Neil Dantam, Dave Coleman, and Sachin Chitta. This paper describes a hierarchical approach to recovery behaviors in mobile robot navigation, which allows the robot to recover from various types of failures and disturbances.</p><p>4.”Recovery Behaviors for Autonomous Mobile Robots,” by Stefano Carpin, Nicola Tomatis, and Alberto Broggi. This paper presents a set of recovery behaviors for autonomous mobile robots, including obstacle avoidance, replanning, and exploration.</p><p>5.”Recovery Behaviors for Mobile Robots in Unknown Environments,” by Jaeheung Park, Minwoo Lee, and Seungbin Moon. This paper proposes a set of recovery behaviors for mobile robots in unknown environments, including localization, path planning, and obstacle avoidance.<br>这些论文都提供了有关ROS Navigation中recovery_behavior的相关研究和应用的信息。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>机器人脱困</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The matrix cookbook</title>
    <link href="/2023/03/17/The-matrix-cookbook/"/>
    <url>/2023/03/17/The-matrix-cookbook/</url>
    
    <content type="html"><![CDATA[<h1 id="The-matrix-cookbook"><a href="#The-matrix-cookbook" class="headerlink" title="The matrix cookbook"></a>The matrix cookbook</h1><div class="row">    <embed src="The-Matrix-Cookbook.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cartographer仿真建图</title>
    <link href="/2023/03/16/cartographer%E4%BB%BF%E7%9C%9F%E5%BB%BA%E5%9B%BE/"/>
    <url>/2023/03/16/cartographer%E4%BB%BF%E7%9C%9F%E5%BB%BA%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="进入cartographer安装的工作空间，激活环境"><a href="#进入cartographer安装的工作空间，激活环境" class="headerlink" title="进入cartographer安装的工作空间，激活环境"></a>进入cartographer安装的工作空间，激活环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_cartographer/<br><span class="hljs-built_in">source</span> install_isolated/setup.bash<br></code></pre></td></tr></table></figure><h1 id="创建文件cartographer-demo-rplidar-launch"><a href="#创建文件cartographer-demo-rplidar-launch" class="headerlink" title="创建文件cartographer_demo_rplidar.launch"></a>创建文件cartographer_demo_rplidar.launch</h1><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">cd ~/catkin_cartographer/src/cartographer_ros/cartographer_ros/<span class="hljs-built_in">launch</span><br>cp demo_revo_lds.<span class="hljs-built_in">launch</span> cartographer_demo_rplidar.<span class="hljs-built_in">launch</span><br>gedit cartographer_demo_rplidar.<span class="hljs-built_in">launch</span><br></code></pre></td></tr></table></figure><p>并修改为以下代码：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-symbol">&lt;launch&gt;</span>  <br>  <br>  &lt;param name=<span class="hljs-string">&quot;/use_sim_time&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span> /&gt;  <br><br>  &lt;node name=<span class="hljs-string">&quot;cartographer_node&quot;</span> pkg=<span class="hljs-string">&quot;cartographer_ros&quot;</span>  <br>        <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;cartographer_node&quot;</span> <span class="hljs-keyword">args</span>=<span class="hljs-comment">&quot;  </span><br>            -configuration_directory $(<span class="hljs-keyword">find</span> cartographer_ros)/configuration_files  <br>            -configuration_basename rplidar.<span class="hljs-keyword">lua</span><span class="hljs-comment">&quot;  </span><br>        output=<span class="hljs-string">&quot;screen&quot;</span>&gt;  <br>    &lt;remap from=<span class="hljs-string">&quot;scan&quot;</span> <span class="hljs-keyword">to</span>=<span class="hljs-string">&quot;scan&quot;</span> /&gt;  <br>  &lt;/node&gt;  <br><br>  &lt;node name=<span class="hljs-string">&quot;rviz&quot;</span> pkg=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;rviz&quot;</span> required=<span class="hljs-string">&quot;true&quot;</span>  <br>        <span class="hljs-keyword">args</span>=<span class="hljs-string">&quot;-d $(find cartographer_ros)/configuration_files/demo_2d.rviz&quot;</span> /&gt;  <br>&lt;/launch&gt;<br><br></code></pre></td></tr></table></figure></p><h1 id="创建文件rplidar-lua"><a href="#创建文件rplidar-lua" class="headerlink" title="创建文件rplidar.lua"></a>创建文件rplidar.lua</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> ~/catkin_cartographer/src/cartographer_ros/cartographer_ros/configuration_files<br><span class="hljs-keyword">cp</span> revo_lds.<span class="hljs-keyword">lua</span> rplidar.<span class="hljs-keyword">lua</span><br>gedit rplidar.<span class="hljs-keyword">lua</span><br></code></pre></td></tr></table></figure><p>修改字段如下：<br>tracking_frame = “laser_link”,<br>published_frame = “laser_link”,  </p><h1 id="配置文件修改后，需要重新编译cartographer"><a href="#配置文件修改后，需要重新编译cartographer" class="headerlink" title="配置文件修改后，需要重新编译cartographer"></a>配置文件修改后，需要重新编译cartographer</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/catkin_cartographer</span><br>catkin_make_isolated <span class="hljs-params">--install</span> <span class="hljs-params">--use-ninja</span><br></code></pre></td></tr></table></figure><h1 id="启动仿真平台"><a href="#启动仿真平台" class="headerlink" title="启动仿真平台"></a>启动仿真平台</h1><p>启动仿真平台</p><h1 id="打开新的终端，启动Cartographer"><a href="#打开新的终端，启动Cartographer" class="headerlink" title="打开新的终端，启动Cartographer"></a>打开新的终端，启动Cartographer</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_cartographer<br><span class="hljs-built_in">source</span> install_isolated/setup.bash<br>roslaunch cartographer_ros cartographer_demo_rplidar.launch<br></code></pre></td></tr></table></figure><h1 id="打开新的终端，启动键盘控制，控制机器人移动"><a href="#打开新的终端，启动键盘控制，控制机器人移动" class="headerlink" title="打开新的终端，启动键盘控制，控制机器人移动"></a>打开新的终端，启动键盘控制，控制机器人移动</h1><p>键盘控制仿真机器人移动建图</p><h1 id="打开新的终端，保存地图"><a href="#打开新的终端，保存地图" class="headerlink" title="打开新的终端，保存地图"></a>打开新的终端，保存地图</h1><p>建图完成，保存地图<br>停止地图构建<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rosservice</span> call /finish_trajectory <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><br>生成.pbstream文件，文件名及其路径可修改，以下代码是我个人目录<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">rosservice <span class="hljs-keyword">call</span> <span class="hljs-regexp">/write_state /</span>home<span class="hljs-regexp">/qiang/</span>Documents/museum.pbstream <span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><br>使用catro提供文件，将.pbstream文件转为.yaml和.pgm文件<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">cd ~/catkin_cartographer<br><span class="hljs-keyword">source</span> install_isolated/setup.bash<br>rosrun cartographer_ros cartographer_pbstream_to_ros_map -map_filestem=<span class="hljs-regexp">/home/</span>qiang<span class="hljs-regexp">/Documents/mu</span>seum -pbstream_filename=<span class="hljs-regexp">/home/</span>qiang<span class="hljs-regexp">/Documents/m</span>ap/museum.pbstream -resolution=<span class="hljs-number">0.05</span><br><br></code></pre></td></tr></table></figure><br>执行完成后，将在相应目录下生成 .yaml和.pgm文件<br><a href="https://blog.csdn.net/weixin_49195458/article/details/125067284">参考文章</a></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>cartographer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下安装Octave</title>
    <link href="/2023/03/15/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85Octave/"/>
    <url>/2023/03/15/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85Octave/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu下安装Octave"><a href="#Ubuntu下安装Octave" class="headerlink" title="Ubuntu下安装Octave"></a>Ubuntu下安装Octave</h1><p>GNU Octave是一种采用高级编程语言的主要用于数值分析的软件。Octave有助于以数值方式解决线性和非线性问题，并使用与MATLAB兼容的语言进行其他数值实验。它也可以作为面向批处理的语言使用。因为它是GNU计划的一部分，所以它是GNU通用公共许可证条款下的自由软件。</p><p>打开终端<br>第一步,添加源<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">add</span>-repository <span class="hljs-keyword">pp</span><span class="hljs-variable">a:octave</span>/stable<br></code></pre></td></tr></table></figure><br>第二步,更新源<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><br>第三步,用apt-get安装octave<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install octave<br></code></pre></td></tr></table></figure><br>第四步,运行<br>在终端中输入<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">octave</span><br></code></pre></td></tr></table></figure></p><p><a href="https://www.jianshu.com/p/08c13669cc47">原文</a></p>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>How to read a research paper</title>
    <link href="/2023/03/14/How-to-read-a-research-paper/"/>
    <url>/2023/03/14/How-to-read-a-research-paper/</url>
    
    <content type="html"><![CDATA[<h1 id="How-to-read-a-research-paper"><a href="#How-to-read-a-research-paper" class="headerlink" title="How to read a research paper"></a>How to read a research paper</h1><p>Research papers are a peculiar kind of document; for the uninitiated, it will take some getting usedto. There are two types of research papers that we may read:</p><ul><li>conference papers — shorter papers (typically 6–8 pages in robotics) generally subject to peer review, written and presented in conjunction with a conference meeting.</li><li>journal papers — longer and more complete papers, subject to a more thorough peer review, and published in an (archival) journal<br>We will be reading several journal and conference papers from the robotics literature this semester. Some of the main journals and conferences in robotics are:</li><li>IEEE Transactions on Robotics and Automation</li><li>International Journal of Robotics Research</li><li>Autonomous Robots</li><li>IEEE Conference on Robotics and Automation (ICRA)</li><li>IEEE/RSJ Conference on Robots and Systems (IROS)<br>The Rensselaer library has all these journals and conference proceedings. They are available   online through the library. The library also has hardcopy up until the past few years.<br>&emsp;To search for research papers on a topic, try the INSPEC database (available through the library<br>website under Engineering databases) or try one of the following:<br><a href="http://citeseer.ist.psu.edu/">http://citeseer.ist.psu.edu/</a><br><a href="http://scholar.google.com/">http://scholar.google.com/</a><br>Many researchers (at least in the U.S.) put their papers online on their web page. Sometimes this is a better version than what you can find through the official online sources because conference proceedings often have scanned/reduced quality figures and images. However the published version is definitive<h1 id="Questions-to-ask-while-reading-a-research-paper"><a href="#Questions-to-ask-while-reading-a-research-paper" class="headerlink" title="Questions to ask while reading a research paper"></a>Questions to ask while reading a research paper</h1>It is important that you learn to read research papers critically, so here are some questions to ask yourself as you read:</li><li>What problem(s) are they solving? Why are these problems important?</li><li>What did they really do? (as opposed to what the authors say or imply they did)</li><li>What is the contribution of the work? (i.e. what is interesting or new to the field?)</li><li>What methods are they using?</li><li>Would you have solved the problem differently?</li><li>Do all the pieces of their work fit together logically?</li><li>What were the results? Did they do what they set out to do?<h1 id="Tips-on-reading-research-papers"><a href="#Tips-on-reading-research-papers" class="headerlink" title="Tips on reading research papers"></a>Tips on reading research papers</h1></li><li>You need not read a research paper sequentially from beginning to end. Here’s one possible<br>sequence:<br>– Read the title. (What is the paper about?)<br>– Read the abstract. (Should give you a concise overview of the paper.)<br>– Read the introduction. (Look for motivations, relation to other work, and a more detailed<br>overview.)<br>– Look at the structure of the paper. (What do the remaining sections address? How do<br>they fit together?)<br>– (Read the previous/related work section. (How does this work relate? What is new or<br>different about this work?))<br>– Read the conclusions. (What were their results?)<br>– Read the body of the paper. You may want to skip over all the equations the first time<br>through  </li><li>The references won’t mean much to you if you’re not familiar with the literature. Sometimes<br>important parts of the work may be contained in the references, particularly in conference<br>papers since space is limited.<br>The references are very important when you are researching a topic — they point you to<br>related research as well as the research upon which the current paper builds upon.</li><li>Sooner or later, you will come across something that you don’t understand. What can you<br>do? You should try to figure out what it is and how it is being used (even though you still<br>don’t understand it). For further reading, see the references!</li></ul>]]></content>
    
    
    <categories>
      
      <category>academic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Building Modular ROS Packages</title>
    <link href="/2023/03/10/Building-Modular-ROS-Packages/"/>
    <url>/2023/03/10/Building-Modular-ROS-Packages/</url>
    
    <content type="html"><![CDATA[<h1 id="Building-Modular-ROS-Packages"><a href="#Building-Modular-ROS-Packages" class="headerlink" title="Building Modular ROS Packages"></a>Building Modular ROS Packages</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>&emsp;The key power of the Catkin build tool is how it makes it easier to build modular software without having to keep track of the specific build products of each package. Modularity, in this case, comes in the form of building specific functionality into libraries which can be used by other packages. This tutorial is meant for someone with minimal to moderate CMake experience and minimal experience with Catkin.</p><p>&emsp;This tutorial begins by separating the executable code from the ROS C++ Hello World Tutorial into a library and building it with CMake and Catkin. If you are unfamilar with Catkin or CMake, this tutorial will make more sense after you have worked through the Gentle Introduction to Catkin.</p><p>&emsp;The next step involves creating a second package which depends on the first package and uses the functionality defined in our library. This inter-dependency then demonstrates how to use the <font color=red>catkin_package()</font> CMake function to declare exported targets for a package.</p><h2 id="Pre-Requisites"><a href="#Pre-Requisites" class="headerlink" title="Pre-Requisites"></a>Pre-Requisites</h2><ul><li>A computer running a recent Ubuntu Linix1 LTS (long-term support) installation</li><li>Minimal experience with the Linux and the command-line interface</li><li>Minimal experience with compiling C++ code</li></ul><h2 id="Tools-Used"><a href="#Tools-Used" class="headerlink" title="Tools Used"></a>Tools Used</h2><ul><li>Ubuntu Linux</li><li>The bash shell</li><li>C++</li><li>CMake</li><li>Catkin</li><li>Any plain-text editor (I like vim).</li></ul><h2 id="ROS-Packages-Used"><a href="#ROS-Packages-Used" class="headerlink" title="ROS Packages Used"></a>ROS Packages Used</h2><ul><li>roscpp</li><li>roscpp</li><li>catkin</li></ul><h2 id="Create-a-Catkin-Package"><a href="#Create-a-Catkin-Package" class="headerlink" title="Create a Catkin Package"></a>Create a Catkin Package</h2><p>Create a new directory for your package:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> src/modular_lib_pkg<br></code></pre></td></tr></table></figure><br>Add bare-bones Catkin CMakeLists.txt and package.xml files to make your directory a valid package:<br>src/modular_lib_pkg/CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Declare the version of the CMake API for forward-compatibility</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># Declare the name of the CMake Project</span><br><span class="hljs-keyword">project</span>(modular_lib_pkg)<br><br><span class="hljs-comment"># Find Catkin</span><br><span class="hljs-keyword">find_package</span>(catkin REQUIRED)<br><span class="hljs-comment"># Declare this project as a catkin package</span><br>catkin_package()<br></code></pre></td></tr></table></figure><br>src/modular_lib_pkg/package.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">package</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Package Metadata --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>modular_lib_pkg<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maintainer</span> <span class="hljs-attr">email</span>=<span class="hljs-string">&quot;you@example.com&quot;</span>&gt;</span>Your Name<span class="hljs-tag">&lt;/<span class="hljs-name">maintainer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span><br>    A ROS tutorial on modularity.<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>BSD<span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Required by Catkin --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">buildtool_depend</span>&gt;</span>catkin<span class="hljs-tag">&lt;/<span class="hljs-name">buildtool_depend</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br></code></pre></td></tr></table></figure></p><h2 id="Separating-Functionality-into-a-Library"><a href="#Separating-Functionality-into-a-Library" class="headerlink" title="Separating Functionality into a Library"></a>Separating Functionality into a Library</h2><p>&emsp;The first step in making code available for use in other ROS packages is to encapsulate its functionality into a library.</p><p>&emsp;On most operating systems, including Linux8, there are two types of libraries: static libraries and dynamic libraries. Both of these types of libraries contain compiled binary code which can be executed directly by a computer.</p><p>&emsp;Static libraries (.a for “archive” on Linux) are linked into an executable when it is built and it becomes part of that executable. When the executable is loaded, the binary code that was copied from the static library is also loaded. Dynamic libraries (.so for “shared object” on Linux), however, are not copied into the executable, and instead are loaded at runtime.</p><p>&emsp;This means not only are dynamically-linked executables smaller, but also the libraries that they depend on chan change internally without necessitating recompilation of the executable.</p><p>&emsp;In the ROS community, dynamic libraries are most commonly used, and this is what will be built by default when using Catkin.</p><h2 id="Create-the-Library-Code"><a href="#Create-the-Library-Code" class="headerlink" title="Create the Library Code"></a>Create the Library Code</h2><p>&emsp;The first step is to create the library. Our library will encapsulate the hello-world functionality used in the ROS C++ hello-world tutorial9 so that you can call a single function called say_hello() to broadcast “Hello, world!” over the /rosout topic.</p><p>&emsp;There’s nothing fundamentally different between putting C++ code in a library as opposed to an executable. What is required, however, is to split the code definition from the declaration. This involves creating two files: a header file and a source file.</p><p>&emsp;The header file should contain only what is needed by the compiler of anyone who uses the library. As such, it only needs to contain function and class delcarations, and does not need to contain function definitions.</p><p>&emsp;The header with the declaration of our say_hello() function is as follows:<br>modular_lib_pkg/include/modular_lib_pkg/hello_world.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Inclusion guard to prevent this header from being included multiple times</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MODULAR_LIB_PKG_HELLO_WORLD_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MODULAR_LIB_PKG_HELLO_WORLD_H</span><br><br><span class="hljs-comment">//! Broadcast a hello-world message over ROS_INFO</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say_hello</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><br>Next is the source or implementation file. This file should contain what is needed by the linker to connect function calls to binary code. As such, it needs to contain all of the definitions of the functions declared in the corresponding header.<br>&emsp;The source file with the definition of say_hello() is as follows:<br>modular_lib_pkg/src/hello_world.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Include the ROS C++ APIs</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say_hello</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">ROS_INFO_STREAM</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>Now that we’ve written the code for the library, we can add a rule to the CMakeLists.txt file to actually build it. Note that just like in the ROS C++ hello-world tutorial9, we need to add a dependency on roscpp in order to use ROS. This is just like adding an executable with the add_executable() CMake command: instead, we use add_library():<br>src/modular_lib_pkg/CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Declare the version of the CMake API for forward-compatibility</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># Declare the name of the CMake Project</span><br><span class="hljs-keyword">project</span>(modular_lib_pkg)<br><br><span class="hljs-comment"># Find and get all the information about the roscpp package</span><br><span class="hljs-keyword">find_package</span>(roscpp REQUIRED)<br><br><span class="hljs-comment"># Find Catkin</span><br><span class="hljs-keyword">find_package</span>(catkin REQUIRED)<br><span class="hljs-comment"># Declare this project as a catkin package</span><br>catkin_package()<br><br><span class="hljs-comment"># Add the headers from roscpp</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;roscpp_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-comment"># Define a library target called hello_world</span><br><span class="hljs-keyword">add_library</span>(hello_world src/hello_world.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><br>&emsp;Also, now that we’re using the roscpp package, we need to list it as a build- and run-dependency of our package:<br>src/modular_lib_pkg/package.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">package</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Package Metadata --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>modular_lib_pkg<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maintainer</span> <span class="hljs-attr">email</span>=<span class="hljs-string">&quot;you@example.com&quot;</span>&gt;</span>Your Name<span class="hljs-tag">&lt;/<span class="hljs-name">maintainer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span><br>    A ROS tutorial on modularity.<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>BSD<span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Required by Catkin --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">buildtool_depend</span>&gt;</span>catkin<span class="hljs-tag">&lt;/<span class="hljs-name">buildtool_depend</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Package Dependencies --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>roscpp<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">run_depend</span>&gt;</span>roscpp<span class="hljs-tag">&lt;/<span class="hljs-name">run_depend</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br></code></pre></td></tr></table></figure><br>&emsp;At this point you should be able to compile the library by running catkin_make from the root of your workspace and see the following output:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Scanning <span class="hljs-keyword">dependencies</span> of target hello_world<br>[<span class="hljs-number">100</span>%] Building CXX object modular_lib_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world.dir<span class="hljs-regexp">/src/</span>hello_world.cpp.o<br>Linking CXX shared library <span class="hljs-regexp">/tmp/</span>devel<span class="hljs-regexp">/lib/</span>libhello_world.so<br>[<span class="hljs-number">100</span>%] Built target hello_world<br></code></pre></td></tr></table></figure><br>&emsp;<strong>Notice</strong> that it built the hello_world target into a file called libhello_world.so. This is the standard naming convention for dynamic libraries on Linux. Also, it built the library into the lib subdirectory of the develspace, so when you source one of the setup files in the devel directory, it will make this library available for dynamic linking at runtime.</p><h2 id="Create-the-Node"><a href="#Create-the-Node" class="headerlink" title="Create the Node"></a>Create the Node</h2><p>&emsp;Now that we have our hello_world library, we can write a simple program to call the say_hello() function in that library. This program is nearly identical to the one used in the ROS C++ hello-world Tutorial9, except we replace the call to ROS_INFO with a call to say_hello() and we include the header file in the previous section.<br>modular_lib_pkg/src/hello_world_node.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Include the ROS C++ APIs</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><br><span class="hljs-comment">// Include the declaration of our library function</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;modular_lib_pkg/hello_world.h&gt;</span></span><br><br><span class="hljs-comment">// Standard C++ entry point</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>  <span class="hljs-comment">// Initialize ROS</span><br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;hello_world_node&quot;</span>);<br>  ros::NodeHandle nh;<br><br>  <span class="hljs-comment">// Call our library function</span><br>  <span class="hljs-built_in">say_hello</span>();<br><br>  <span class="hljs-comment">// Wait for SIGINT/Ctrl-C</span><br>  ros::<span class="hljs-built_in">spin</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>To build this node, just add an appropriate add_executable() call to the bottom of the package’s CMakeLists.txt:<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">add<span class="hljs-constructor">_executable(<span class="hljs-params">hello_world_node</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">hello_world_node</span>.<span class="hljs-params">cpp</span>)</span><br>target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">hello_world_node</span> $&#123;<span class="hljs-params">roscpp_LIBRARIES</span>&#125;)</span><br></code></pre></td></tr></table></figure></p><h2 id="Building-the-Node-and-getting-a-compiler-error"><a href="#Building-the-Node-and-getting-a-compiler-error" class="headerlink" title="Building the Node (and getting a compiler error)"></a>Building the Node (and getting a compiler error)</h2><p>&emsp;At this point, you can try to build hello_world_node with catkin_make, but you will see the following error:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[<span class="hljs-number">100</span>%] Building CXX object modular_lib_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world_node.dir<span class="hljs-regexp">/src/</span>hello_world_node.cpp.o<br><span class="hljs-regexp">/tmp/</span>src<span class="hljs-regexp">/modular_lib_pkg/</span>src<span class="hljs-regexp">/hello_world_node.cpp:5:42: fatal error: modular_lib_pkg/</span>hello_world.h: No such <span class="hljs-keyword">file</span> or directory<br>compilation terminated.<br></code></pre></td></tr></table></figure><br>&emsp;The compiler is complaining about modular_lib_pkg/hello_world.h not existing, but we know it exists! The problem isn’t that the file doesn’t exist, but rather that we haven’t told the compiler where to look for it.</p><p>&emsp;In the same way that we added the header search paths for roscpp, we also need to add our own local include directory where we put our own headers. To do so, just add the relative path to src/modular_lib_pkg/include to the existing include_directories() command in CMakeLists.txt:<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">include</span><span class="hljs-constructor">_directories(<span class="hljs-params">include</span> $&#123;<span class="hljs-params">roscpp_INCLUDE_DIRS</span>&#125;)</span><br></code></pre></td></tr></table></figure></p><h2 id="Building-the-Node-and-getting-a-linker-error"><a href="#Building-the-Node-and-getting-a-linker-error" class="headerlink" title="Building the Node (and getting a linker error)"></a>Building the Node (and getting a linker error)</h2><p>At this point, you can try to build hello_world_node with catkin_make again, but you will see another error:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">[<span class="hljs-number">100</span>%] Building CXX object modular_lib_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world_node.dir<span class="hljs-regexp">/src/</span>hello_world_node.cpp.o<br>Linking CXX executable <span class="hljs-regexp">/tmp/</span>foo<span class="hljs-regexp">/devel/</span>lib<span class="hljs-regexp">/modular_lib_pkg/</span>hello_world_node<br>CMakeFiles<span class="hljs-regexp">/hello_world_node.dir/</span>src/hello_world_node.cpp.o:hello_world_node.cpp:<span class="hljs-keyword">function</span> main: error: undefined reference to <span class="hljs-string">&#x27;say_hello()&#x27;</span><br>collect2: ld returned <span class="hljs-number">1</span> <span class="hljs-keyword">exit</span> status<br></code></pre></td></tr></table></figure><br>&emsp;This time, hello_world_node.cpp is compiled successfully, but the linker reports an error that the say_hello() function is undefined. The declaration was found in the hello_world.h header file, otherwise it wouldn’t have compiled, still the definition from hello_world.cpp was missing.</p><p>&emsp;In order to resolve this, in addition to linking against ${roscpp_LIBRARIES}, we also link hello_world_node against the hello_world target so that its symbols are defined for the linker. This is done by adding hello_world to the existing target_link_libraries() command like the following:<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">hello_world_node</span> $&#123;<span class="hljs-params">roscpp_LIBRARIES</span>&#125; <span class="hljs-params">hello_world</span>)</span><br></code></pre></td></tr></table></figure><br>The following CMakeLists.txt file contains both this and the previous modifications:<br>src/modular_lib_pkg/CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Declare the version of the CMake API for forward-compatibility</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># Declare the name of the CMake Project</span><br><span class="hljs-keyword">project</span>(modular_lib_pkg)<br><br><span class="hljs-comment"># Find and get all the information about the roscpp package</span><br><span class="hljs-keyword">find_package</span>(roscpp REQUIRED)<br><br><span class="hljs-comment"># Find Catkin</span><br><span class="hljs-keyword">find_package</span>(catkin REQUIRED)<br><span class="hljs-comment"># Declare this project as a catkin package</span><br>catkin_package()<br><br><span class="hljs-comment"># Add the local headers and the headers from roscpp</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-keyword">include</span> <span class="hljs-variable">$&#123;roscpp_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-comment"># Define a library target called hello_world</span><br><span class="hljs-keyword">add_library</span>(hello_world src/hello_world.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span>)<br><br><span class="hljs-comment"># Define an executable target called hello_world_node</span><br><span class="hljs-keyword">add_executable</span>(hello_world_node src/hello_world_node.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world_node <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span> hello_world)<br></code></pre></td></tr></table></figure></p><h2 id="Building-the-Node-and-succeeding"><a href="#Building-the-Node-and-succeeding" class="headerlink" title="Building the Node (and succeeding)"></a>Building the Node (and succeeding)</h2><p>Now you should be able to compile hello_world_node succesfully and then (assuming you sourced one of your workspace’s setup files) you can run it with rosrun:<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosrun modular_lib_pkg hello_world_node</span><br></code></pre></td></tr></table></figure><br>This node does the same thing as before, except now, the core functionality is implemented in a separate library, which could more easily be used by other packages.</p><h1 id="Using-Libraries-from-Other-Packages"><a href="#Using-Libraries-from-Other-Packages" class="headerlink" title="Using Libraries from Other Packages"></a>Using Libraries from Other Packages</h1><p>Now that we’ve created a single package with its functionality built into a library, we can create another package which also uses that functionality. In this case, we’ll create another hello_world_node in another package which also links against libhello_world.so from modular_lib_pkg.</p><h2 id="Create-the-Second-Package-and-Node"><a href="#Create-the-Second-Package-and-Node" class="headerlink" title="Create the Second Package and Node"></a>Create the Second Package and Node</h2><p>First, create a package for the new node called modular_node_pkg:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> src/modular_node_pkg<br></code></pre></td></tr></table></figure><br>Next, add the source code for our node. This code is exactly the same as the hello_world_node.cpp in the modular_lib_pkg:<br>modular_node_pkg/hello_world_node.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Include the ROS C++ APIs</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><br><span class="hljs-comment">// Include the declaration of our library function</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;modular_lib_pkg/hello_world.h&gt;</span></span><br><br><span class="hljs-comment">// Standard C++ entry point</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>  <span class="hljs-comment">// Initialize ROS</span><br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;hello_world_node&quot;</span>);<br>  ros::NodeHandle nh;<br><br>  <span class="hljs-comment">// Call our library function</span><br>  <span class="hljs-built_in">say_hello</span>();<br><br>  <span class="hljs-comment">// Wait for SIGINT/Ctrl-C</span><br>  ros::<span class="hljs-built_in">spin</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>Then add the following CMakeLists.txt and package.xml files to the new package. Note that now that we’re using the modular_lib_pkg just like we’re using the roscpp package, we need to find its headers and libraries just like we do with roscpp:<br>src/modular_node_pkg/CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Declare the version of the CMake API for forward-compatibility</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># Declare the name of the CMake Project</span><br><span class="hljs-keyword">project</span>(modular_node_pkg)<br><br><span class="hljs-comment"># Find and get all the information about the roscpp package</span><br><span class="hljs-keyword">find_package</span>(roscpp REQUIRED)<br><br><span class="hljs-comment"># Find and get all the information about the modular_lib_pkg package</span><br><span class="hljs-keyword">find_package</span>(modular_lib_pkg REQUIRED)<br><br><span class="hljs-comment"># Find Catkin</span><br><span class="hljs-keyword">find_package</span>(catkin REQUIRED)<br><span class="hljs-comment"># Declare this project as a catkin package</span><br>catkin_package()<br><br><span class="hljs-comment"># Add the headers from roscpp</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;roscpp_INCLUDE_DIRS&#125;</span> <span class="hljs-variable">$&#123;modular_lib_pkg_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-comment"># Define an executable  target called hello_world_node</span><br><span class="hljs-keyword">add_executable</span>(hello_world_node2 hello_world_node.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world_node2 <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span> <span class="hljs-variable">$&#123;modular_lib_pkg_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><br><strong>NOTE:</strong> Goofy or not, the way that Catkin works, it combines all of your packages into a single CMake project. This means that each package must have unique target names. Otherwise the world will implode and unhappiness will descend upon the land. If you don’t want to have this constraint, you can use catkin_make_isolated which will build each package in isolation, but will be slower.<br>src/modular_lib_pkg/package.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">package</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Package Metadata --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>modular_node_pkg<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maintainer</span> <span class="hljs-attr">email</span>=<span class="hljs-string">&quot;you@example.com&quot;</span>&gt;</span>Your Name<span class="hljs-tag">&lt;/<span class="hljs-name">maintainer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span><br>    A ROS tutorial on modularity.<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>BSD<span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Required by Catkin --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">buildtool_depend</span>&gt;</span>catkin<span class="hljs-tag">&lt;/<span class="hljs-name">buildtool_depend</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Package Dependencies --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>roscpp<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>modular_lib_pkg<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">run_depend</span>&gt;</span>roscpp<span class="hljs-tag">&lt;/<span class="hljs-name">run_depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">run_depend</span>&gt;</span>modular_lib_pkg<span class="hljs-tag">&lt;/<span class="hljs-name">run_depend</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br></code></pre></td></tr></table></figure><br>After creating these files, your workspace should look like the following:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── build<br>│   └── ...<br>├── devel<br>│   └── ...<br>└── <span class="hljs-attribute">src</span><br>    ├── CMakeLists<span class="hljs-selector-class">.txt</span> -&gt; /opt/ros/hydro/share/catkin/cmake/toplevel<span class="hljs-selector-class">.cmake</span><br>    ├── modular_lib_pkg<br>    │   ├── CMakeLists<span class="hljs-selector-class">.txt</span><br>    │   ├── include<br>    │   │   └── modular_lib_pkg<br>    │   │       └── hello_world<span class="hljs-selector-class">.h</span><br>    │   ├── package<span class="hljs-selector-class">.xml</span><br>    │   └── <span class="hljs-attribute">src</span><br>    │       ├── hello_world<span class="hljs-selector-class">.cpp</span><br>    │       └── hello_world_node<span class="hljs-selector-class">.cpp</span><br>    └── modular_node_pkg<br>        ├── CMakeLists<span class="hljs-selector-class">.txt</span><br>        ├── hello_world_node<span class="hljs-selector-class">.cpp</span><br>        └── package.xml<br></code></pre></td></tr></table></figure></p><h2 id="Building-the-Node-and-getting-a-compiler-error-again"><a href="#Building-the-Node-and-getting-a-compiler-error-again" class="headerlink" title="Building the Node (and getting a compiler error again)"></a>Building the Node (and getting a compiler error again)</h2><p>If you try to build yor workspace by running catkin_make at this point, you will get the same compiler error as before, but this time with the new node!<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[<span class="hljs-number">100</span>%] Building CXX object modular_node_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world_node2.dir/hello_world_node.cpp.o<br><span class="hljs-regexp">/tmp/</span>foo<span class="hljs-regexp">/src/m</span>odular_node_pkg<span class="hljs-regexp">/hello_world_node.cpp:5:41: fatal error: modular_lib_pkg/</span>hello_world.h: No such <span class="hljs-keyword">file</span> or directory<br>compilation terminated.<br></code></pre></td></tr></table></figure><br>Despite the fact that you included ${modular_lib_pkg_INCLUDE_DIRS} in the include_directories() CMake function, it still couldn’t find the header. This is because this sort of information needs to be exported by the other package.</p><p>With the current workspace, not only will ${modular_lib_pkg_INCLUDE_DIRS} be empty, but also ${modular_lib_pkg_LIBRARIES} will also be empty.</p><h2 id="Exporting-Package-Flags-to-Other-Packages"><a href="#Exporting-Package-Flags-to-Other-Packages" class="headerlink" title="Exporting Package Flags to Other Packages"></a>Exporting Package Flags to Other Packages</h2><p>In the previous secion, our second package, modular_node_pkg, was unable to get the compilation or linker flags from the first package, modular_lib_pkg. This is because the flags weren’t exported by modular_lib_pkg. With Catkin, exporting such information is done with the catkin_package() command in the CMakeLists.txt file, and in the case of modular_lib_pkg, we didn’t pass it any arguments:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">catkin_package</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><br>This function can be left empty if we don’t need to export anything, but if we do, there are several optional arguments10 and the following are most commonly used:</p><ul><li>INCLUDE_DIRS One or more header directories that should be made available to other packages. These directories are relative to the path of the given CMakeLists.txt file.</li><li>LIBRARIES One or more libraries that should be made available to other packages. These are the target names of the libraries.</li><li>CATKIN_DEPENDS One or more names of Catkin packages whose build flags should be passed transitively to any package which depends on this one. This will cause dependent packages to automatically call find_package() on each of these names.</li><li>DEPENDS One or more names of packages whose build flags should be passed transitively to any package which depends on this one. If a name like foo is given here, then Catkin will add whatever the contents of the ${foo_INCLUDE_DIRS} and ${foo_LIBRARIES} variables will be exported as part of this package’s include directories and libraries, respectively.<br>In our case, we want to export both a local include directory and a library, so we modify the catkin_package() call in the modular_lib_pkg CMakeLists.txt to export the flags for our include directory and library.</li></ul><p>Additionally, we should declare that anyone depending on this package should also use build flags from the roscpp package. This is important either if we link our library against libraries from the roscpp package or if any of our exported header files #include headers from roscpp.<br><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">catkin_package</span>(</span><br><span class="hljs-function">  <span class="hljs-variable">INCLUDE_DIRS</span> <span class="hljs-variable">include</span></span><br><span class="hljs-function">  <span class="hljs-variable">LIBRARIES</span> <span class="hljs-variable">hello_world</span></span><br><span class="hljs-function">  <span class="hljs-variable">CATKIN_DEPENDS</span> <span class="hljs-variable">roscpp</span></span><br><span class="hljs-function">  )</span><br></code></pre></td></tr></table></figure><br><strong>NOTE:</strong> In this specific case, leaving out the CATKIN_DEPENDS on roscpp won’t cause any problems, but this is only because it is unlikely that someone would try to build a ROS C++ node without depending on roscpp directly. A motivating example will be shown in the next section.<br>The complete CMakeLists.txt for modular_lib_pkg is as follows:<br>src/modular_lib_pkg/CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Declare the version of the CMake API for forward-compatibility</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># Declare the name of the CMake Project</span><br><span class="hljs-keyword">project</span>(modular_lib_pkg)<br><br><span class="hljs-comment"># Find and get all the information about the roscpp package</span><br><span class="hljs-keyword">find_package</span>(roscpp REQUIRED)<br><br><span class="hljs-comment"># Find Catkin</span><br><span class="hljs-keyword">find_package</span>(catkin REQUIRED)<br><span class="hljs-comment"># Declare this project as a catkin package and export the necessary build flags</span><br>catkin_package(<br>  INCLUDE_DIRS <span class="hljs-keyword">include</span><br>  LIBRARIES hello_world<br>  CATKIN_DEPENDS roscpp<br>  )<br><br><span class="hljs-comment"># Add the local headers and the headers from roscpp</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-keyword">include</span> <span class="hljs-variable">$&#123;roscpp_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-comment"># Define a library target called hello_world</span><br><span class="hljs-keyword">add_library</span>(hello_world src/hello_world.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span>)<br><br><span class="hljs-comment"># Define an executable target called hello_world_node</span><br><span class="hljs-keyword">add_executable</span>(hello_world_node src/hello_world_node.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world_node <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span> hello_world)<br></code></pre></td></tr></table></figure><br>You can now build the workspace again with catkin_make, but this time it should succeed:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">[ <span class="hljs-number">33</span>%] Building CXX object modular_lib_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world.dir<span class="hljs-regexp">/src/</span>hello_world.cpp.o<br>Linking CXX shared library <span class="hljs-regexp">/tmp/</span>devel<span class="hljs-regexp">/lib/</span>libhello_world.so<br>[ <span class="hljs-number">33</span>%] Built target hello_world<br>[ <span class="hljs-number">66</span>%] Building CXX object modular_lib_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world_node.dir<span class="hljs-regexp">/src/</span>hello_world_node.cpp.o<br>Linking CXX executable <span class="hljs-regexp">/tmp/</span>devel<span class="hljs-regexp">/lib/m</span>odular_lib_pkg/hello_world_node<br>[ <span class="hljs-number">66</span>%] Built target hello_world_node<br>[<span class="hljs-number">100</span>%] Building CXX object modular_node_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world_node2.dir/hello_world_node.cpp.o<br>Linking CXX executable <span class="hljs-regexp">/tmp/</span>devel<span class="hljs-regexp">/lib/m</span>odular_node_pkg/hello_world_node2<br>[<span class="hljs-number">100</span>%] Built target hello_world_node2<br></code></pre></td></tr></table></figure><br>And finally, (assuming you still have your workspace environment set up), you can run hello_world_node2:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rosrun</span> modular_node_pkg hello_world_node2<br></code></pre></td></tr></table></figure><br>Reference:<br><a href="https://jbohren.com/articles/modular-ros-packages">original article</a></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Why does my robot navigate too close to walls and/or cuts corners?</title>
    <link href="/2023/03/08/Why-does-my-robot-navigate-too-close-to-walls-and-or-cuts-corners/"/>
    <url>/2023/03/08/Why-does-my-robot-navigate-too-close-to-walls-and-or-cuts-corners/</url>
    
    <content type="html"><![CDATA[<h1 id="Question-Why-does-my-robot-navigate-too-close-to-walls-and-or-cuts-corners"><a href="#Question-Why-does-my-robot-navigate-too-close-to-walls-and-or-cuts-corners" class="headerlink" title="Question: Why does my robot navigate too close to walls and/or cuts corners?"></a>Question: Why does my robot navigate too close to walls and/or cuts corners?</h1><p><strong>Short Answer:</strong> Define/Increase the inflation radius in your costmap configuration.<br><strong>Long Answer:</strong> At first glance, parameter min_obstacle_dist could be increased, but this could lead to an undesired navigation behavior in small hallways or doors (see Gaps in the trajectory). The local planner “follows” a moving virtual goal on the global plan. Therefore locations of intermediate global plan position of the global plan significantly influence the spatial behavior of the local plan. By defining an inflation radius the global planner prefers plans with minimum cost and hence plans with a higher separation from walls. Note, the teb_local_planner itself does not take the inflation radius into account. The resulting motion is time-optimal w.r.t. the virtual goal. If you wish to stick much more to following the global path, refer to Global path following. If your robot hits walls, you should really increase min_obstacle_dist or setup an appropriate footprint (refer to this tutorial).</p>]]></content>
    
    
    <categories>
      
      <category>ROS QA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS-melodic在catkin build时报错catkin: command not found</title>
    <link href="/2023/03/04/ROS-melodic%E5%9C%A8catkin-build%E6%97%B6%E6%8A%A5%E9%94%99catkin-command-not-found/"/>
    <url>/2023/03/04/ROS-melodic%E5%9C%A8catkin-build%E6%97%B6%E6%8A%A5%E9%94%99catkin-command-not-found/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS-melodic在catkin-build时报错catkin-command-not-found"><a href="#ROS-melodic在catkin-build时报错catkin-command-not-found" class="headerlink" title="ROS-melodic在catkin build时报错catkin: command not found"></a>ROS-melodic在catkin build时报错catkin: command not found</h1><p>解决方法<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-catkin python-catkin-tools<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决ubuntu在apt-get install时出错Could not get lock /var/lib/dpkg/lock-frontend</title>
    <link href="/2023/03/03/%E8%A7%A3%E5%86%B3ubuntu%E5%9C%A8apt-get-install%E6%97%B6%E5%87%BA%E9%94%99Could-not-get-lock-var-lib-dpkg-lock-frontend/"/>
    <url>/2023/03/03/%E8%A7%A3%E5%86%B3ubuntu%E5%9C%A8apt-get-install%E6%97%B6%E5%87%BA%E9%94%99Could-not-get-lock-var-lib-dpkg-lock-frontend/</url>
    
    <content type="html"><![CDATA[<p>sudo apt-get install 时会报错<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">E: Could <span class="hljs-keyword">not</span> <span class="hljs-keyword">get</span> <span class="hljs-keyword">lock</span> /var/lib/dpkg/<span class="hljs-keyword">lock</span>-frontend - <span class="hljs-keyword">open</span> (<span class="hljs-number">11</span>: Resource temporarily unavailable)<br>E: Unable <span class="hljs-keyword">to</span> acquire the dpkg frontend <span class="hljs-keyword">lock</span> (/var/lib/dpkg/<span class="hljs-keyword">lock</span>-frontend), <span class="hljs-keyword">is</span> another process <span class="hljs-keyword">using</span> it?<br></code></pre></td></tr></table></figure><br>解决方法:依次执行如下命令<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/lock<br></code></pre></td></tr></table></figure><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm <span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/apt/</span>archives/lock<br></code></pre></td></tr></table></figure><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/dpkg/</span>lock*<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gazebo打不开一直卡在Preparing your world</title>
    <link href="/2023/03/03/gazebo%E6%89%93%E4%B8%8D%E5%BC%80%E4%B8%80%E7%9B%B4%E5%8D%A1%E5%9C%A8Preparing-your-world/"/>
    <url>/2023/03/03/gazebo%E6%89%93%E4%B8%8D%E5%BC%80%E4%B8%80%E7%9B%B4%E5%8D%A1%E5%9C%A8Preparing-your-world/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在运行某些程序的功能包的时候，gazebo启动的时候会一直卡在”Preparing your world”，然后就一直不动了，这是由于gazebo在下载某些模型导致的，多等上一会，或者执行下面的命令手动把模型下全，如果还是不能打开那说明要下载的模型不在这个列表里面，知道这个模型是什么可以去手动下载，如果不知道的话就只有多等一会看能不能下完打开了。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd ~<span class="hljs-regexp">/.gazebo/</span><br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/osrf/g</span>azebo_models.git models<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>gazebo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>world</title>
    <link href="/2023/03/03/world/"/>
    <url>/2023/03/03/world/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ROS-melodic升级gazebo11</title>
    <link href="/2023/03/03/ROS-melodic%E5%8D%87%E7%BA%A7gazebo11/"/>
    <url>/2023/03/03/ROS-melodic%E5%8D%87%E7%BA%A7gazebo11/</url>
    
    <content type="html"><![CDATA[<h1 id="卸载Gazebo9"><a href="#卸载Gazebo9" class="headerlink" title="卸载Gazebo9"></a>卸载Gazebo9</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> ros-melodic-gazebo*<br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> libgazebo*<br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> gazebo*<br></code></pre></td></tr></table></figure><h1 id="安装Gazebo11"><a href="#安装Gazebo11" class="headerlink" title="安装Gazebo11"></a>安装Gazebo11</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">sudo sh -c &#x27;echo <span class="hljs-string">&quot;deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main&quot;</span> &gt; /etc/apt/sources.list.d/gazebo-stable.list&#x27;<br></code></pre></td></tr></table></figure><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">wget https://packages.osrfoundation.org/gazebo.<span class="hljs-keyword">key</span> -O - | sudo apt-<span class="hljs-keyword">key</span> <span class="hljs-keyword">add</span> -<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> update<br>sudo apt-<span class="hljs-built_in">get</span> install gazebo11<br>sudo apt-<span class="hljs-built_in">get</span> install libgazebo11-dev<br>sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-gazebo11-ros-pkgs<br></code></pre></td></tr></table></figure><h1 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h1><p>终端输入<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gazebo</span><br></code></pre></td></tr></table></figure></p><h1 id="如果出现如下错误解决方法"><a href="#如果出现如下错误解决方法" class="headerlink" title="如果出现如下错误解决方法"></a>如果出现如下错误解决方法</h1><p>出错：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">VMware: vmw_ioctl_command <span class="hljs-built_in">error</span> Invalid argument<br></code></pre></td></tr></table></figure><br>解决方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export SVGA_VGPU10=0&quot;</span> &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_44732054/article/details/123430259?spm=1001.2014.3001.5501">ROS-Melodic升级Gazebo11</a><br><a href="https://blog.csdn.net/qq_40660130/article/details/124342844">VMware: vmw_ioctl_command error Invalid argument解决办法</a></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>gazebo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv形态学处理morphologyEx</title>
    <link href="/2023/02/22/opencv%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86morphologyEx/"/>
    <url>/2023/02/22/opencv%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86morphologyEx/</url>
    
    <content type="html"><![CDATA[<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> morph_elem = <span class="hljs-number">0</span>;<br>cv::Mat element = cv::get<span class="hljs-constructor">StructuringElement( <span class="hljs-params">morph_elem</span>, <span class="hljs-params">cv</span>::Size( 3, 3 )</span>, cv::<span class="hljs-constructor">Point( -1, -1 )</span> );<br>cv::Mat dst;<br>cv::morphology<span class="hljs-constructor">Ex( <span class="hljs-params">src</span>, <span class="hljs-params">dst</span>, 3, <span class="hljs-params">element</span> )</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>opencv</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++中fillPoly函数使用</title>
    <link href="/2023/02/22/c-%E4%B8%ADfillPoly%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/02/22/c-%E4%B8%ADfillPoly%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>fillPoly函数需要二维嵌套<code>std::vector&lt;std::vector&lt;cv::Point&gt;&gt;ppts;</code>否则无法正常使用。若使用<code>std::vector&lt;cv::Point&gt; pts</code>会导致程序中断，但不会在编译器中报错。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">cv</span>::Mat <span class="hljs-built_in">image</span> = <span class="hljs-built_in">cv</span>::Mat::ones(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>, CV_8UC3)<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">cv</span>::Point&gt; pts;<br>pts.push_back(<span class="hljs-built_in">cv</span>::Point(x, y));<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">cv</span>::Point&gt;&gt; ppts;<br>ppts.push_back(pts);<br><span class="hljs-built_in">cv</span>::fillPoly(<span class="hljs-built_in">image</span> , ppts, (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>));<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>opencv</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刚体位姿</title>
    <link href="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/"/>
    <url>/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>&emsp;刚体在三维笛卡尔空间的运动包括平移和旋转，平移用三个笛卡尔坐标，旋转用三个角坐标，因此，刚体运动需要六个坐标。机器人运动学研究的就是在空间中不断地去控制机器人的位置和方向，为了确定机器人的位置和方向，需要建立一个固定的参考坐标系，称为固定坐标系或世界坐标系。另外，在移动的机器人上需建立一个移动坐标系或局部坐标系来描述机器人的位姿。<br>&emsp;按照参考坐标系来看，刚体的位置和方向有六个独立的参数，如下图所示<br><img src="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/spatial_description.png" class="" title="图1.坐标系示意图"><br>定义$X-Y-Z$坐标系为固定坐标系，机器人在运动过程中建立的运动坐标系为$U-V-W$，很明显，如果确定了运动坐标系相对于固定坐标系的位姿，那么刚体的位姿也就知道了。刚体位姿可以通过刚体上任意一点的位姿来确定，例如原点$O$或刚体上任一点$P$。</p><h1 id="位置描述"><a href="#位置描述" class="headerlink" title="位置描述"></a>位置描述</h1><p>&emsp;运动中的刚体上任何一点$P$相对于固定坐标系的位置可以用一个三维笛卡尔向量<strong><em>P</em></strong>，如上图所示，定义点$P$在固定坐标系$F$中的坐标或向量<strong><em>P</em></strong>在固定坐标系$F$的分量为$p_x,p_y,p_z$为</p><script type="math/tex; mode=display">\left[ \mathbf{P}\right]_F=\left[                    \begin{matrix}                    p_x\\                    p_y \\                    p_z                    \end{matrix}                    \right]                    \tag{1}</script><p>这里的下表$F$表示向量<strong><em>P</em></strong>参考的固定坐标系。<br>&emsp;下表$x,y,z$分别表示向量<strong><em>P</em></strong>沿固定坐标系$X,Y,Z$三个方向的分量。<br>&emsp;向量<strong><em>P</em></strong>可以表达为：</p><script type="math/tex; mode=display">\mathbf{P}=p_x\mathbf{x}+p_y\mathbf{y}+p_z\mathbf{z} \tag{2}</script><p>这里$\mathbf{x},\mathbf{y},\mathbf{z}$分别表示沿固定坐标系$F$的$X,Y,Z$方向的单位向量，如上图所示。在固定坐标系$F$下分别写为：</p><script type="math/tex; mode=display">\left[ \mathbf{x} \right]_F\equiv\left[ \begin{matrix}1\\0\\0\end{matrix}\right],\left[ \mathbf{y} \right]_F\equiv\left[ \begin{matrix}0\\1\\0\end{matrix}\right],and \left[ \mathbf{z} \right]_F\equiv\left[ \begin{matrix}0\\0\\1\end{matrix}\right]\tag{3}</script><p><strong>注意</strong>：如果向量<strong><em>P</em></strong>参考的固定坐标系是不同于坐标系$F$的，那么，向量<strong><em>P</em></strong>的分量将会不同于参考固定坐标系$F$的分量，尽管向量<strong><em>P</em></strong>没变，因此，无论参考坐标系如何改变，向量<strong><em>P</em></strong>是不会变的，这就是所谓的坐标无关的表达方式，也可以说是与参考系是独立的。  </p><h1 id="方向描述"><a href="#方向描述" class="headerlink" title="方向描述"></a>方向描述</h1><p>&emsp;根据参考坐标系，刚体的方向可以有不同的描述方式，例如：<br>1.Direction cosine representation<br>2.Fixed-axes rotations<br>3.Euler-angles representation<br>4.Single- and double-axes rotations<br>5.Euler parameters, and others<br><strong>注意</strong>：每种描述方式都有其局限，下面具体介绍</p><h2 id="1-Direction-Cosine-Representation"><a href="#1-Direction-Cosine-Representation" class="headerlink" title="1.Direction Cosine Representation"></a>1.Direction Cosine Representation</h2><p>&emsp;为了描述刚体的方向或旋转，考虑相对于固定坐标系$F$运动的移动坐标系$M$，如图1所示。另$\mathbf{u}、\mathbf{v}、\mathbf{w}$分别表示沿运动坐标系$M$方向$U、V、W$的单位向量，由于每个单位向量$\mathbf{u}、\mathbf{v}、\mathbf{w}$表示点在坐标系$M$下距原点单位距离处的位置，因此，可以用它们各自沿固定坐标系$X、Y、Z$方向的分量来表达：</p><script type="math/tex; mode=display">\mathbf{u}=u_x\mathbf{x}+u_y\mathbf{y}+u_z\mathbf{z}\tag{4}</script><script type="math/tex; mode=display">\mathbf{v}=v_x\mathbf{x}+v_y\mathbf{y}+v_z\mathbf{z}\tag{5}</script><script type="math/tex; mode=display">\mathbf{w}=w_x\mathbf{x}+w_y\mathbf{y}+w_z\mathbf{z}\tag{6}</script><p>这里$u_x、u_y、u_z$分别表示单位向量$\mathbf{u}$沿$X、Y、Z$方向的分量，相似的，$v_x、v_y、v_z$和$w_x、w_y、w_z$分别表示单位向量$\mathbf{v}$和$\mathbf{w}$的分量。现在，如图1所示刚体上的一点$P$在运动坐标系下的表达为：</p><script type="math/tex; mode=display">\mathbf{P}=p_u\mathbf{u}+p_v\mathbf{v}+p_w\mathbf{w}\tag{7}</script><p>这里$p_u,p_v,p_w$分别是向量<strong><em>P</em></strong>沿运动坐标系$M$的坐标轴$U、V、W$的分量，把公式（4）-（6）带入公式（7）得到：</p><script type="math/tex; mode=display">\mathbf{P}=(p_uu_x+p_vv_x+p_ww_x)\mathbf{x}+(p_uu_y+p_vv_y+p_ww_y)\mathbf{y}+(p_uu_z+p_vv_z+p_ww_z)\mathbf{z}\tag{8}</script><p>对比公式（7）和（8）得到：</p><script type="math/tex; mode=display">p_x = p_uu_x+p_vv_x+p_ww_x\tag{9}</script><script type="math/tex; mode=display">p_y = p_uu_y+p_vv_y+p_ww_y\tag{10}</script><script type="math/tex; mode=display">p_z = p_uu_z+p_vv_z+p_ww_z\tag{11}</script><p>写成矩阵形式：</p><script type="math/tex; mode=display">\left[ \mathbf{p}\right]_F=\mathbf{Q}\left[ \mathbf{p}\right]_M\tag{12}</script><p>这里$\left[ \mathbf{p}\right]_F$和$\left[ \mathbf{p}\right]_M$分别表示三维向量<strong><em>P</em></strong>在坐标系$F$和$M$的分量，$\mathbf{Q}$是一个$3\times3$的旋转矩阵表示向量<strong><em>P</em></strong>从坐标系$M$到坐标系$F$的转换。它们的具体形式为：</p><script type="math/tex; mode=display">\left[ \mathbf{p} \right]_F\equiv\left[ \begin{matrix}p_x\\p_y\\p_z\end{matrix}\right],\left[ \mathbf{p} \right]_M\equiv\left[ \begin{matrix}p_u\\p_v\\p_w\end{matrix}\right],and \left[ \mathbf{Q} \right]\equiv\left[ \begin{matrix}u_x&v_x& w_x\\u_y&v_y& w_y\\u_z&v_z& w_z\end{matrix}\right]=\left[ \begin{matrix}\mathbf{u}^T\mathbf{x}&\mathbf{v}^T\mathbf{x}& \mathbf{w}^T\mathbf{x}\\\mathbf{u}^T\mathbf{y}&\mathbf{v}^T\mathbf{y}& \mathbf{w}^T\mathbf{y}\\\mathbf{u}^T\mathbf{z}&\mathbf{v}^T\mathbf{z}& \mathbf{w}^T\mathbf{z}\end{matrix}\right]\tag{13}</script><p>注意矩阵$\mathbf{Q}$的每一列都是正交的，它们是单位向量$\mathbf{u},\mathbf{v},\mathbf{w}$在坐标系$F$下的分量，而且必须满足如下的六个正交条件：</p><script type="math/tex; mode=display">\mathbf{u}^T\mathbf{u}=\mathbf{v}^T\mathbf{v}=\mathbf{w}^T\mathbf{w}=1,and\mathbf{u}^T\mathbf{v}(\equiv\mathbf{v}^T\mathbf{u})=\mathbf{u}^T\mathbf{w}(\equiv\mathbf{w}^T\mathbf{u})=\mathbf{v}^T\mathbf{w}(\equiv\mathbf{w}^T\mathbf{v})=0\tag{14}</script><p>并且，对于正交向量$\mathbf{u},\mathbf{v},\mathbf{w}$满足如下关系：</p><script type="math/tex; mode=display">\mathbf{u}\times\mathbf{v}=\mathbf{w},\mathbf{v}\times\mathbf{w}=\mathbf{u},and \mathbf{w}\times\mathbf{u}=\mathbf{v}\tag{15}</script><p>因此，$3\times3$的旋转矩阵$\mathbf{Q}$，给出了运动坐标系$M$相对于固定坐标系$F$的方位，就是所谓的正交矩阵。它有如下特性：</p><script type="math/tex; mode=display">\mathbf{Q}^T\mathbf{Q}=\mathbf{Q}\mathbf{Q}^T=1\tag{16}</script><p>这里，$det(\mathbf{Q})=1,and\ \mathbf{Q}^{-1}=\mathbf{Q}^T$，这里$\mathbf{1}$是一个$3\times3$的单位矩阵。如果需要求出坐标系$F$相对于坐标系$M$的旋转矩阵$\mathbf{Q}^\prime$，可以得到$\mathbf{Q}^\prime=\mathbf{Q}^T$，另外，我们从公式(13)中$\mathbf{Q}$矩阵的第一个元素$\mathbf{Q}_{1,1}$能够发现它是向量$\mathbf{u}$和$\mathbf{x}$的夹角余弦值，即$\mathbf{u}^T\mathbf{x}$。同样的结论对于其他各元素也成立。因此，这个旋转矩阵$\mathbf{Q}$就是直接余弦表示的旋转矩阵。这种表示法需要$3\times3$矩阵的9个参数，但是，9各参数并不是独立的，需要满足公式（14）的6个条件，因此，只有3个参数是独立的，这足以定义3个旋转自由度了。然后，这3个参数的选择是困难的，这也是直接余弦表达法的缺点。</p><h2 id="2-Fixed-axes-rotations"><a href="#2-Fixed-axes-rotations" class="headerlink" title="2.Fixed-axes rotations"></a>2.Fixed-axes rotations</h2><p>&emsp;Roll, Pitch and Yaw:围绕固定的X、Y和Z轴旋转也称为滚动、俯仰和偏航角度。这个命名法是常用于航空工程。绕着固定的惯性坐标系$F$旋转来表达运动坐标系$M$的方向，使用3个角度来表达旋转这种方式比较简单，在概念上类似于沿固定坐标系$F$的3个平移变换。坐标系$M$相对于坐标系$F$的方向由固定坐标系的3个基本旋转获得，如下图2所示。<br><img src="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/rpy.png" class="" title="图2绕固定坐标系旋转"></p><h3 id="绕XYZ轴的旋转组合"><a href="#绕XYZ轴的旋转组合" class="headerlink" title="绕XYZ轴的旋转组合"></a>绕XYZ轴的旋转组合</h3><p>&emsp;对于绕固定X、Y和Z轴的旋转，可以通过一系列基本旋转从固定坐标系F到达坐标系M，如图2所示。另$\psi,\theta\ and \ \phi$分别为绕$X-,Y-\ and \ Z-$轴的转角，总的旋转可以表达为基本旋转的组合：</p><ul><li>绕固定坐标系$F$的$X$轴旋转的角度为$\psi$，如图2(a)所示，这个旋转用旋转矩阵$\mathbf{Q}_X$表示：<script type="math/tex; mode=display">\mathbf{Q}_X\equiv\left[ \begin{matrix}1&0&0\\0&C\psi&-S\psi\\0&S\psi&C\psi\end{matrix}\right]\tag{17}</script></li><li>从当前坐标系$A$绕坐标轴$Y$旋转一个角度$\theta$，如图2(b)所示，这个旋转矩阵用$\mathbf{Q}_Y$表示：<script type="math/tex; mode=display">\mathbf{Q}_Y\equiv\left[ \begin{matrix}C\theta&0&S\theta\\0&1&0\\-S\theta&0&C\theta\end{matrix}\right]\tag{18}</script></li><li>从当前坐标系$B$绕$Z$轴旋转一个角度$\phi$，如图2(c)所示，这个旋转矩阵用$\mathbf{Q}_Z$表示：<script type="math/tex; mode=display">\mathbf{Q}_Z\equiv\left[ \begin{matrix}C\phi&-S\phi&0\\S\phi&C\phi&0\\0&0&1\end{matrix}\right]\tag{19}</script>&emsp;坐标系$F$的方向由矩阵$\mathbf{Q}$表示，方向矩阵$\mathbf{Q}$由基本旋转矩阵相乘得到：<script type="math/tex; mode=display">\mathbf{Q}=\mathbf{Q}_Z\mathbf{Q}_Y\mathbf{Q}_X\tag{20}</script>详细结果如下所示：<script type="math/tex; mode=display">\mathbf{Q}=\left[ \begin{matrix}C\theta C\phi&S\theta S\psi C\phi-C\psi S\phi&S\theta C\psi C\phi+S\psi S\phi\\ C\theta S\phi&S\theta S\psi S\phi+C\psi C\phi&S\theta C\psi S\phi-S\psi C\phi\\-S\theta&C\theta S\psi&C\theta C\psi\end{matrix}\right]\tag{21}</script>由于基本旋转不满足交换律，因此它们顺序的任何变化都会导致整体旋转矩阵$\mathbf{Q}$的不同，因此我们可以总结出12中组合，如表1所示。<img src="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/table.png" class="" title="表1"><!-- |SN|**Fixed-axes**<br>[$\psi \theta \phi$]|**Euler angles**<br>[$\phi \theta \psi$]|Rotation Matrix, Q|| :---: | :---: | :---:|:---:||Nonsymmetric sets||1|XYZ<br>[$\mathbf{Q}_Z \mathbf{Q}_Y \mathbf{Q}_X$]|ZYX<br>$\mathbf{Q}_Z\mathbf{Q}_{Y^\prime}\mathbf{Q}_{X^{\prime \prime}}$|$\left[ \begin{matrix}C\theta C\phi&S\theta S\psi C\phi-C\psi S\phi&S\theta C\psi C\phi+S\psi S\phi\\ C\theta S\phi&S\theta S\psi S\phi+C\psi C\phi& S\theta C\psi S\phi -S\psi C\phi\\ -S\theta&C\theta S\psi & C\theta C\psi \end{matrix}\right]$||2|YZX<br>[$\mathbf{Q}_X \mathbf{Q}_Z \mathbf{Q}_Y$]|XZY<br>[$\mathbf{Q}_X \mathbf{Q}_{Z^{\prime}} \mathbf{Q}_{Y^{\prime \prime}}$]|$\left[ \begin{matrix}C\theta C\psi&-S\theta&C\theta S\psi\\ C\psi S\theta C\phi+S\psi S\phi&C\theta C\phi&S\theta S\psi C\phi-C\psi S\phi\\ C\psi S\theta S\phi-S\psi C\phi&C\theta S\phi&S\theta S\psi S\phi+C\psi C\phi\end{matrix}\right]$||3|ZXY<br>[$\mathbf{Q}_Y \mathbf{Q}_X \mathbf{Q}_Z$]|YXZ<br>[$\mathbf{Q}_Y \mathbf{Q}_{X^{\prime}} \mathbf{Q}_{Z^{\prime \prime}}$]|$\left[ \begin{matrix}S\psi S\theta S\phi+C\psi C\phi&C\psi S\theta S\phi-S\psi C\phi&C\theta S\phi\\ C\theta S\psi&C\theta C\psi&-S\theta\\ S\psi S\theta C\phi-C\psi S\phi&C\psi S\theta C\phi+S\psi S\phi&C\theta C\phi\end{matrix}\right]$||4|ZYX<br>$[\mathbf{Q}_X \mathbf{Q}_Y \mathbf{Q}_Z]$|XYZ<br>$[\mathbf{Q}_X \mathbf{Q}_{Y^\prime} \mathbf{Q}_{Z^{\prime \prime}}]$|$\left[ \begin{matrix}C\theta C\psi&-C\theta S\psi&S\theta\\ C\psi S\theta S\phi+S\psi C\phi&-S\theta S\psi S\phi+C\psi C\phi&-C\theta S\phi\\ -S\theta C\psi C\phi+S\psi S\phi&S\psi S\theta C\phi+C\psi S\phi&C\theta C\phi\end{matrix}\right]$||5|XZY<br>$[\mathbf{Q}_Y \mathbf{Q}_Z \mathbf{Q}_X]$|YZX<br>$[\mathbf{Q}_Y \mathbf{Q}_{Z^\prime} \mathbf{Q}_{X^{\prime \prime}}]$|$\left[ \begin{matrix}C\theta C\phi&-C\psi S\theta C\phi+S\psi S\phi&S\theta S\psi C\phi+C\psi S\phi\\ S\theta&C\theta C\psi&-C\theta S\psi\\ -C\theta S\phi&C\psi S\theta S\phi+S\psi C\phi&-S\theta S\psi S\phi+C\psi C\phi\end{matrix}\right]$||6|YXZ<br>$[\mathbf{Q}_Z \mathbf{Q}_X \mathbf{Q}_Y]$|ZXY<br>$[\mathbf{Q}_Z \mathbf{Q}_{X^\prime} \mathbf{Q}_{Y^{\prime \prime}}]$|$\left[ \begin{matrix}-S\phi S\psi S\theta+C\phi C\psi&-C\theta S\phi&S\theta C\psi S\phi+S\psi C\phi\\ C\phi S\psi S\theta +S\phi C\psi&C\theta C\phi&-C\phi C\psi S\theta+S\phi S\psi\\ -C\theta S\psi&S\theta & C\psi C\theta\end{matrix}\right]$||Symmetric sets||7|XYX<br>$[\mathbf{Q}_X \mathbf{Q}_Y \mathbf{Q}_X]$|XYX<br>$[\mathbf{Q}_X \mathbf{Q}_{Y^\prime} \mathbf{Q}_{X^{\prime \prime}}]$|$\left[ \begin{matrix}C\theta&S\theta S\psi&S\theta C\psi\\ S\theta S\phi&-C\theta S\psi S\phi+C\psi C\phi&-C\theta C\psi S\phi-S\psi C\phi\\ -S\theta C\phi&C\theta S\psi C\phi+C\psi S\phi& C\theta C\psi C\phi-S\psi S\phi\\\end{matrix}\right]$||8|XZX<br>$[\mathbf{Q}_X \mathbf{Q}_Z \mathbf{Q}_X]$|XZX<br>$[\mathbf{Q}_X \mathbf{Q}_{Z^\prime} \mathbf{Q}_{X^{\prime \prime}}]$|$\left[ \begin{matrix} C\theta&-S\theta C\psi&S\theta S\psi\\ S\theta C\phi&C\theta C\psi C\phi-S\psi S\phi&-C\theta S\psi C\phi-C\psi S\phi\\ S\theta S\phi&C\theta C\psi S\phi +S\psi C\phi&-C\theta S\psi S\phi+C\psi C\phi\end{matrix}\right]$||9|YZY<br>$[\mathbf{Q}_Y \mathbf{Q}_Z \mathbf{Q}_Y]$|YZY<br>$[\mathbf{Q}_Y \mathbf{Q}_{Z^\prime} \mathbf{Q}_{Y^{\prime \prime}}]$|$\left[ \begin{matrix}C\theta C\psi C\phi-S\psi S\phi&-S\theta C\phi&C\theta S\psi C\phi-S\psi S\phi\\ S\theta C\psi&C\theta &S\theta S\psi\\ -C\theta C\psi S\phi-S\psi C\phi&S\theta S\phi&-C\theta S\psi S\phi+C\psi C\phi\end{matrix}\right]$||10|YXY<br>$[\mathbf{Q}_Y \mathbf{Q}_X \mathbf{Q}_Y]$|YXY<br>$[\mathbf{Q}_Y \mathbf{Q}_{X^\prime} \mathbf{Q}_{Y^{\prime \prime}}]$|$\left[ \begin{matrix} -C\theta S\psi S\phi+C\psi C\phi&S\theta S\phi&C\theta C\psi S\phi+S\psi C\phi\\ S\theta S\psi&C\theta&-S\theta C\psi\\ -C\theta S\psi C\phi-C\psi S\phi&S\theta C\phi& C\theta C\psi C\phi-S\psi S\phi\end{matrix}\right]$||11|ZXZ<br>$[\mathbf{Q}_Z \mathbf{Q}_X \mathbf{Q}_Z]$|ZXZ<br>$[\mathbf{Q}_Z \mathbf{Q}_{X^\prime} \mathbf{Q}_{Z^{\prime \prime}}]$|$\left[ \begin{matrix}-C\theta S\psi S\phi+C\psi C\phi& -C\theta C\psi S\phi-S\psi C\phi& S\theta S\phi\\ C\theta S\phi S\psi+C\psi S\phi&C\theta C\psi C\phi -S\psi S\phi&-S\theta C\phi\\ S\theta S\psi & S\theta C\psi& C\theta \end{matrix}\right]$||12|ZYZ<br>$[\mathbf{Q}_Z \mathbf{Q}_Y \mathbf{Q}_Z]$|ZYZ<br>$[\mathbf{Q}_Z \mathbf{Q}_{Y^\prime} \mathbf{Q}_{Z^{\prime \prime}}]$|$\left[ \begin{matrix}C\phi C\theta C\psi-S\phi S\psi& -C\phi C\theta S\psi-S\phi C\psi& S\theta C\phi\\ S\phi C\theta C\psi+C\phi S\psi& -S\phi C\theta S\psi+C\phi S\psi&S\theta S\phi\\ -S\theta C\psi&S\theta S\psi& C\theta\end{matrix}\right]$| --></li></ul><h2 id="3-Euler-angles-representation"><a href="#3-Euler-angles-representation" class="headerlink" title="3.Euler-angles representation"></a>3.Euler-angles representation</h2><p>&emsp;欧拉角的表示法通过组合绕当前坐标系轴旋转的基本旋转来获得，不像固定轴旋转，这里的旋转是针对当前坐标。如图3所示。如果坐标系$F$先绕$X$轴旋转，再绕$Y^\prime$，最后绕$X^{\prime \prime}$轴旋转，最后的旋转矩阵$\mathbf{Q}$可以通过组合三个绕当前坐标系的基本旋转获得，分别是$\mathbf{Q}_X,\mathbf{Q}_{Y^\prime}$和$\mathbf{Q}_{Z^{\prime \prime}}$，得到：</p><script type="math/tex; mode=display">\mathbf{Q} = \mathbf{Q}_X \mathbf{Q}_{Y^\prime} \mathbf{Q}_{Z^{\prime \prime}}\tag{22}</script><img src="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/euler-angles.png" class="" title="图3"><h3 id="ZYZ欧拉角组合"><a href="#ZYZ欧拉角组合" class="headerlink" title="ZYZ欧拉角组合"></a>ZYZ欧拉角组合</h3><p>&emsp;尽管已经有12个欧拉角组合存在，但是$ZYZ$组合也是最常用的表示法之一，如图4所示。<img src="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/zyz-euler.png" class="" title="图4">  </p><ul><li>绕固定坐标系$F$的坐标轴$Z$旋转角度$\phi$，如图4（a）所示，这个旋转用旋转矩阵$\mathbf{Q}_Z$表示：<script type="math/tex; mode=display">\mathbf{Q}_Z \equiv \left[ \begin{matrix} C\phi&-S\phi&0\\S\phi&C\phi&0\\ 0&0&1\end{matrix}\right] \tag{23}</script></li><li>绕当前坐标系$A$的$Y^\prime$轴旋转角度$\theta$，用旋转矩阵$\mathbf{Q}_{Y^\prime}$表示，如图4（b）所示：<script type="math/tex; mode=display">\mathbf{Q}_{Y^\prime} \equiv \left[ \begin{matrix} C\theta&0&S\theta\\ 0&1&0\\ -S\theta&0&C\theta\end{matrix}\right] \tag{24}</script></li><li>绕当前坐标系$B$的$Z^{\prime \prime}$轴旋转角度$\psi$，如图4（c）所示，用矩阵$\mathbf{Q}_{Z^{\prime \prime}}$表示：<script type="math/tex; mode=display">\mathbf{Q}_{Z^{\prime \prime}} \equiv \left[ \begin{matrix}C\psi&-S\psi&0\\ S\psi&C\psi&0\\0&0&1 \end{matrix}\right] \tag{25}</script>&emsp;最后坐标系$M$的方向矩阵$\mathbf{Q}$可以通过组合三个基本的旋转矩阵$\mathbf{Q}_Z,\mathbf{Q}_{Y^\prime} \ and\ \mathbf{Q}_{Z^{\prime \prime}}$获得：<script type="math/tex; mode=display">\mathbf{Q}=\mathbf{Q}_Z \mathbf{Q}_{Y^\prime} \mathbf{Q}_{Z^{\prime \prime}} \tag{26}</script>\mathbf{Q}矩阵的每个元素计算方式如下：<script type="math/tex; mode=display">\mathbf{Q}\equiv \left[ \begin{matrix}C\phi C\theta C\psi-S\phi S\psi&-C\phi C\theta S\psi-S\phi C\psi&S\theta C\phi\\ S\phi C\theta C\psi+C\phi S\psi&-S\phi C\theta S\psi+C\phi C\psi&S\theta S\phi\\ -S\theta C\psi&S\theta S\psi&C\theta \end{matrix}\right] \tag{27}</script><h2 id="4-Single-and-double-axes-rotations"><a href="#4-Single-and-double-axes-rotations" class="headerlink" title="4.Single- and double-axes rotations"></a>4.Single- and double-axes rotations</h2></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器人运动控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2023/02/19/test/"/>
    <url>/2023/02/19/test/</url>
    
    <content type="html"><![CDATA[<h1 id="测试文章"><a href="#测试文章" class="headerlink" title="测试文章"></a>测试文章</h1><p>这是一篇测试公式是否渲染的文章  </p><script type="math/tex; mode=display">\frac{V}{r}=\omega</script>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>差速底盘机器人运动分析</title>
    <link href="/2023/02/19/%E5%B7%AE%E9%80%9F%E5%BA%95%E7%9B%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%88%86%E6%9E%90/"/>
    <url>/2023/02/19/%E5%B7%AE%E9%80%9F%E5%BA%95%E7%9B%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="差速底盘机器人运动分析"><a href="#差速底盘机器人运动分析" class="headerlink" title="差速底盘机器人运动分析"></a>差速底盘机器人运动分析</h1><p>1.差速驱动是许多移动轮式机器人的运动控制方式<br>2.差速驱动机器人通常有两个动力轮，机器人每侧各一个，有时还有其他从动轮以防止机器人倾翻。<br>3.当两个轮子以相同的速度向相同的方向转动时，机器人沿直线运动。<br>4.当一个轮子转得比另一个轮子快时，机器人沿弧线运动。<br>5.当轮子朝以相同大小的速度向相反的方向转动时，机器人就原地转动。<br>6.我们可以正式描述机器人的行为如下：<br>&emsp;(a) 当机器人沿曲线运动时，存在一个瞬时曲率中心（ICC）。<br>&emsp;(b) 如果$r$表示曲线的半径（ICC到机器人中心的距离），$l$表示机器人的轮距，那么角速度和ICC的关系可以按如下方式推导：</p><script type="math/tex; mode=display">\omega(r+\frac{l}{2})=v_r</script><script type="math/tex; mode=display">\omega(r-\frac{l}{2})=v_l</script><p>为什么？因为角速度的定义为线速度除以曲线半径：  </p><script type="math/tex; mode=display">\frac{d\theta}{dt}=\frac{V}{r}</script><p>上式比较直观的物理的意义是：轮子离中心越远需要移动得越快才能获得与另一个轮子相同的角速度。<br>通过上式我们得到：  </p><script type="math/tex; mode=display">v_r=\omega(r+\frac{l}{2})\\=\omega r+\omega \frac{l}{2}</script><script type="math/tex; mode=display">v_l=\omega(r-\frac{l}{2})\\=\omega r-\frac{l}{2}</script><p>以上两式相减得到：</p><script type="math/tex; mode=display">v_r-v_l=\frac{2\omega l}{2}</script><script type="math/tex; mode=display">\omega = \frac{v_r-v_l}{l}</script><p>相加得到：</p><script type="math/tex; mode=display">2\omega r=v_r+v_l</script><script type="math/tex; mode=display">r=\frac{l(v_r+v_l)}{2(v_r-v_l)}</script><p>综上所述，我们发现：<br>i.角速度是车轮速度在它们分开的距离内的差异。<br>ii.如果$v_r=v_l$，那么$\omega$为0，机器人沿直线行走。<br>iii.如果$v_r=-v_l$，那么$r$为0，机器人原地旋转。</p><h2 id="机器人位姿"><a href="#机器人位姿" class="headerlink" title="机器人位姿"></a>机器人位姿</h2><p>假设机器人在运行时的位置为x,y ，并且朝向某一角度$\theta$，$\theta$是机器人坐标系$x$轴与世界坐标系$x$轴的夹角。定义$\theta=0$时机器人$x$轴与世界坐标系$x$轴一致。当机器人移动时，机器人的局部坐标系也一同移动，另$x,y,\theta$为机器人的位姿(pose)。<br><img src="/2023/02/19/%E5%B7%AE%E9%80%9F%E5%BA%95%E7%9B%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%88%86%E6%9E%90/pose.png" class="" title="机器人坐标系"></p><h2 id="前向运动学"><a href="#前向运动学" class="headerlink" title="前向运动学"></a>前向运动学</h2><p>给定一个初始位姿，机器人以角速度$\omega$在$\delta t$时间内运动，确定机器人的新位姿。<br><img src="/2023/02/19/%E5%B7%AE%E9%80%9F%E5%BA%95%E7%9B%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%88%86%E6%9E%90/new_pose.png" class="" title="确定机器人新位姿"><br>(a) 首先，注意所有变量都是时间的函数：$x(t)，y(t)，\omega(t)，V(t)，\theta(t)$。<br>(b) 然后，我们来计算ICC位于何处，得到$r$</p><h1 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h1>]]></content>
    
    
    <categories>
      
      <category>机器人运动控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线速度与角速度之间的关系</title>
    <link href="/2023/02/18/%E7%BA%BF%E9%80%9F%E5%BA%A6%E4%B8%8E%E8%A7%92%E9%80%9F%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2023/02/18/%E7%BA%BF%E9%80%9F%E5%BA%A6%E4%B8%8E%E8%A7%92%E9%80%9F%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="高中物理知识：线速度与角速度之间的关系"><a href="#高中物理知识：线速度与角速度之间的关系" class="headerlink" title="高中物理知识：线速度与角速度之间的关系"></a>高中物理知识：线速度与角速度之间的关系</h1><h2 id="1-线速度"><a href="#1-线速度" class="headerlink" title="1.线速度"></a>1.线速度</h2><img src="/2023/02/18/%E7%BA%BF%E9%80%9F%E5%BA%A6%E4%B8%8E%E8%A7%92%E9%80%9F%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/velocity.png" class="" title="线速度">  <p>物理意义：描述质点圆周运动快慢的物理量。<br>定义：质点做圆周运动通过的弧长$\Delta S$和所用时间$\Delta t$的比值叫做线速度的大小。<br>公式：$v=\frac{\Delta S}{\Delta t}$<br>单位：$m/s$<br>方向：质点在圆周某点的线速度方向沿圆周上该点的切线方向。</p><h2 id="2-角速度"><a href="#2-角速度" class="headerlink" title="2.角速度"></a>2.角速度</h2><img src="/2023/02/18/%E7%BA%BF%E9%80%9F%E5%BA%A6%E4%B8%8E%E8%A7%92%E9%80%9F%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/angular.png" class="" title="角速度">  <p>物理意义：描述质点绕圆心转动快慢的物理量。<br>定义：质点所在半径转过的角度$\Delta \theta$和所用时间$\Delta t$的比值叫做角速度。<br>公式：$\omega = \frac{\Delta \theta}{\Delta t}$<br>单位：弧度/秒 $rad/s$</p><h2 id="3-关系证明"><a href="#3-关系证明" class="headerlink" title="3.关系证明"></a>3.关系证明</h2><img src="/2023/02/18/%E7%BA%BF%E9%80%9F%E5%BA%A6%E4%B8%8E%E8%A7%92%E9%80%9F%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/prove.png" class="" title="证明">  <p>在$\Delta t$内通过的弧长为$\Delta S$，半径转过的角度为$\Delta \theta$<br>由$\Delta S=r\Delta \theta$<br>得到$v=\frac{\Delta S}{\Delta t}=\frac{r\Delta \theta}{\Delta t}=\omega r$<br>写成微分形式$\frac{d\theta}{dt}=\frac{v}{r}$</p>]]></content>
    
    
    <categories>
      
      <category>机器人运动控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux使用find统计代码行数</title>
    <link href="/2023/02/17/Linux%E4%BD%BF%E7%94%A8find%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/"/>
    <url>/2023/02/17/Linux%E4%BD%BF%E7%94%A8find%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>Linux一行代码统计项目代码行数<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> . -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*.cpp&quot;</span> -<span class="hljs-built_in">or</span> -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*.cc&quot;</span> -<span class="hljs-built_in">or</span> -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*.h&quot;</span> -<span class="hljs-built_in">or</span> -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*.hpp&quot;</span> |xargs cat|wc -l<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu18.04中ROS版本为melodic环境安装cartographer</title>
    <link href="/2023/02/17/ubuntu18-04%E4%B8%ADROS%E7%89%88%E6%9C%AC%E4%B8%BAmelodic%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85cartographer/"/>
    <url>/2023/02/17/ubuntu18-04%E4%B8%ADROS%E7%89%88%E6%9C%AC%E4%B8%BAmelodic%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85cartographer/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1.安装环境"></a>1.安装环境</h1><p>本文是在ubuntu18.04下重新安装了melodic，然后成功安装并运行了cartographer</p><h1 id="2-依赖安装"><a href="#2-依赖安装" class="headerlink" title="2.依赖安装"></a>2.依赖安装</h1><p>按照cartographer的官网提供的<a href="https://google-cartographer.readthedocs.io/en/latest/">依赖安装</a><br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment"># Install the required libraries that are available as debs.</span><br>sudo apt-get update<br>sudo apt-get install -y <span class="hljs-string">\</span><br>    clang <span class="hljs-string">\</span><br>    cmake <span class="hljs-string">\</span><br>    g++ <span class="hljs-string">\</span><br>    git <span class="hljs-string">\</span><br>    google-mock <span class="hljs-string">\</span><br>    libboost-all-dev <span class="hljs-string">\</span><br>    libcairo2-dev <span class="hljs-string">\</span><br>    libcurl4-openssl-dev <span class="hljs-string">\</span><br>    libeigen3-dev <span class="hljs-string">\</span><br>    libgflags-dev <span class="hljs-string">\</span><br>    libgoogle-glog-dev <span class="hljs-string">\</span><br>    liblua5.<span class="hljs-number">2</span>-dev <span class="hljs-string">\</span><br>    libsuitesparse-dev <span class="hljs-string">\</span><br>    lsb-release <span class="hljs-string">\</span><br>    ninja-build <span class="hljs-string">\</span><br>    stow<br></code></pre></td></tr></table></figure><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Install Ceres Solver and Protocol Buffers support if available.</span><br><span class="hljs-comment"># No need to build it ourselves.</span><br><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$(lsb_release -sc)</span>&quot;</span> = <span class="hljs-string">&quot;focal&quot;</span> || <span class="hljs-string">&quot;<span class="hljs-variable">$(lsb_release -sc)</span>&quot;</span> = <span class="hljs-string">&quot;buster&quot;</span> ]]<br>then<br>  sudo apt-<span class="hljs-built_in">get</span> install -y python3-sphinx libgmock-dev libceres-dev protobuf-compiler<br><span class="hljs-keyword">else</span><br>  sudo apt-<span class="hljs-built_in">get</span> install -y python-sphinx<br>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$(lsb_release -sc)</span>&quot;</span> = <span class="hljs-string">&quot;bionic&quot;</span> ]]<br>  then<br>    sudo apt-<span class="hljs-built_in">get</span> install -y libceres-dev<br>  fi<br>fi<br></code></pre></td></tr></table></figure></p><h1 id="3-安装abseil-cpp"><a href="#3-安装abseil-cpp" class="headerlink" title="3.安装abseil-cpp"></a>3.安装abseil-cpp</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/abseil/</span>abseil-cpp.git<br>cd abseil-cpp<br>git checkout d902eb869bcfacc1bad14933ed9af4bed006d481<br>mkdir build<br>cd build<br>cmake -G Ninja \<br>  -DCMAKE_BUILD_TYPE=Release \<br>  -DCMAKE_POSITION_INDEPENDENT_CODE=ON \<br>  -DCMAKE_INSTALL_PREFIX=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/stow/</span>absl \<br>  ..<br>ninja<br>sudo ninja install<br>cd <span class="hljs-regexp">/usr/</span>local/stow<br>sudo stow absl<br></code></pre></td></tr></table></figure><h1 id="4-安装ceres-solver"><a href="#4-安装ceres-solver" class="headerlink" title="4.安装ceres-solver"></a>4.安装ceres-solver</h1><p>在ceres-solver<a href="https://ceres-solver.googlesource.com/ceres-solver">官网</a>下载1.13.0版本<br><img src="/2023/02/17/ubuntu18-04%E4%B8%ADROS%E7%89%88%E6%9C%AC%E4%B8%BAmelodic%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85cartographer/ceres_solver_download.png" class="" title="ceres-solver下载地址"><br>解压ceres-solver，然后执行以下命令<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> ceres-solver<br><span class="hljs-keyword">mkdir</span> build<br><span class="hljs-keyword">cd</span> build<br>cmake .. -<span class="hljs-keyword">G</span> Ninja -DCXX11=<span class="hljs-keyword">ON</span><br>ninja<br>CTEST_OUTPUT_ON_FAILURE=1 ninja <span class="hljs-keyword">test</span><br>sudo ninja install<br></code></pre></td></tr></table></figure><br>这里之所以和官网安装方式不一样是因为，作者在执行git clone <a href="https://ceres-solver.googlesource.com/ceres-solver">https://ceres-solver.googlesource.com/ceres-solver</a> 这个安装命令时一直不成功，可能是网络原因</p><h1 id="5-安装protobuf"><a href="#5-安装protobuf" class="headerlink" title="5.安装protobuf"></a>5.安装protobuf</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">VERSION=<span class="hljs-string">&quot;v3.4.1&quot;</span><br><span class="hljs-comment"># Build and install proto3.</span><br>git <span class="hljs-built_in">clone</span> https://github.com/google/protobuf.git<br><span class="hljs-built_in">cd</span> protobuf<br>git checkout tags/<span class="hljs-variable">$&#123;VERSION&#125;</span><br><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br>cmake -G Ninja \<br>  -DCMAKE_POSITION_INDEPENDENT_CODE=ON \<br>  -DCMAKE_BUILD_TYPE=Release \<br>  -Dprotobuf_BUILD_TESTS=OFF \<br>  ../cmake<br>ninja<br>sudo ninja install<br></code></pre></td></tr></table></figure><h1 id="6-安装cartographer"><a href="#6-安装cartographer" class="headerlink" title="6.安装cartographer"></a>6.安装cartographer</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim">ROS_DISTRO=<span class="hljs-string">&quot;melodic&quot;</span><br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span><br>sudo apt-<span class="hljs-built_in">get</span> install -<span class="hljs-keyword">y</span> <span class="hljs-keyword">python</span>-wstool <span class="hljs-keyword">python</span>-rosdep ninja-build stow<br><span class="hljs-built_in">mkdir</span> catkin_google_ws<br><span class="hljs-keyword">cd</span> catkin_google_ws<br>wstool init src<br>wstool merge -t src https://ghproxy.<span class="hljs-keyword">com</span>/https://raw.githubusercontent.<span class="hljs-keyword">com</span>/cartographer-project/cartographer_ros/master/cartographer_ros.rosinstall<br>wstool <span class="hljs-keyword">update</span> -t src<br>src/cartographer/scripts/install_abseil.<span class="hljs-keyword">sh</span><br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> ros-$&#123;ROS_DISTRO&#125;-abseil-cpp<br>catkin_make_isolated --install --use-ninja<br></code></pre></td></tr></table></figure><h1 id="7-测试demo"><a href="#7-测试demo" class="headerlink" title="7.测试demo"></a>7.测试demo</h1><p>下载官方数据<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">wget -P ~<span class="hljs-regexp">/Downloads https:/</span><span class="hljs-regexp">/storage.googleapis.com/</span>cartographer-<span class="hljs-keyword">public</span>-data<span class="hljs-regexp">/bags/</span>backpack_2d/cartographer_paper_deutsches_museum.bag<br></code></pre></td></tr></table></figure></p><h1 id="8-运行"><a href="#8-运行" class="headerlink" title="8.运行"></a>8.运行</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_google_ws<br><span class="hljs-built_in">source</span> install_isolated/setup.sh<br>roslaunch cartographer_ros demo_backpack_2d.launch bag_filename:=<span class="hljs-variable">$&#123;HOME&#125;</span>/Downloads/cartographer_paper_deutsches_museum.bag<br></code></pre></td></tr></table></figure><h1 id="9-结果"><a href="#9-结果" class="headerlink" title="9.结果"></a>9.结果</h1><img src="/2023/02/17/ubuntu18-04%E4%B8%ADROS%E7%89%88%E6%9C%AC%E4%B8%BAmelodic%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85cartographer/museum.png" class="" title="运行结果"><h1 id="10-Cartographer-ROS-Documentation"><a href="#10-Cartographer-ROS-Documentation" class="headerlink" title="10.Cartographer ROS Documentation"></a>10.Cartographer ROS Documentation</h1><div class="row">    <embed src="google-cartographer-ros.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>cartographer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rosdepc安装</title>
    <link href="/2023/02/17/rosdepc%E5%AE%89%E8%A3%85/"/>
    <url>/2023/02/17/rosdepc%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>rosdep更新失败，使用rosdepc，原文在这<a href="https://www.guyuehome.com/35408">https://www.guyuehome.com/35408</a></p><h1 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo pip <span class="hljs-keyword">install</span> rosdepc<br>sudo apt-get <span class="hljs-keyword">install</span> python-pip <br>sudo pip <span class="hljs-keyword">install</span> rosdepc<br>sudo rosdepc init<br>rosdepc update<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu下安装glog并修改源码打印自定义logo</title>
    <link href="/2023/02/14/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85glog%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E6%89%93%E5%8D%B0%E8%87%AA%E5%AE%9A%E4%B9%89logo/"/>
    <url>/2023/02/14/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85glog%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E6%89%93%E5%8D%B0%E8%87%AA%E5%AE%9A%E4%B9%89logo/</url>
    
    <content type="html"><![CDATA[<h1 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1.下载源码"></a>1.下载源码</h1><p><a href="https://github.com/google/glog">https://github.com/google/glog</a></p><h1 id="2-解压glog-master"><a href="#2-解压glog-master" class="headerlink" title="2.解压glog-master"></a>2.解压glog-master</h1><p>unzip xxx.zip/tar -zxvf xxx.tar.gz</p><h1 id="3-编译"><a href="#3-编译" class="headerlink" title="3.编译"></a>3.编译</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd glog-master<br>mkdir build<br>cd build<br>cmake ..<br>make<br>sudo make install<br></code></pre></td></tr></table></figure><h1 id="4-生成logo代码"><a href="#4-生成logo代码" class="headerlink" title="4.生成logo代码"></a>4.生成logo代码</h1><p><a href="https://tools.kalvinbg.cn/txt/ascii">kalvin在线把logo转换成ACSII</a></p><h1 id="5-kalvin在线生成工具"><a href="#5-kalvin在线生成工具" class="headerlink" title="5.kalvin在线生成工具"></a>5.kalvin在线生成工具</h1><img src="/2023/02/14/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85glog%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E6%89%93%E5%8D%B0%E8%87%AA%E5%AE%9A%E4%B9%89logo/kalvin.png" class="" title="kalvin在线工具"><h1 id="6-修改glog源码"><a href="#6-修改glog源码" class="headerlink" title="6.修改glog源码"></a>6.修改glog源码</h1><p>在glog源码/src/logging.cc 的1265行之后插入logo生成的源码，然后重新编译glog，这样就能够在你的glog打印日志开头先打印logo了。<br><img src="/2023/02/14/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85glog%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E6%89%93%E5%8D%B0%E8%87%AA%E5%AE%9A%E4%B9%89logo/logo.png" class="" title="源码修改实例"></p>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2023/02/14/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2023/02/14/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/13/hello-world/"/>
    <url>/2023/02/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
