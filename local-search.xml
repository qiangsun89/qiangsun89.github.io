<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>介绍ROS中的std_msgs</title>
    <link href="/2023/04/25/%E4%BB%8B%E7%BB%8DROS%E4%B8%AD%E7%9A%84std-msgs/"/>
    <url>/2023/04/25/%E4%BB%8B%E7%BB%8DROS%E4%B8%AD%E7%9A%84std-msgs/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍ROS中的std-msgs"><a href="#介绍ROS中的std-msgs" class="headerlink" title="介绍ROS中的std_msgs"></a>介绍ROS中的std_msgs</h1><p>Robot Operating System (ROS) 是一个用于编写机器人软件的灵活框架。在 ROS 中，std_msgs 是标准消息包，提供了一系列简单的消息类型，这些消息类型可以在不同的 ROS 节点之间进行通信。std_msgs 包含了一些基本的数据类型，如整数、浮点数、字符串等。以下是 std_msgs 中一些常用消息类型的例子：</p><ul><li>std_msgs::Bool</li><li>std_msgs::Int8、Int16、Int32、Int64</li><li>std_msgs::UInt8、UInt16、UInt32、UInt64</li><li>std_msgs::Float32、Float64</li><li>std_msgs::String</li><li>std_msgs::ColorRGBA</li><li>std_msgs::Header<br>下面是一个使用 C++ 编写的 ROS 节点例子，展示了如何使用 std_msgs::String 类型来发布和接收字符串消息：</li></ul><ol><li>首先，创建一个名为 “example_publisher” 的发布者节点：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;std_msgs/String.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;example_publisher&quot;</span>);<br>  ros::NodeHandle nh;<br><br>  ros::Publisher publisher = nh.<span class="hljs-built_in">advertise</span>&lt;std_msgs::<span class="hljs-type">String</span>&gt;(<span class="hljs-string">&quot;example_topic&quot;</span>, <span class="hljs-number">1000</span>);<br><br>  <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br>  <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>()) &#123;<br>    std_msgs::<span class="hljs-type">String</span> msg;<br>    msg.data = <span class="hljs-string">&quot;Hello, ROS! &quot;</span> + std::<span class="hljs-built_in">to_string</span>(count);<br><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;%s&quot;</span>, msg.data.<span class="hljs-built_in">c_str</span>());<br><br>    publisher.<span class="hljs-built_in">publish</span>(msg);<br><br>    ros::<span class="hljs-built_in">spinOnce</span>();<br>    loop_rate.<span class="hljs-built_in">sleep</span>();<br>    ++count;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>接下来，创建一个名为 “example_subscriber” 的订阅者节点：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;std_msgs/String.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exampleCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::<span class="hljs-type">String</span>::ConstPtr&amp; msg)</span> </span>&#123;<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Received message: %s&quot;</span>, msg-&gt;data.<span class="hljs-built_in">c_str</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;example_subscriber&quot;</span>);<br>  ros::NodeHandle nh;<br><br>  ros::Subscriber subscriber = nh.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;example_topic&quot;</span>, <span class="hljs-number">1000</span>, exampleCallback);<br><br>  ros::<span class="hljs-built_in">spin</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>这两个例子分别创建了一个发布者节点和一个订阅者节点。发布者节点发布一个 std_msgs::String 类型的消息到 “example_topic” 主题上，订阅者节点订阅该主题并在接收到新消息时调用 exampleCallback 函数。</li></ol><p>接下来，我们将详细介绍如何编译和运行上述示例中的发布者和订阅者节点。</p><p>首先，确保你已经安装了 ROS 并正确设置了环境。接下来，在你的工作空间中创建一个名为 std_msgs_example 的新 ROS 软件包：<br><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">cd ~<span class="hljs-regexp">/catkin_ws/</span>src<br>catkin_create_pkg std_msgs_example roscpp std_msgs<br><br></code></pre></td></tr></table></figure><br>现在，在 std_msgs_example 软件包的 src 文件夹中创建两个源文件：example_publisher.cpp 和 example_subscriber.cpp。将先前给出的发布者和订阅者示例代码分别复制到这两个文件中。</p><p>接下来，在 std_msgs_example/CMakeLists.txt 中添加以下内容以编译发布者和订阅者节点：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-operator"> ...</span><br><span class="hljs-operator"></span># 在 find_package 之后添加<br>add<span class="hljs-constructor">_executable(<span class="hljs-params">example_publisher</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">example_publisher</span>.<span class="hljs-params">cpp</span>)</span><br>add<span class="hljs-constructor">_executable(<span class="hljs-params">example_subscriber</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">example_subscriber</span>.<span class="hljs-params">cpp</span>)</span><br>target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">example_publisher</span> $&#123;<span class="hljs-params">catkin_LIBRARIES</span>&#125;)</span><br>target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">example_subscriber</span> $&#123;<span class="hljs-params">catkin_LIBRARIES</span>&#125;)</span><br><br></code></pre></td></tr></table></figure><p>在终端中，导航到你的工作空间目录（catkin_ws），并运行 catkin_make 以编译新创建的发布者和订阅者节点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws<br>catkin_make<br><br></code></pre></td></tr></table></figure><br>编译完成后，确保在新的终端中运行 ROS Master：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">roscore</span><br><br></code></pre></td></tr></table></figure><br>接下来，在两个单独的终端中分别运行发布者和订阅者节点：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> ~<span class="hljs-regexp">/catkin_ws/</span>devel/setup.bash<br>rosrun std_msgs_example example_publisher<br><br></code></pre></td></tr></table></figure><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> ~<span class="hljs-regexp">/catkin_ws/</span>devel/setup.bash<br>rosrun std_msgs_example example_subscriber<br><br></code></pre></td></tr></table></figure><br>此时，你将看到发布者节点定期发布消息 “Hello, ROS! X”（其中 X 是递增的整数），并且订阅者节点会显示接收到的消息。这个简单的例子演示了如何使用 std_msgs::String 类型在 ROS 节点之间传递消息。对于其他 std_msgs 类型，使用类似的方法创建发布者和订阅者节点即可。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人路径规划梯形分解（Trapezoidal cell decomposition）算法</title>
    <link href="/2023/04/24/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E6%A2%AF%E5%BD%A2%E5%88%86%E8%A7%A3%EF%BC%88Trapezoidal-cell-decomposition%EF%BC%89%E7%AE%97%E6%B3%95/"/>
    <url>/2023/04/24/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E6%A2%AF%E5%BD%A2%E5%88%86%E8%A7%A3%EF%BC%88Trapezoidal-cell-decomposition%EF%BC%89%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="机器人路径规划梯形分解（Trapezoidal-cell-decomposition）算法"><a href="#机器人路径规划梯形分解（Trapezoidal-cell-decomposition）算法" class="headerlink" title="机器人路径规划梯形分解（Trapezoidal cell decomposition）算法"></a>机器人路径规划梯形分解（Trapezoidal cell decomposition）算法</h1><p>梯形分解（Trapezoidal Cell Decomposition）是一种用于机器人路径规划的技术。它适用于二维平面上的机器人导航，特别是在有障碍物的环境中。梯形分解的基本思想是将地图分解成多个不相交的梯形区域，然后构建一个连接这些梯形区域的导航图。机器人可以通过在导航图上搜索最短路径来确定从起点到终点的最佳路径。</p><p>梯形分解的步骤如下：</p><ol><li>将地图中的障碍物多边形分解成线段。</li><li>将线段的端点向地图边界射出水平射线，将地图划分为若干个梯形区域。</li><li>通过将相邻梯形区域连接起来，构建导航图。</li><li>使用搜索算法（如A*算法）在导航图上找到从起点到终点的最短路径。</li></ol><p>以下是一个使用C++实现的梯形分解示例程序：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;iostream&gt;<br>#<span class="hljs-keyword">include</span> &lt;vector&gt;<br>#<span class="hljs-keyword">include</span> &lt;algorithm&gt;<br><br><span class="hljs-comment">// 定义点结构</span><br><span class="hljs-keyword">struct</span> Point &#123;<br>    double x, y;<br><br>    <span class="hljs-constructor">Point(<span class="hljs-params">double</span> <span class="hljs-params">x</span> = 0, <span class="hljs-params">double</span> <span class="hljs-params">y</span> = 0)</span> : x(x), y(y) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 定义线段结构</span><br><span class="hljs-keyword">struct</span> Segment &#123;<br>    Point start, <span class="hljs-keyword">end</span>;<br><br>    <span class="hljs-constructor">Segment(Point <span class="hljs-params">start</span> = Point()</span>, Point <span class="hljs-keyword">end</span> = <span class="hljs-constructor">Point()</span>) : start(start), <span class="hljs-keyword">end</span>(<span class="hljs-keyword">end</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 定义梯形结构</span><br><span class="hljs-keyword">struct</span> Trapezoid &#123;<br>    Segment top, bottom;<br>    Point leftp, rightp;<br>&#125;;<br><br><span class="hljs-keyword">class</span> TrapezoidalMap &#123;<br>public:<br>    <span class="hljs-constructor">TrapezoidalMap(<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">vector</span>&lt;Segment&gt;&amp; <span class="hljs-params">segments</span>)</span> &#123;<br>        build<span class="hljs-constructor">TrapezoidalMap(<span class="hljs-params">segments</span>)</span>;<br>    &#125;<br><br>    void build<span class="hljs-constructor">TrapezoidalMap(<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">vector</span>&lt;Segment&gt;&amp; <span class="hljs-params">segments</span>)</span> &#123;<br>        <span class="hljs-comment">// 对线段的端点进行排序</span><br>        std::vector&lt;Point&gt; endpoints(segments.size<span class="hljs-literal">()</span><span class="hljs-operator"> * </span><span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; segments.size<span class="hljs-literal">()</span>; ++i) &#123;<br>            endpoints<span class="hljs-literal">[<span class="hljs-identifier">i</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span>]</span> = segments<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.start;<br>            endpoints<span class="hljs-literal">[<span class="hljs-identifier">i</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]</span> = segments<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.<span class="hljs-keyword">end</span>;<br>        &#125;<br>        std::sort(endpoints.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, endpoints.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>, <span class="hljs-literal">[]</span>(const Point&amp; a, const Point&amp; b) &#123;<br>            return a.x &lt; b.x;<br>        &#125;);<br><br>        <span class="hljs-comment">// 生成梯形分解</span><br>        <span class="hljs-keyword">for</span> (const Point&amp; p : endpoints) &#123;<br>            <span class="hljs-comment">// 查找当前端点左侧的梯形</span><br>            Trapezoid* leftTrap = find<span class="hljs-constructor">Trapezoid(<span class="hljs-params">p</span>)</span>;<br><br>            <span class="hljs-comment">// 如果找不到左侧梯形，说明当前点在地图边界之外，跳过处理</span><br>            <span class="hljs-keyword">if</span> (!leftTrap) continue;<br><br>            <span class="hljs-comment">// 更新梯形区域</span><br>            <span class="hljs-keyword">if</span> (p.x<span class="hljs-operator"> == </span>leftTrap-&gt;rightp.x) &#123;<br>                leftTrap-&gt;rightp = p;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Trapezoid newTrap = *leftTrap;<br>                newTrap.leftp = p;<br>                trapezoids.push<span class="hljs-constructor">_back(<span class="hljs-params">newTrap</span>)</span>;<br>                leftTrap-&gt;rightp= p;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 在梯形图中查找包含给定点的梯形</span><br>Trapezoid* find<span class="hljs-constructor">Trapezoid(<span class="hljs-params">const</span> Point&amp; <span class="hljs-params">p</span>)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Trapezoid&amp; trap : trapezoids) &#123;<br>        <span class="hljs-keyword">if</span> (p.x &gt;= trap.leftp.x<span class="hljs-operator"> &amp;&amp; </span>p.x &lt;= trap.rightp.x) &#123;<br>            double topY = get<span class="hljs-constructor">YatX(<span class="hljs-params">trap</span>.<span class="hljs-params">top</span>, <span class="hljs-params">p</span>.<span class="hljs-params">x</span>)</span>;<br>            double bottomY = get<span class="hljs-constructor">YatX(<span class="hljs-params">trap</span>.<span class="hljs-params">bottom</span>, <span class="hljs-params">p</span>.<span class="hljs-params">x</span>)</span>;<br><br>            <span class="hljs-keyword">if</span> (p.y &lt;= topY<span class="hljs-operator"> &amp;&amp; </span>p.y &gt;= bottomY) &#123;<br>                return &amp;trap;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return nullptr;<br>&#125;<br><br><span class="hljs-comment">// 根据给定的x坐标和线段，计算线段上对应的y坐标</span><br>double get<span class="hljs-constructor">YatX(<span class="hljs-params">const</span> Segment&amp; <span class="hljs-params">segment</span>, <span class="hljs-params">double</span> <span class="hljs-params">x</span>)</span> &#123;<br>    double t = (x - segment.start.x)<span class="hljs-operator"> / </span>(segment.<span class="hljs-keyword">end</span>.x - segment.start.x);<br>    return segment.start.y + t<span class="hljs-operator"> * </span>(segment.<span class="hljs-keyword">end</span>.y - segment.start.y);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;Trapezoid&gt; trapezoids;<br>&#125;;<br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span> &#123;<br><span class="hljs-comment">// 定义障碍物线段</span><br>std::vector&lt;Segment&gt; segments = &#123;<br><span class="hljs-constructor">Segment(Point(2, 2)</span>, <span class="hljs-constructor">Point(5, 6)</span>),<br><span class="hljs-constructor">Segment(Point(5, 6)</span>, <span class="hljs-constructor">Point(8, 2)</span>),<br><span class="hljs-constructor">Segment(Point(10, 3)</span>, <span class="hljs-constructor">Point(13, 6)</span>),<br><span class="hljs-constructor">Segment(Point(13, 6)</span>, <span class="hljs-constructor">Point(15, 3)</span>)<br>&#125;;<br><span class="hljs-comment">// 构建梯形图</span><br>TrapezoidalMap trapezoidal<span class="hljs-constructor">Map(<span class="hljs-params">segments</span>)</span>;<br><br><span class="hljs-comment">// 寻找路径...</span><br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>上面的示例程序首先对障碍物线段进行排序，然后遍历每个端点，根据端点找到相应的梯形并更新梯形分解。为了简化问题，此示例仅处理了梯形分解的构建过程，而未包括实际的路径搜索部分。</p><p>为了在梯形分解的基础上进行路径规划，你可以使用一种图搜索算法（如A*或Dijkstra算法）来在导航图上搜索从起点到终点的最短路径。在实际应用中，你还需要考虑如何处理地图边界、障碍物多边形的凸性等问题。</p><p>在上面的示例程序中，我们完成了梯形分解的构建过程。接下来，我们将实现一个简化版的A*算法，用于在导航图上搜索从起点到终点的最短路径。</p><p>首先，我们需要定义一个函数来计算两点之间的距离，以作为启发式函数：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; a, <span class="hljs-type">const</span> Point&amp; b)</span> </span>&#123;<br>    <span class="hljs-type">double</span> dx = a.x - b.x;<br>    <span class="hljs-type">double</span> dy = a.y - b.y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(dx * dx + dy * dy);<br>&#125;<br><br></code></pre></td></tr></table></figure><br>接下来，定义一个表示导航图节点的结构体，用于存储梯形区域和A<em>算法所需的信息：<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">struct NavNode &#123;<br>    Trapezoid* trapezoid;<br>    NavNode* parent;<br>    <span class="hljs-type">double</span> <span class="hljs-keyword">cost</span>;<br>    <span class="hljs-type">double</span> heuristic;<br>    <span class="hljs-type">double</span> total;<br><br>    NavNode(Trapezoid* trapezoid, NavNode* parent, <span class="hljs-type">double</span> <span class="hljs-keyword">cost</span>, <span class="hljs-type">double</span> heuristic)<br>        : trapezoid(trapezoid), parent(parent), <span class="hljs-keyword">cost</span>(<span class="hljs-keyword">cost</span>), heuristic(heuristic) &#123;<br>        total = <span class="hljs-keyword">cost</span> + heuristic;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><br>现在我们可以开始实现A</em>算法。为简化问题，我们假设从一个梯形到另一个梯形的代价是两个梯形中心点之间的距离。实际应用中，你可能需要根据机器人的运动约束来计算代价。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">std::vector&lt;Point&gt; <span class="hljs-title">findPath</span><span class="hljs-params">(TrapezoidalMap&amp; map, <span class="hljs-type">const</span> Point&amp; start, <span class="hljs-type">const</span> Point&amp; end)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> startTrap = map.<span class="hljs-built_in">findTrapezoid</span>(start);<br>    <span class="hljs-keyword">auto</span> endTrap = map.<span class="hljs-built_in">findTrapezoid</span>(end);<br><br>    <span class="hljs-keyword">if</span> (!startTrap || !endTrap) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Start or end point is not in the trapezoidal map.&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    std::vector&lt;NavNode*&gt; openList;<br>    std::vector&lt;NavNode*&gt; closedList;<br><br>    openList.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">NavNode</span>(startTrap, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">distance</span>(start, end)));<br><br>    <span class="hljs-keyword">while</span> (!openList.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 从开放列表中选取代价最小的节点</span><br>        <span class="hljs-keyword">auto</span> minIt = std::<span class="hljs-built_in">min_element</span>(openList.<span class="hljs-built_in">begin</span>(), openList.<span class="hljs-built_in">end</span>(), [](NavNode* a, NavNode* b) &#123;<br>            <span class="hljs-keyword">return</span> a-&gt;total &lt; b-&gt;total;<br>        &#125;);<br>        NavNode* current = *minIt;<br>        openList.<span class="hljs-built_in">erase</span>(minIt);<br><br>        <span class="hljs-comment">// 如果当前节点是目标梯形，回溯并构建路径</span><br>        <span class="hljs-keyword">if</span> (current-&gt;trapezoid == endTrap) &#123;<br>            std::vector&lt;Point&gt; path;<br>            NavNode* node = current;<br>            <span class="hljs-keyword">while</span> (node) &#123;<br>                path.<span class="hljs-built_in">push_back</span>(node-&gt;trapezoid-&gt;leftp);<br>                node = node-&gt;parent;<br>            &#125;<br>            std::<span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : openList) <span class="hljs-keyword">delete</span> n;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : closedList) <span class="hljs-keyword">delete</span> n;<br><br>            <span class="hljs-keyword">return</span> path;<br>        &#125;<br><br>        <span class="hljs-comment">// 将当前节点从开放列表移动到关闭列表</span><br>        closedList.<span class="hljs-built_in">push_back</span>(current);<br><br>        <span class="hljs-comment">// 访问当前节点的相邻梯形</span><br>        std::vector&lt;Trapezoid*&gt; neighbors; <span class="hljs-comment">// 获取当前梯形的相邻梯形</span><br>    <span class="hljs-comment">// 获取当前梯形的相邻梯形（在实际实现中，你需要根据梯形之间的连接关系来获取邻居梯形）</span><br>    <span class="hljs-comment">// 这里只是简化的演示代码</span><br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-keyword">for</span> (Trapezoid* neighbor : neighbors) &#123;<br>        <span class="hljs-comment">// 如果邻居梯形已在关闭列表中，跳过</span><br>        <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">any_of</span>(closedList.<span class="hljs-built_in">begin</span>(), closedList.<span class="hljs-built_in">end</span>(), [neighbor](NavNode* n) &#123;<br>            <span class="hljs-keyword">return</span> n-&gt;trapezoid == neighbor;<br>        &#125;)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算从起点到邻居梯形的代价</span><br>        <span class="hljs-type">double</span> cost = current-&gt;cost + <span class="hljs-built_in">distance</span>(current-&gt;trapezoid-&gt;leftp, neighbor-&gt;leftp);<br>        <span class="hljs-type">double</span> heuristic = <span class="hljs-built_in">distance</span>(neighbor-&gt;leftp, end);<br>        <span class="hljs-type">double</span> total = cost + heuristic;<br><br>        <span class="hljs-comment">// 检查邻居梯形是否已在开放列表中</span><br>        <span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find_if</span>(openList.<span class="hljs-built_in">begin</span>(), openList.<span class="hljs-built_in">end</span>(), [neighbor](NavNode* n) &#123;<br>            <span class="hljs-keyword">return</span> n-&gt;trapezoid == neighbor;<br>        &#125;);<br><br>        <span class="hljs-keyword">if</span> (it != openList.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-comment">// 如果邻居梯形已在开放列表中且新的代价更低，则更新节点信息</span><br>            NavNode* existing = *it;<br>            <span class="hljs-keyword">if</span> (total &lt; existing-&gt;total) &#123;<br>                existing-&gt;parent = current;<br>                existing-&gt;cost = cost;<br>                existing-&gt;heuristic = heuristic;<br>                existing-&gt;total = total;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 将邻居梯形添加到开放列表中</span><br>            openList.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">NavNode</span>(neighbor, current, cost, heuristic));<br>        &#125;<br>    &#125;<br>&#125;<br><br>std::cerr &lt;&lt; <span class="hljs-string">&quot;No path found.&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br><br>现在，我们可以在`main`函数中使用`findPath`函数来搜索从起点到终点的最短路径：<br><br>```<span class="hljs-function">cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 定义障碍物线段</span><br>    std::vector&lt;Segment&gt; segments = &#123;<br>        <span class="hljs-built_in">Segment</span>(<span class="hljs-built_in">Point</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), <span class="hljs-built_in">Point</span>(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)),<br>        <span class="hljs-built_in">Segment</span>(<span class="hljs-built_in">Point</span>(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>), <span class="hljs-built_in">Point</span>(<span class="hljs-number">8</span>, <span class="hljs-number">2</span>)),<br>        <span class="hljs-built_in">Segment</span>(<span class="hljs-built_in">Point</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>), <span class="hljs-built_in">Point</span>(<span class="hljs-number">13</span>, <span class="hljs-number">6</span>)),<br>        <span class="hljs-built_in">Segment</span>(<span class="hljs-built_in">Point</span>(<span class="hljs-number">13</span>, <span class="hljs-number">6</span>), <span class="hljs-built_in">Point</span>(<span class="hljs-number">15</span>, <span class="hljs-number">3</span>))<br>    &#125;;<br><br>    <span class="hljs-comment">// 构建梯形图</span><br>    <span class="hljs-function">TrapezoidalMap <span class="hljs-title">trapezoidalMap</span><span class="hljs-params">(segments)</span></span>;<br><br>    <span class="hljs-comment">// 定义起点和终点</span><br>    <span class="hljs-function">Point <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-function">Point <span class="hljs-title">end</span><span class="hljs-params">(<span class="hljs-number">16</span>, <span class="hljs-number">4</span>)</span></span>;<br><br>    <span class="hljs-comment">// 寻找路径</span><br>    std::vector&lt;Point&gt; path = <span class="hljs-built_in">findPath</span>(trapezoidalMap, start, end);<br><br>    <span class="hljs-keyword">if</span> (!path.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Path found:&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Point&amp; p : path) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>这个示例程序展示了如何在梯形分解的基础上实现A*算法进行路径规划。请注意，这个示例仅用于演示目的，实际应用中可能需要对代码进行优化和改进。例如，你可以考虑以下方面的改进：</p><ol><li>在梯形分解过程中，可以构建一个数据结构来存储梯形之间的连接关系。这将有助于在A*算法中获取邻居梯形。</li><li>考虑障碍物多边形的凸性。在实际应用中，障碍物可能是凹多边形，你需要对梯形分解算法进行相应的调整以适应这种情况。</li><li>根据机器人的运动约束来计算路径代价。本示例中，我们使用了两个梯形中心点之间的距离作为代价。实际应用中，你可能需要根据机器人的运动能力和环境特性来计算更为合适的代价。</li><li>处理地图边界。在实际应用中，你需要考虑地图边界对梯形分解和路径规划的影响。</li><li>使用更有效的数据结构和算法。示例中使用的数据结构和算法可能不是最高效的选择。实际应用中，你可能需要根据具体问题选择更适合的数据结构和算法来提高程序性能。</li></ol><p>在实际项目中应用梯形分解和A*算法时，你可能还需要考虑其他因素，如机器人的尺寸、运动能力和环境特性。此外，还可以尝试使用其他路径规划算法，如Visibility Graph、Voronoi Diagram等，以满足不同应用场景的需求。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>O’Rourke, J. (1998). Computational Geometry in C (2nd ed.). Cambridge University Press.</li></ol><ul><li>本书详细介绍了计算几何领域的基本概念和算法，包括梯形分解、凸包、线段相交等。对于学习梯形分解算法的实现和应用非常有帮助。</li></ul><ol><li>Lozano-Pérez, T., &amp; Wesley, M. A. (1979). An algorithm for planning collision-free paths among polyhedral obstacles. Communications of the ACM, 22(10), 560-570.</li></ol><ul><li>这篇经典论文首次提出了可视化图（Visibility Graph）算法，用于在多边形障碍物环境中规划无碰撞路径。该算法将机器人和障碍物看作点和多边形，并构建一个表示相互可见性的图来搜索最短路径。</li></ul><ol><li>Choset, H., &amp; Lynch, K. M. (2005). Robot motion planning and control. MIT OpenCourseWare.</li></ol><ul><li>这是一门关于机器人运动规划和控制的课程，详细介绍了机器人运动学、动力学、运动规划和控制算法等方面的内容。课程中包含了多种路径规划算法，如梯形分解、可视化图、Voronoi图等，对于实现这些算法非常有帮助。</li></ul><ol><li>Lavalle, S. M. (2006). Planning algorithms. Cambridge University Press.</li></ol><ul><li>本书系统地介绍了规划算法的理论和实践，包括机器人运动规划、几何规划、决策理论等内容。书中提供了多种路径规划算法的详细解释和实现方法，对于学习路径规划算法非常有帮助。</li></ul><ol><li>LaValle, S. M. (1999). Rapidly-exploring random trees: A new tool for path planning. Technical Report 98-11, Iowa State University.</li></ol><ul><li>这篇论文首次提出了快速探索随机树（Rapidly-exploring Random Trees，RRT）算法，用于解决高维度和非完整约束的路径规划问题。RRT算法在机器人运动规划、避障、探索等领域有广泛应用。</li></ul><ol><li>Kavraki, L. E., Svestka, P., Latombe, J. C., &amp; Overmars, M. H. (1996). Probabilistic roadmaps for path planning in high-dimensional configuration spaces. IEEE Transactions on Robotics and Automation, 12(4), 566-580.</li></ol><ul><li>这篇论文提出了一种基于概率的路径规划方法——概率路图（Probabilistic Roadmaps，PRM），用于解决高维度和复杂环境中的路径规划问题。PRM算法通过在配置空间中随机采样构建路图，并使用局部规划器连接可行点，最后搜索路图上的最短路径。</li></ul><ol><li>Sánchez, G., &amp; Latombe, J. C. (2002). A single-query bi-directional probabilistic roadmap planner with lazy collision checking. The International Journal of Robotics Research, 21(1), 5-18.</li></ol><ul><li>本文介绍了一种单查询双向概率路图规划器（Bi-directional Probabilistic Roadmap Planner），并引入了惰性碰撞检测（Lazy Collision Checking）技术，以提高规划效率和性能。这种方法在机器人路径规划和避障领域有广泛应用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>path_planning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程编程技术</title>
    <link href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程编程技术"><a href="#多线程编程技术" class="headerlink" title="多线程编程技术"></a>多线程编程技术</h1><p>多线程编程技术是一种程序设计方法，它允许程序的多个部分（线程）同时执行。多线程的优势在于能够更有效地利用处理器资源，提高程序的性能。多线程对于并行处理任务、提高响应性和处理器利用率等方面具有重要意义。</p><p>在C++中，可以使用C++11标准提供的<thread>库来实现多线程编程。下面是一个简单的C++多线程示例程序：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_hello</span><span class="hljs-params">()</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 创建一个新的线程，执行print_hello函数</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(print_hello)</span></span>;<br><br>  <span class="hljs-comment">// 在主线程中打印一条消息</span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from main thread!&quot;</span> &lt;&lt; std::endl;<br><br>  <span class="hljs-comment">// 等待子线程执行完成</span><br>  t.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例中，我们首先定义了一个print_hello函数，用于在子线程中执行。在main函数中，我们创建了一个新的线程std::thread t(print_hello)，它执行print_hello函数。然后，我们在主线程中打印一条消息，表示主线程的执行。最后，我们使用t.join()等待子线程执行完成，以确保子线程在程序结束前完成任务。</p><h2 id="使用互斥量"><a href="#使用互斥量" class="headerlink" title="使用互斥量"></a>使用互斥量</h2><p>下面是一个使用互斥量保护共享资源的多线程示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>std::mutex mtx;<br><span class="hljs-type">int</span> shared_counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-type">int</span> num_increments)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_increments; ++i) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    ++shared_counter;<br>    lock.<span class="hljs-built_in">unlock</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> num_threads = <span class="hljs-number">5</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> num_increments = <span class="hljs-number">1000</span>;<br><br>  std::vector&lt;std::thread&gt; threads;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_threads; ++i) &#123;<br>    threads.<span class="hljs-built_in">emplace_back</span>(increment, num_increments);<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;t : threads) &#123;<br>    t.<span class="hljs-built_in">join</span>();<br>  &#125;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Final value of shared_counter: &quot;</span> &lt;&lt; shared_counter &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例中，我们创建了一个名为shared_counter的共享计数器，多个线程将同时访问它。为了避免竞争条件，我们使用互斥量mtx来保护对shared_counter的访问。increment函数中，我们在修改shared_counter前获取互斥量的锁，在修改shared_counter之后，我们立即释放锁。这样，就确保了在同一时刻只有一个线程能够访问shared_counter，从而避免了数据不一致和竞争条件。</p><p>main函数中，我们创建了一个std::vector<std::thread>类型的容器来存储多个线程对象。然后，我们创建了num_threads个线程，每个线程执行increment函数，并将num_increments作为参数传递。接下来，我们使用join函数等待所有线程执行完成。最后，我们输出shared_counter的最终值。</p><p>注意，这个示例仅用于说明如何使用互斥量保护共享资源。在实际应用中，你可能需要根据具体问题选择合适的同步原语，例如条件变量、信号量（semaphore）或原子操作（atomic operations）等。</p><p>这里是一个使用条件变量实现生产者-消费者模型的示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br>std::mutex mtx;<br>std::condition_variable cv;<br>std::queue&lt;<span class="hljs-type">int</span>&gt; data_queue;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">int</span> num_items)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_items; ++i) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    data_queue.<span class="hljs-built_in">push</span>(i);<br>    lock.<span class="hljs-built_in">unlock</span>();<br><br>    cv.<span class="hljs-built_in">notify_one</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    cv.<span class="hljs-built_in">wait</span>(lock, [] &#123; <span class="hljs-keyword">return</span> !data_queue.<span class="hljs-built_in">empty</span>(); &#125;);<br><br>    <span class="hljs-type">int</span> data = data_queue.<span class="hljs-built_in">front</span>();<br>    data_queue.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">if</span> (data == <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    lock.<span class="hljs-built_in">unlock</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Consumed: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">prod_thread</span><span class="hljs-params">(producer, <span class="hljs-number">10</span>)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">cons_thread</span><span class="hljs-params">(consumer)</span></span>;<br><br>  prod_thread.<span class="hljs-built_in">join</span>();<br><br>  &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    data_queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br><br>  cv.<span class="hljs-built_in">notify_one</span>();<br><br>  cons_thread.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例中，我们创建了一个生产者线程和一个消费者线程。生产者线程向data_queue中添加数据，消费者线程从data_queue中取出并处理数据。我们使用条件变量cv来同步生产者和消费者线程。当生产者线程向队列中添加数据后，它会调用cv.notify_one()来唤醒等待中的消费者线程。消费者线程在cv.wait()中等待，直到队列非空。当队列为空时，消费者线程将一直等待，直到生产者线程向队列中添加新数据并发出通知。这种方式可以有效地协调生产者和消费者线程之间的工作，避免资源浪费。</p><p>在上面的生产者-消费者示例中，我们只使用了一个生产者线程和一个消费者线程。实际上，可以通过创建多个生产者和消费者线程来进一步提高处理能力。在这种情况下，需要确保多个线程之间的同步和资源访问安全。我们可以使用相同的互斥量和条件变量来实现这一目标。</p><p>以下是一个具有多个生产者和消费者线程的生产者-消费者示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>std::mutex mtx;<br>std::condition_variable cv;<br>std::queue&lt;<span class="hljs-type">int</span>&gt; data_queue;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> num_items)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_items; ++i) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    data_queue.<span class="hljs-built_in">push</span>(i);<br>    lock.<span class="hljs-built_in">unlock</span>();<br><br>    cv.<span class="hljs-built_in">notify_one</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Producer &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    cv.<span class="hljs-built_in">wait</span>(lock, [] &#123; <span class="hljs-keyword">return</span> !data_queue.<span class="hljs-built_in">empty</span>(); &#125;);<br><br>    <span class="hljs-type">int</span> data = data_queue.<span class="hljs-built_in">front</span>();<br>    data_queue.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">if</span> (data == <span class="hljs-number">-1</span>) &#123;<br>      data_queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">// 将-1放回队列，以便其他消费者线程也能收到退出信号</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    lock.<span class="hljs-built_in">unlock</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Consumer &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; consumed: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> num_producers = <span class="hljs-number">3</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> num_consumers = <span class="hljs-number">5</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> num_items_per_producer = <span class="hljs-number">10</span>;<br><br>  std::vector&lt;std::thread&gt; producer_threads;<br>  std::vector&lt;std::thread&gt; consumer_threads;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_producers; ++i) &#123;<br>    producer_threads.<span class="hljs-built_in">emplace_back</span>(producer, i, num_items_per_producer);<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_consumers; ++i) &#123;<br>    consumer_threads.<span class="hljs-built_in">emplace_back</span>(consumer, i);<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;t : producer_threads) &#123;<br>    t.<span class="hljs-built_in">join</span>();<br>  &#125;<br><br>  &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_consumers; ++i) &#123;<br>      data_queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>  &#125;<br><br>  cv.<span class="hljs-built_in">notify_all</span>();<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;t : consumer_threads) &#123;<br>    t.<span class="hljs-built_in">join</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例中，我们创建了num_producers个生产者线程和num_consumers个消费者线程。生产者线程将数据添加到data_queue中，消费者线程从data_queue中获取并处理数据。当所有生产者线程完成工作后，我们将-1添加到data_queue中，以通知消费者线程退出。这里我们为每个消费者线程都添加了一个-1，确保所有消费者线程都能收到退出信号。</p><p>请注意，多线程编程需要仔细考虑同步和资源访问安全，以避免潜在的问题，如竞争条件、死锁和数据不一致。在实际应用中，还需要根据具体需求选择合适的线程管理策略和线程池技术。线程池是一种管理线程的方式，它预先创建一定数量的线程，并在需要时将任务分配给空闲线程。这样可以减少线程创建和销毁的开销，提高程序的性能和响应性。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>在C++中，可以使用第三方库（例如Intel TBB或Boost.Asio等）来实现线程池功能。也可以自己实现一个简单的线程池，如下所示：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br>class <span class="hljs-title class_">ThreadPool</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">public:</span><br>  ThreadPool(size_t num_threads) : done(false) <span class="hljs-punctuation">&#123;</span><br>    for (size_t i = <span class="hljs-number">0</span><span class="hljs-punctuation">;</span> i <span class="hljs-params">&lt; num_threads; ++i) &#123;</span><br><span class="hljs-params">      worker_threads.emplace_back(<span class="hljs-variable">&amp;</span>ThreadPool::worker, this);</span><br><span class="hljs-params">    &#125;</span><br><span class="hljs-params">  &#125;</span><br><span class="hljs-params"></span><br><span class="hljs-params">  ~ThreadPool() &#123;</span><br><span class="hljs-params">    done = true;</span><br><span class="hljs-params">    cv.notify_all();</span><br><span class="hljs-params">    for (auto <span class="hljs-variable">&amp;t</span> : worker_threads) &#123;</span><br><span class="hljs-params">      t.join();</span><br><span class="hljs-params">    &#125;</span><br><span class="hljs-params">  &#125;</span><br><span class="hljs-params"></span><br><span class="hljs-params">  template &lt;typename Func, typename... Args&gt;</span><br>  auto enqueue(Func &amp;<span class="hljs-variable">&amp;func</span>, Args &amp;&amp;... args)<br>      -&gt; std::future<span class="hljs-params">&lt;typename std::result_of&lt;Func(Args...)&gt;</span>::type&gt; <span class="hljs-punctuation">&#123;</span><br>    using ReturnT<span class="hljs-attr">ype</span> <span class="hljs-operator">=</span> typename std::result_of<span class="hljs-params">&lt;Func(Args...)&gt;</span>::<span class="hljs-attr">type</span><span class="hljs-punctuation">;</span><br>    auto <span class="hljs-attr">task</span> <span class="hljs-operator">=</span> std::make_shared<span class="hljs-params">&lt;std::packaged_task&lt;ReturnType()&gt;</span>&gt;(<br><span class="hljs-symbol">        std:</span>:bind(std::forward<span class="hljs-params">&lt;Func&gt;</span>(func), std::forward<span class="hljs-params">&lt;Args&gt;</span>(args)...))<span class="hljs-punctuation">;</span><br><span class="hljs-symbol">    std:</span>:future<span class="hljs-params">&lt;ReturnType&gt;</span> <span class="hljs-attr">result</span> <span class="hljs-operator">=</span> task-&gt;get_future()<span class="hljs-punctuation">;</span><br><br>    <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      std:</span>:unique_lock<span class="hljs-params">&lt;std::mutex&gt;</span> lock(mtx)<span class="hljs-punctuation">;</span><br>      tasks.emplace([task]() <span class="hljs-punctuation">&#123;</span> (*task)()<span class="hljs-punctuation">;</span> <span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">;</span><br>    <span class="hljs-punctuation">&#125;</span><br><br>    cv.notify_one()<span class="hljs-punctuation">;</span><br>    return <span class="hljs-attr">result</span><span class="hljs-punctuation">;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">private:</span><br>  void worker() <span class="hljs-punctuation">&#123;</span><br>    while (!done) <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      std:</span>:function<span class="hljs-params">&lt;void()&gt;</span> <span class="hljs-attr">task</span><span class="hljs-punctuation">;</span><br>      <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">        std:</span>:unique_lock<span class="hljs-params">&lt;std::mutex&gt;</span> lock(mtx)<span class="hljs-punctuation">;</span><br>        cv.wait(lock, [this] <span class="hljs-punctuation">&#123;</span> return done || !tasks.empty()<span class="hljs-punctuation">;</span> <span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">;</span><br><br>        if (done &amp;&amp; tasks.empty()) <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">return</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-punctuation">&#125;</span><br><br>        <span class="hljs-attr">task</span> <span class="hljs-operator">=</span> std::move(tasks.front())<span class="hljs-punctuation">;</span><br>        tasks.pop()<span class="hljs-punctuation">;</span><br>      <span class="hljs-punctuation">&#125;</span><br><br>      task()<span class="hljs-punctuation">;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  std:</span>:vector<span class="hljs-params">&lt;std::thread&gt;</span> worker_<span class="hljs-attr">threads</span><span class="hljs-punctuation">;</span><br><span class="hljs-symbol">  std:</span>:queue<span class="hljs-params">&lt;std::function&lt;void()&gt;</span>&gt; <span class="hljs-attr">tasks</span><span class="hljs-punctuation">;</span><br><span class="hljs-symbol">  std:</span>:mutex <span class="hljs-attr">mtx</span><span class="hljs-punctuation">;</span><br><span class="hljs-symbol">  std:</span>:condition_variable <span class="hljs-attr">cv</span><span class="hljs-punctuation">;</span><br><span class="hljs-symbol">  std:</span>:atomic_bool <span class="hljs-attr">done</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br><br></code></pre></td></tr></table></figure><br>这个简单的线程池实现提供了一个enqueue方法，可以将任务添加到线程池中。线程池中的工作线程在执行任务时，会等待任务队列中的新任务。当任务队列为空时，工作线程会阻塞等待，直到有新任务添加到队列中。当线程池析构时，所有工作线程将退出。</p><p>使用线程池可以简化多线程任务的管理，并提高程序性能。通过限制线程的数量，线程池可以帮助降低资源竞争和上下文切换开销。此外，线程池还可以根据系统负载动态调整线程数量，以适应不同的运行环境和任务需求。</p><p>以下是一个使用上述线程池实现的示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">long_running_task</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Task &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; completed on thread &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> id * <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">ThreadPool <span class="hljs-title">thread_pool</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>  std::vector&lt;std::future&lt;<span class="hljs-type">int</span>&gt;&gt; results;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>    results.<span class="hljs-built_in">emplace_back</span>(thread_pool.<span class="hljs-built_in">enqueue</span>(long_running_task, i));<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;result : results) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例中，我们创建了一个包含4个工作线程的线程池。我们将10个long_running_task任务添加到线程池中，并将返回的std::future对象存储在一个向量中。这些任务将由线程池中的工作线程执行。最后，我们等待所有任务完成，并输出结果。</p><p>请注意，在使用多线程和线程池时，始终要关注线程安全、资源竞争、死锁和性能等问题。在编写多线程代码时，务必谨慎地选择合适的同步原语，并在适当时机对共享资源进行保护。此外，在实际应用中，可能需要根据项目需求选择不同的线程池实现，以满足性能、灵活性和易用性等方面的需求。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详细介绍std::unique_ptr</title>
    <link href="/2023/04/24/%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8Dstd-unique-ptr/"/>
    <url>/2023/04/24/%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8Dstd-unique-ptr/</url>
    
    <content type="html"><![CDATA[<h1 id="详细介绍std-unique-ptr"><a href="#详细介绍std-unique-ptr" class="headerlink" title="详细介绍std::unique_ptr"></a>详细介绍std::unique_ptr</h1><p>std::unique_ptr是C++11中引入的智能指针（smart pointer）之一，它提供了一种自动化的资源管理方式，可以避免手动进行内存管理和释放，同时也可以防止内存泄漏和悬挂指针等常见的编程错误。在本文中，我们将详细介绍std::unique_ptr的使用方法和注意事项，并提供一些示例代码。</p><h2 id="std-unique-ptr的基本用法"><a href="#std-unique-ptr的基本用法" class="headerlink" title="std::unique_ptr的基本用法"></a>std::unique_ptr的基本用法</h2><p>std::unique_ptr是一种独占所有权的智能指针，它只允许一个指针拥有对资源的所有权，其他指针不能访问或者修改这个资源。在创建std::unique_ptr对象时，需要指定指针所指向的资源类型，并使用new操作符来分配资源。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">uptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们创建了一个std::unique_ptr对象，它指向一个int类型的资源，并使用new操作符来分配资源。我们可以使用箭头运算符（-&gt;）和星号运算符（*）来访问和修改资源，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cout &lt;&lt; *uptr &lt;&lt; std::endl; <span class="hljs-comment">// Output: 42</span><br>*uptr = <span class="hljs-number">24</span>;<br>std::cout &lt;&lt; *uptr &lt;&lt; std::endl; <span class="hljs-comment">// Output: 24</span><br><br></code></pre></td></tr></table></figure><br>在访问和修改资源时，我们应该遵循以下几个原则：</p><ul><li><p>避免使用裸指针：使用裸指针可能会导致内存泄漏和悬挂指针等常见的编程错误。在使用std::unique_ptr时，应该尽可能避免使用裸指针，以提高代码的安全性和可维护性。</p></li><li><p>使用get函数获取裸指针：如果需要将std::unique_ptr对象传递给需要裸指针的接口或者函数，可以使用get函数获取裸指针。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> </span>&#123;<br>    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">uptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;<br>    <span class="hljs-built_in">foo</span>(uptr.<span class="hljs-built_in">get</span>()); <span class="hljs-comment">// Output: 42</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个接受裸指针的函数foo，并将std::unique_ptr对象的裸指针作为参数传递给它。</p></li><li><p>使用release函数释放所有权：如果需要将std::unique_ptr对象转移给其他对象或者接口，可以使用release函数释放所有权，并返回裸指针。注意，释放所有权后，std::unique_ptr对象将不再拥有对资源的所有权，我们需要手动释放资源或者将资源交给其他std::unique_ptr对象来管理。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">uptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;<br><span class="hljs-type">int</span>* ptr = uptr.<span class="hljs-built_in">release</span>();<br><span class="hljs-comment">// do something with ptr</span><br><span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// manually release the resource</span><br><br></code></pre></td></tr></table></figure><p>在使用std::unique_ptr时，我们应该注意以下几个注意事项：</p></li><li><p>不要使用std::unique_ptr管理数组：std::unique_ptr不适用于管理数组类型的资源，因为它没有提供数组类型的删除器（deleter）。如果需要管理数组类型的资源，可以使用std::unique_ptr的特化版本std::unique_ptr<T[]>，或者使用std::vector等标准容器来管理。</p></li><li>使用删除器（deleter）自定义资源释放方式：如果需要自定义资源的释放方式，可以使用删除器（deleter）。删除器是一个函数对象或者函数指针，它接受一个指向资源的指针，并负责释放这个资源。在创建std::unique_ptr对象时，可以将删除器作为第二个参数传递给它。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_deleter</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;deleting &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;<br>    <span class="hljs-keyword">delete</span> ptr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>, <span class="hljs-title">void</span><span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span>&gt; <span class="hljs-title">uptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>), my_deleter)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>在这个例子中，我们定义了一个删除器my_deleter，并将它作为第二个参数传递给std::unique_ptr对象。在删除std::unique_ptr对象时，删除器将被调用来释放资源。</li><li>使用std::make_unique创建std::unique_ptr对象：std::make_unique是C++14中引入的函数模板，它可以方便地创建std::unique_ptr对象，同时避免了使用new操作符来手动分配资源的繁琐过程。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; uptr = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><br></code></pre></td></tr></table></figure>在这个例子中，我们使用std::make_unique函数创建了一个std::unique_ptr对象，并将它初始化为42。<h2 id="std-unique-ptr的高级用法"><a href="#std-unique-ptr的高级用法" class="headerlink" title="std::unique_ptr的高级用法"></a>std::unique_ptr的高级用法</h2>除了基本用法之外，std::unique_ptr还提供了一些高级用法，例如：<h3 id="std-unique-ptr的移动语义"><a href="#std-unique-ptr的移动语义" class="headerlink" title="std::unique_ptr的移动语义"></a>std::unique_ptr的移动语义</h3>std::unique_ptr是一个移动语义类型，它可以被移动但不能被复制。在移动std::unique_ptr对象时，资源的所有权将被转移给新的std::unique_ptr对象，原始的std::unique_ptr对象将不再拥有对资源的所有权。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">uptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;<br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; uptr2 = std::<span class="hljs-built_in">move</span>(uptr1);<br>std::cout &lt;&lt; *uptr2 &lt;&lt; std::endl; <span class="hljs-comment">// Output: 42</span><br><br></code></pre></td></tr></table></figure>在这个例子中，我们创建了一个std::unique_ptr对象uptr1，并将它的所有权移动给了另一个std::unique_ptr对象uptr2。在移动完成后，uptr1将不再拥有对资源的所有权。<h3 id="std-unique-ptr的自定义删除器类型"><a href="#std-unique-ptr的自定义删除器类型" class="headerlink" title="std::unique_ptr的自定义删除器类型"></a>std::unique_ptr的自定义删除器类型</h3>std::unique_ptr的删除器类型不一定是一个函数指针或者函数对象，它还可以是一个自定义类型。在定义删除器类型时，需要定义一个调用运算符operator()，并将它用于释放资源。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_deleter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;deleting &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;<br>        <span class="hljs-keyword">delete</span> ptr;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>, my_deleter&gt; <span class="hljs-title">uptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>在这个例子中，我们定义了一个自定义删除器类型my_deleter，它包含一个调用运算符，用于释放资源。在创建std::unique_ptr对象时，我们将my_deleter类型作为第二个模板参数传递给它。<h3 id="std-unique-ptr的空指针检查"><a href="#std-unique-ptr的空指针检查" class="headerlink" title="std::unique_ptr的空指针检查"></a>std::unique_ptr的空指针检查</h3>std::unique_ptr提供了一个成员函数get，可以获取它所管理的资源的裸指针。当std::unique_ptr对象为空指针时，get函数将返回nullptr。我们可以使用bool运算符或者显式的空指针检查来判断std::unique_ptr对象是否为空指针。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; uptr;<br><span class="hljs-keyword">if</span> (!uptr) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;uptr is a null pointer&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br></code></pre></td></tr></table></figure>在这个例子中，我们定义了一个空的std::unique_ptr对象uptr，并使用bool运算符来判断它是否为空指针。</li></ul><p>总的来说，std::unique_ptr是一种非常方便和安全的资源管理方式，可以避免手动进行内存管理和释放，同时也可以防止内存泄漏和悬挂指针等常见的编程错误。在使用std::unique_ptr时，我们应该遵循基本用法和注意事项，并根据需要使用高级用法来提高代码的可读性和可维护性。</p><p>下面是一些示例代码，用于演示std::unique_ptr的基本用法和高级用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass foo&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_deleter</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;deleting &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;<br>    <span class="hljs-keyword">delete</span> ptr;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_deleter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;deleting &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;<br>        <span class="hljs-keyword">delete</span> ptr;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Basic usage</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">uptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;<br>    std::cout &lt;&lt; *uptr &lt;&lt; std::endl;<br>    *uptr = <span class="hljs-number">24</span>;<br>    std::cout &lt;&lt; *uptr &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// Get raw pointer</span><br>    <span class="hljs-type">void</span>* ptr = uptr.<span class="hljs-built_in">get</span>();<br>    std::cout &lt;&lt; *<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(ptr) &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// Custom deleter</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>, <span class="hljs-title">void</span><span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span>&gt; <span class="hljs-title">uptr2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>), my_deleter)</span></span>;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>, my_deleter&gt; <span class="hljs-title">uptr3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;<br><br>    <span class="hljs-comment">// Move semantics</span><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; uptr4 = std::<span class="hljs-built_in">move</span>(uptr);<br>    std::cout &lt;&lt; *uptr4 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// Null pointer check</span><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; uptr5;<br>    <span class="hljs-keyword">if</span> (!uptr5) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;uptr5 is a null pointer&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// Custom class</span><br>    <span class="hljs-function">std::unique_ptr&lt;MyClass&gt; <span class="hljs-title">uptr6</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MyClass())</span></span>;<br>    uptr6-&gt;<span class="hljs-built_in">foo</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例代码中，我们演示了std::unique_ptr的基本用法和高级用法，包括创建std::unique_ptr对象、获取裸指针、使用自定义删除器、使用移动语义、空指针检查、自定义类等。在使用std::unique_ptr时，我们应该根据需要选择合适的用法，以提高代码的安全性和可维护性。</p><p>补充一些示例代码，用于演示std::unique_ptr的更多用法：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-comment">#include &lt;memory&gt;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-title function_ invoke__">MyClass</span>() &#123;<br>        std::<span class="hljs-variable constant_">cout</span> &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;<br>    &#125;<br><br>    ~<span class="hljs-title function_ invoke__">MyClass</span>() &#123;<br>        std::<span class="hljs-variable constant_">cout</span> &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">foo</span>() &#123;<br>        std::<span class="hljs-variable constant_">cout</span> &lt;&lt; <span class="hljs-string">&quot;MyClass foo&quot;</span> &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDeleter</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">operator</span>()(MyClass* ptr) <span class="hljs-keyword">const</span> &#123;<br>        std::<span class="hljs-variable constant_">cout</span> &lt;&lt; <span class="hljs-string">&quot;MyDeleter deleting MyClass&quot;</span> &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;<br>        delete ptr;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">int</span> <span class="hljs-title function_ invoke__">main</span>() &#123;<br>    <span class="hljs-comment">// Create a unique_ptr that owns a dynamically-allocated int</span><br>    std::<span class="hljs-variable constant_">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title function_ invoke__">uptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>));<br>    std::<span class="hljs-variable constant_">cout</span> &lt;&lt; *uptr &lt;&lt; std::<span class="hljs-variable constant_">endl</span>; <span class="hljs-comment">// Output: 42</span><br><br>    <span class="hljs-comment">// Use make_unique to create a unique_ptr</span><br>    auto uptr2 = std::<span class="hljs-variable constant_">make_unique</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10</span>);<br>    std::<span class="hljs-variable constant_">cout</span> &lt;&lt; *uptr2 &lt;&lt; std::<span class="hljs-variable constant_">endl</span>; <span class="hljs-comment">// Output: 10</span><br><br>    <span class="hljs-comment">// Release the ownership of the pointer and return its value</span><br>    <span class="hljs-keyword">int</span>* raw_ptr = uptr.<span class="hljs-title function_ invoke__">release</span>();<br>    std::<span class="hljs-variable constant_">cout</span> &lt;&lt; *raw_ptr &lt;&lt; std::<span class="hljs-variable constant_">endl</span>; <span class="hljs-comment">// Output: 42</span><br><br>    <span class="hljs-comment">// Transfer the ownership of a pointer to another unique_ptr</span><br>    std::<span class="hljs-variable constant_">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title function_ invoke__">uptr3</span>(raw_ptr);<br>    std::<span class="hljs-variable constant_">cout</span> &lt;&lt; *uptr3 &lt;&lt; std::<span class="hljs-variable constant_">endl</span>; <span class="hljs-comment">// Output: 42</span><br><br>    <span class="hljs-comment">// Custom deleter</span><br>    std::<span class="hljs-variable constant_">unique_ptr</span>&lt;MyClass, MyDeleter&gt; <span class="hljs-title function_ invoke__">uptr4</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(), <span class="hljs-title function_ invoke__">MyDeleter</span>());<br>    uptr4-&gt;<span class="hljs-title function_ invoke__">foo</span>(); <span class="hljs-comment">// Output: MyClass foo</span><br><br>    <span class="hljs-comment">// Access the managed pointer using get()</span><br>    <span class="hljs-keyword">int</span>* raw_ptr2 = uptr.<span class="hljs-title function_ invoke__">get</span>();<br>    <span class="hljs-keyword">if</span> (raw_ptr2 != nullptr) &#123;<br>        std::<span class="hljs-variable constant_">cout</span> &lt;&lt; *raw_ptr2 &lt;&lt; std::<span class="hljs-variable constant_">endl</span>; <span class="hljs-comment">// Output: 42</span><br>    &#125;<br><br>    <span class="hljs-comment">// Null pointer check</span><br>    std::<span class="hljs-variable constant_">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; uptr5;<br>    <span class="hljs-keyword">if</span> (uptr5 == nullptr) &#123;<br>        std::<span class="hljs-variable constant_">cout</span> &lt;&lt; <span class="hljs-string">&quot;uptr5 is a null pointer&quot;</span> &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Array management using a unique_ptr</span><br>    std::<span class="hljs-variable constant_">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>[]&gt; <span class="hljs-title function_ invoke__">uptr6</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);<br>    std::<span class="hljs-variable constant_">cout</span> &lt;&lt; uptr6[<span class="hljs-number">0</span>] &lt;&lt; std::<span class="hljs-variable constant_">endl</span>; <span class="hljs-comment">// Output: 1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例代码中，我们进一步演示了std::unique_ptr的用法，包括使用make_unique创建std::unique_ptr对象、释放所有权、转移所有权、使用自定义删除器、使用get()函数获取裸指针、空指针检查以及管理数组类型的资源。这些示例代码可以帮助开发者更好地理解std::unique_ptr的使用方法和注意事项，并应用到实际的项目开发中。</p><p>以下是一些额外的示例代码，演示了std::unique_ptr的更多高级用法：<br><figure class="highlight plaintext"><figcaption><span><iostream></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs #include">#include &lt;memory&gt;<br><br>class MyClass &#123;<br>public:<br>    MyClass() &#123;<br>        std::cout &lt;&lt; &quot;MyClass constructor&quot; &lt;&lt; std::endl;<br>    &#125;<br><br>    ~MyClass() &#123;<br>        std::cout &lt;&lt; &quot;MyClass destructor&quot; &lt;&lt; std::endl;<br>    &#125;<br><br>    void foo() &#123;<br>        std::cout &lt;&lt; &quot;MyClass foo&quot; &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br>class MyDeleter &#123;<br>public:<br>    void operator()(MyClass* ptr) const &#123;<br>        std::cout &lt;&lt; &quot;MyDeleter deleting MyClass&quot; &lt;&lt; std::endl;<br>        delete ptr;<br>    &#125;<br>&#125;;<br><br>int main() &#123;<br>    // Custom deleter with lambda function<br>    auto deleter = [](int* ptr) &#123;<br>        std::cout &lt;&lt; &quot;deleting &quot; &lt;&lt; *ptr &lt;&lt; std::endl;<br>        delete ptr;<br>    &#125;;<br>    std::unique_ptr&lt;int, decltype(deleter)&gt; uptr(new int(42), deleter);<br>    std::cout &lt;&lt; *uptr &lt;&lt; std::endl; // Output: 42<br><br>    // Custom deleter with lambda function capturing an external variable<br>    int factor = 10;<br>    auto deleter2 = [factor](int* ptr) &#123;<br>        std::cout &lt;&lt; &quot;deleting &quot; &lt;&lt; *ptr &lt;&lt; &quot; times &quot; &lt;&lt; factor &lt;&lt; std::endl;<br>        delete ptr;<br>    &#125;;<br>    std::unique_ptr&lt;int, decltype(deleter2)&gt; uptr2(new int(42), deleter2);<br>    std::cout &lt;&lt; *uptr2 &lt;&lt; std::endl; // Output: 42<br><br>    // Custom deleter with member function pointer<br>    std::unique_ptr&lt;MyClass, void(MyClass::*)()&gt; uptr3(new MyClass(), &amp;MyClass::foo);<br>    uptr3-&gt;foo(); // Output: MyClass foo<br><br>    // Make unique array<br>    auto uptr4 = std::make_unique&lt;int[]&gt;(3);<br>    uptr4[0] = 1;<br>    uptr4[1] = 2;<br>    uptr4[2] = 3;<br>    std::cout &lt;&lt; uptr4[1] &lt;&lt; std::endl; // Output: 2<br><br>    // Get raw pointer and release ownership<br>    int* raw_ptr = uptr4.release();<br>    delete[] raw_ptr;<br><br>    return 0;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例代码中，我们进一步演示了std::unique_ptr的高级用法，包括使用lambda函数作为删除器、使用成员函数指针作为删除器、使用std::make_unique创建数组类型的std::unique_ptr对象、使用release函数释放所有权。这些示例代码可以帮助开发者更好地理解std::unique_ptr的高级用法，并且可以应用到更加复杂的项目开发中。</p><p>接下来是一些示例代码，演示了如何在STL算法中使用std::unique_ptr：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Sort a vector of unique_ptr</span><br>    std::vector&lt;std::unique_ptr&lt;<span class="hljs-type">int</span>&gt;&gt; vec;<br>    vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>));<br>    vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>));<br>    vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>    std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> std::unique_ptr&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> std::unique_ptr&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123;<br>        <span class="hljs-keyword">return</span> *a &lt; *b;<br>    &#125;);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ptr : vec) &#123;<br>        std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="hljs-comment">// Output: 1 2 3</span><br>    &#125;<br><br>    <span class="hljs-comment">// Transform a vector of int into a vector of unique_ptr</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec2 &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    std::vector&lt;std::unique_ptr&lt;<span class="hljs-type">int</span>&gt;&gt; vec3;<br>    std::<span class="hljs-built_in">transform</span>(vec2.<span class="hljs-built_in">begin</span>(), vec2.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">back_inserter</span>(vec3), [](<span class="hljs-type">int</span> i) &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(i);<br>    &#125;);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ptr : vec3) &#123;<br>        std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="hljs-comment">// Output: 1 2 3</span><br>    &#125;<br><br>    <span class="hljs-comment">// Remove elements from a vector of unique_ptr</span><br>    std::vector&lt;std::unique_ptr&lt;<span class="hljs-type">int</span>&gt;&gt; vec4;<br>    vec4.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>));<br>    vec4.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>    vec4.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">auto</span> new_end = std::<span class="hljs-built_in">remove_if</span>(vec4.<span class="hljs-built_in">begin</span>(), vec4.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> std::unique_ptr&lt;<span class="hljs-type">int</span>&gt;&amp; ptr) &#123;<br>        <span class="hljs-keyword">return</span> *ptr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>    &#125;);<br>    vec4.<span class="hljs-built_in">erase</span>(new_end, vec4.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ptr : vec4) &#123;<br>        std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="hljs-comment">// Output: 1 3</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例代码中，我们演示了如何在STL算法中使用std::unique_ptr，包括对std::vector中的std::unique_ptr进行排序、将std::vector<int>转换为std::vector<std::unique_ptr<int>&gt;、从std::vector<std::unique_ptr<int>&gt;中删除指定的元素等。使用std::unique_ptr作为STL算法的元素类型，可以更加方便和安全地管理资源，同时也可以避免内存泄漏和悬挂指针等问题。</p><p>以下是一些示例代码，演示了如何使用std::unique_ptr实现RAII的资源管理模式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyResource</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyResource</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyResource constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyResource</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyResource destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyResource foo&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyManager</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyManager</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyManager constructor&quot;</span> &lt;&lt; std::endl;<br>        m_resource = std::<span class="hljs-built_in">make_unique</span>&lt;MyResource&gt;();<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyManager</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyManager destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use_resource</span><span class="hljs-params">()</span> </span>&#123;<br>        m_resource-&gt;<span class="hljs-built_in">foo</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;MyResource&gt; m_resource;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// RAII with unique_ptr</span><br>    &#123;<br>        <span class="hljs-function">std::unique_ptr&lt;MyResource&gt; <span class="hljs-title">uptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MyResource())</span></span>;<br>        uptr-&gt;<span class="hljs-built_in">foo</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// RAII with a manager class</span><br>    &#123;<br>        MyManager manager;<br>        manager.<span class="hljs-built_in">use_resource</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例代码中，我们演示了如何使用std::unique_ptr实现RAII的资源管理模式。在第一个示例中，我们创建了一个std::unique_ptr对象，使用它来管理MyResource类型的资源，并在作用域结束时自动释放资源。在第二个示例中，我们使用一个管理类MyManager来封装MyResource类型的资源，并使用std::unique_ptr来管理MyResource对象的所有权。在MyManager的构造函数中创建MyResource对象，并在析构函数中释放MyResource对象的资源，同时提供一个接口use_resource，用于使用MyResource对象的资源。这种基于std::unique_ptr的RAII模式可以避免手动进行内存管理和释放，从而提高代码的可读性和可维护性。</p><p>以下是一些示例代码，演示了如何使用std::unique_ptr作为返回值：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-comment">#include &lt;memory&gt;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-title function_ invoke__">MyClass</span>() &#123;<br>        std::<span class="hljs-variable constant_">cout</span> &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;<br>    &#125;<br><br>    ~<span class="hljs-title function_ invoke__">MyClass</span>() &#123;<br>        std::<span class="hljs-variable constant_">cout</span> &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">foo</span>() &#123;<br>        std::<span class="hljs-variable constant_">cout</span> &lt;&lt; <span class="hljs-string">&quot;MyClass foo&quot;</span> &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;<br>    &#125;<br>&#125;;<br><br>std::<span class="hljs-variable constant_">unique_ptr</span>&lt;MyClass&gt; <span class="hljs-title function_ invoke__">create_my_class</span>() &#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-variable constant_">make_unique</span>&lt;MyClass&gt;();<br>&#125;<br><br>std::<span class="hljs-variable constant_">unique_ptr</span>&lt;MyClass[]&gt; <span class="hljs-title function_ invoke__">create_my_class_array</span>(size_t size) &#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-variable constant_">make_unique</span>&lt;MyClass[]&gt;(size);<br>&#125;<br><br><span class="hljs-keyword">int</span> <span class="hljs-title function_ invoke__">main</span>() &#123;<br>    <span class="hljs-comment">// Return a unique_ptr from a function</span><br>    auto uptr = <span class="hljs-title function_ invoke__">create_my_class</span>();<br>    uptr-&gt;<span class="hljs-title function_ invoke__">foo</span>(); <span class="hljs-comment">// Output: MyClass foo</span><br><br>    <span class="hljs-comment">// Return a unique_ptr array from a function</span><br>    auto uptr_array = <span class="hljs-title function_ invoke__">create_my_class_array</span>(<span class="hljs-number">3</span>);<br>    uptr_array[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">foo</span>(); <span class="hljs-comment">// Output: MyClass foo</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例代码中，我们演示了如何使用std::unique_ptr作为函数的返回值类型，包括返回单个对象和返回对象数组。通过使用std::unique_ptr作为返回值类型，我们可以避免内存泄漏和悬挂指针等问题，同时也可以方便地传递对象的所有权，使代码更加清晰和安全。</p><p>以下是一些示例代码，演示了如何使用std::unique_ptr实现Pimpl Idiom（Pointer to Implementation Idiom）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassImpl</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClassImpl foo&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">m_impl</span>(std::<span class="hljs-built_in">make_unique</span>&lt;MyClassImpl&gt;()) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        m_impl-&gt;<span class="hljs-built_in">foo</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;MyClassImpl&gt; m_impl;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    obj.<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// Output: MyClassImpl foo</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例代码中，我们演示了如何使用std::unique_ptr实现Pimpl Idiom（Pointer to Implementation Idiom）。Pimpl Idiom是一种设计模式，它的核心思想是将类的实现细节和接口分离，使得实现细节可以被封装在一个私有类中，并通过一个指针来访问这个私有类，从而避免将实现细节暴露在类的接口中。在这个示例中，我们将MyClass的实现细节封装在MyClassImpl中，并通过一个std::unique_ptr指针来访问MyClassImpl，从而实现了Pimpl Idiom。使用Pimpl Idiom可以提高代码的可维护性和可重用性，同时也可以减少编译时间和链接时间。</p><p>以下是一些示例代码，演示了如何使用std::unique_ptr实现基于策略模式的设计：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyA</span> : <span class="hljs-keyword">public</span> Strategy &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Executing ConcreteStrategyA&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyB</span> : <span class="hljs-keyword">public</span> Strategy &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Executing ConcreteStrategyB&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Context</span>(std::unique_ptr&lt;Strategy&gt; strategy) : <span class="hljs-built_in">m_strategy</span>(std::<span class="hljs-built_in">move</span>(strategy)) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_strategy</span><span class="hljs-params">(std::unique_ptr&lt;Strategy&gt; strategy)</span> </span>&#123;<br>        m_strategy = std::<span class="hljs-built_in">move</span>(strategy);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute_strategy</span><span class="hljs-params">()</span> </span>&#123;<br>        m_strategy-&gt;<span class="hljs-built_in">execute</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;Strategy&gt; m_strategy;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> strategyA = std::<span class="hljs-built_in">make_unique</span>&lt;ConcreteStrategyA&gt;();<br>    <span class="hljs-keyword">auto</span> strategyB = std::<span class="hljs-built_in">make_unique</span>&lt;ConcreteStrategyB&gt;();<br><br>    <span class="hljs-function">Context <span class="hljs-title">context</span><span class="hljs-params">(std::move(strategyA))</span></span>;<br>    context.<span class="hljs-built_in">execute_strategy</span>(); <span class="hljs-comment">// Output: Executing ConcreteStrategyA</span><br><br>    context.<span class="hljs-built_in">set_strategy</span>(std::<span class="hljs-built_in">move</span>(strategyB));<br>    context.<span class="hljs-built_in">execute_strategy</span>(); <span class="hljs-comment">// Output: Executing ConcreteStrategyB</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例代码中，我们演示了如何使用std::unique_ptr实现基于策略模式的设计。策略模式是一种设计模式，它的核心思想是将算法的实现细节和客户端分离，从而使得算法的实现可以独立于客户端进行修改和重用。在这个示例中，我们使用了一个Context类来封装策略的执行，使用std::unique_ptr来管理Strategy对象的所有权，并使用set_strategy函数来动态切换不同的策略实现。这种基于std::unique_ptr的策略模式可以提高代码的可维护性和可扩展性，同时也可以避免内存泄漏和悬挂指针等问题。</p><p>以下是一些示例代码，演示了如何使用std::unique_ptr实现移动语义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass copy constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass copy assignment operator&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp;) <span class="hljs-keyword">noexcept</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass move constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(MyClass&amp;&amp;) <span class="hljs-keyword">noexcept</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass move assignment operator&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Move semantics with unique_ptr</span><br>    <span class="hljs-keyword">auto</span> uptr1 = std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;();<br>    <span class="hljs-keyword">auto</span> uptr2 = std::<span class="hljs-built_in">move</span>(uptr1);<br>    <span class="hljs-keyword">auto</span> uptr3 = std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;();<br>    uptr3 = std::<span class="hljs-built_in">move</span>(uptr2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例代码中，我们演示了如何使用std::unique_ptr实现移动语义。移动语义是一种C++11引入的新特性，它允许我们将资源从一个对象转移到另一个对象，而不需要进行资源的复制和销毁，从而提高程序的性能和效率。在这个示例中，我们使用std::unique_ptr来管理MyClass类型的资源，使用std::move函数来实现资源的移动，从而调用MyClass的移动构造函数和移动赋值运算符。使用std::unique_ptr和移动语义可以避免资源的不必要复制和销毁，从而提高程序的性能和效率。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结C++的模板template编程技术</title>
    <link href="/2023/04/24/%E6%80%BB%E7%BB%93C-%E7%9A%84%E6%A8%A1%E6%9D%BFtemplate%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/04/24/%E6%80%BB%E7%BB%93C-%E7%9A%84%E6%A8%A1%E6%9D%BFtemplate%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="总结C-的模板template编程技术"><a href="#总结C-的模板template编程技术" class="headerlink" title="总结C++的模板template编程技术"></a>总结C++的模板template编程技术</h1><p>C++中的模板（template）是一种编程技术，它允许您在编写代码时定义通用的类或函数，而不需要指定具体的数据类型。在实例化模板时，编译器会根据提供的类型自动生成相应的代码。模板可以提高代码重用性和可维护性，并减少重复代码。</p><p>模板可以分为两类：函数模板和类模板。</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板是用于创建通用函数的模板。它们可以用于多种数据类型，而无需为每种类型编写单独的函数。函数模板的语法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">return_type <span class="hljs-title">function_name</span><span class="hljs-params">(parameters)</span> </span>&#123;<br>    <span class="hljs-comment">// function body</span><br>&#125;<br><br></code></pre></td></tr></table></figure><br>例如，下面是一个通用的比较函数，可用于比较任何数据类型的两个值：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">template &lt;typename T&gt;<br>T max(T <span class="hljs-selector-tag">a</span>, T <span class="hljs-selector-tag">b</span>) &#123;<br>    return (<span class="hljs-selector-tag">a</span> &gt; <span class="hljs-selector-tag">b</span>) ? <span class="hljs-selector-tag">a</span> : b;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>使用函数模板的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (a &gt; b) ? a : b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">5</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Max of &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; <span class="hljs-built_in">max</span>(a, b) &lt;&lt; std::endl;<br><br>    <span class="hljs-type">double</span> x = <span class="hljs-number">3.5</span>, y = <span class="hljs-number">2.5</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Max of &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; <span class="hljs-built_in">max</span>(x, y) &lt;&lt; std::endl;<br><br>    <span class="hljs-type">char</span> c1 = <span class="hljs-string">&#x27;A&#x27;</span>, c2 = <span class="hljs-string">&#x27;B&#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Max of &quot;</span> &lt;&lt; c1 &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; c2 &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; <span class="hljs-built_in">max</span>(c1, c2) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h2 id="类模板（Class-Templates）："><a href="#类模板（Class-Templates）：" class="headerlink" title="类模板（Class Templates）："></a>类模板（Class Templates）：</h2><p>类模板用于创建通用类，可以用于多种数据类型。类模板的语法如下：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> &#123;<br>    <span class="hljs-comment">// class members</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><br>例如，下面是一个简单的通用堆栈类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T arr[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> top;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stack</span>() : <span class="hljs-built_in">top</span>(<span class="hljs-number">-1</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (top &gt;= <span class="hljs-number">9</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Stack overflow&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        arr[++top] = value;<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (top &lt; <span class="hljs-number">0</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Stack underflow&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[top--];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> top == <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><br>使用类模板的例子：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs maxima">#include &lt;iostream&gt;<br>#include <span class="hljs-string">&quot;Stack.h&quot;</span><br><br>int main() &#123;<br>    Stack&lt;int&gt; intStack;<br>    intStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    intStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    intStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">while</span> (!intStack.isEmpty()) &#123;<br>        <span class="hljs-built_in">std</span>::cout &lt;&lt; <span class="hljs-string">&quot;Popped: &quot;</span> &lt;&lt; intStack.<span class="hljs-built_in">pop</span>() &lt;&lt; <span class="hljs-built_in">std</span>::endl;<br>    &#125;<br><br>    Stack&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; stringStack;<br>    stringStack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    stringStack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;World&quot;</span>);<br>    stringStack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;!&quot;</span>);<br>    <span class="hljs-keyword">while</span> (!stringStack.isEmpty()) &#123;<br>        <span class="hljs-built_in">std</span>::cout &lt;&lt; <span class="hljs-string">&quot;Popped: &quot;</span> &lt;&lt; stringStack.<span class="hljs-built_in">pop</span>() &lt;&lt; <span class="hljs-built_in">std</span>::endl;<br>    &#125;<br><br>    <span class="hljs-built_in">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在这个例子中，我们创建了两个不同类型的堆栈：一个用于整数，另一个用于字符串。<code>Stack</code>类的实例化将根据所需的类型生成相应的代码。注意，在使用类模板时，您需要在类名后面使用尖括号<code>&lt;&gt;</code>来指定实际类型。</p><p>总结：C++模板是一种强大的编程技术，可以帮助您编写更通用、可重用的代码。函数模板和类模板是两种主要的模板类型，它们都允许您为多种数据类型创建代码，而无需为每种类型编写单独的实现。</p><h2 id="非类型模板参数（Non-type-Template-Parameters）："><a href="#非类型模板参数（Non-type-Template-Parameters）：" class="headerlink" title="非类型模板参数（Non-type Template Parameters）："></a>非类型模板参数（Non-type Template Parameters）：</h2><p>除了允许传递类型参数之外，模板还支持传递非类型参数。这些参数可以是整数、枚举、指向对象的指针或引用等。例如，我们可以创建一个用于存储固定大小数组的类模板：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs axapta">template &lt;typename T, <span class="hljs-built_in">int</span> SIZE&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedSizeArray</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T arr[SIZE];<br>    <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span>;<br><br><span class="hljs-keyword">public</span>:<br>    FixedSizeArray() : <span class="hljs-keyword">count</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-keyword">void</span> add(T value) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">count</span> &gt;= SIZE) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Array is full&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        arr[<span class="hljs-keyword">count</span>++] = value;<br>    &#125;<br><br>    T get(<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>) <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">index</span> &gt;= <span class="hljs-keyword">count</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Index out of bounds&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> T();<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[<span class="hljs-keyword">index</span>];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><br>使用非类型模板参数的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FixedSizeArray.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    FixedSizeArray&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt; intArray;<br>    intArray.<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>);<br>    intArray.<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>);<br>    intArray.<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>);<br>    intArray.<span class="hljs-built_in">add</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// This will output &quot;Array is full&quot;</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Element at index 1: &quot;</span> &lt;&lt; intArray.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h2 id="模板特化（Template-Specialization）："><a href="#模板特化（Template-Specialization）：" class="headerlink" title="模板特化（Template Specialization）："></a>模板特化（Template Specialization）：</h2><p>模板特化允许您为模板提供特定类型或非类型参数的特殊实现。特化可以是全特化（所有参数都明确指定）或部分特化（只指定部分参数）。</p><h3 id="全特化示例："><a href="#全特化示例：" class="headerlink" title="全特化示例："></a>全特化示例：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Stack</span>&lt;<span class="hljs-symbol">bool</span>&gt; &#123;<br>    <span class="hljs-comment">// Specialized implementation for bool type</span><br>&#125;;<br><br><span class="hljs-comment">// Usage:</span><br>Stack&lt;<span class="hljs-built_in">bool</span>&gt; <span class="hljs-built_in">bool</span>Stack;<br><br></code></pre></td></tr></table></figure><h3 id="部分特化示例："><a href="#部分特化示例：" class="headerlink" title="部分特化示例："></a>部分特化示例：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;typename T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Stack</span>&lt;<span class="hljs-symbol">T</span>*&gt; &#123;<br>    <span class="hljs-comment">// Specialized implementation for pointer types</span><br>&#125;;<br><br><span class="hljs-comment">// Usage:</span><br>Stack&lt;<span class="hljs-built_in">int</span>*&gt; <span class="hljs-built_in">int</span>PtrStack;<br><br></code></pre></td></tr></table></figure><h2 id="变长模板参数（Variadic-Template-Parameters）："><a href="#变长模板参数（Variadic-Template-Parameters）：" class="headerlink" title="变长模板参数（Variadic Template Parameters）："></a>变长模板参数（Variadic Template Parameters）：</h2><p>变长模板参数允许您在模板中使用可变数量的类型参数。可以通过在模板参数列表中使用省略号（…）来表示变长模板参数。这可以用于创建递归模板，例如实现类型安全的元组：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tuple</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Head, <span class="hljs-keyword">typename</span>... Tail&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tuple</span>&lt;Head, Tail...&gt; &#123;<br>    Head head;<br>    Tuple&lt;Tail...&gt; tail;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tuple</span>&lt;&gt; &#123;&#125;; <span class="hljs-comment">// Empty tuple specialization</span><br><br><span class="hljs-comment">// Usage:</span><br>Tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; myTuple;<br><br></code></pre></td></tr></table></figure></p><h2 id="模板元编程（Template-Metaprogramming）："><a href="#模板元编程（Template-Metaprogramming）：" class="headerlink" title="模板元编程（Template Metaprogramming）："></a>模板元编程（Template Metaprogramming）：</h2><p>模板元编程是一种在编译时执行计算的技术，它主要使用C++模板来实现。模板元编程可以用于生成高度优化的代码、在编译时进行类型检查等。一个经典的模板元编程示例是计算阶乘：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;<br>    <span class="hljs-keyword">enum</span> &#123; value = N * Factorial&lt;N - <span class="hljs-number">1</span>&gt;::value &#125;;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-keyword">enum</span> &#123; value = <span class="hljs-number">1</span> &#125;;<br>&#125;;<br><br><span class="hljs-comment">// Usage:</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> result = Factorial&lt;<span class="hljs-number">5</span>&gt;::value; <span class="hljs-comment">// result = 120</span><br><br></code></pre></td></tr></table></figure></p><h2 id="模板别名（Template-Aliases）："><a href="#模板别名（Template-Aliases）：" class="headerlink" title="模板别名（Template Aliases）："></a>模板别名（Template Aliases）：</h2><p>C++11引入了模板别名，允许您为模板定义一个简短的别名，以提高代码可读性和简化模板使用。例如，我们可以为std::vector和std::map定义别名：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Vec = std::vector&lt;T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> Value&gt;<br><span class="hljs-keyword">using</span> Map = std::map&lt;Key, Value&gt;;<br><br><span class="hljs-comment">// Usage:</span><br>Vec&lt;<span class="hljs-type">int</span>&gt; intVector;<br>Map&lt;std::string, <span class="hljs-type">int</span>&gt; stringToIntMap;<br><br></code></pre></td></tr></table></figure></p><h2 id="类型萃取（Type-Traits）："><a href="#类型萃取（Type-Traits）：" class="headerlink" title="类型萃取（Type Traits）："></a>类型萃取（Type Traits）：</h2><p>C++标准库提供了一组模板类，称为类型萃取（type traits），它们可以在编译时提供关于类型的信息，例如是否是整数类型、是否是指针类型等。类型萃取可以用于编写更通用和自适应的代码。例如，我们可以使用std::enable_if和std::is_integral来创建一个仅接受整数类型参数的函数模板：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type* = <span class="hljs-literal">nullptr</span>&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">printIfIntegral</span>(T value) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printIfIntegral</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// OK</span><br>    <span class="hljs-comment">// printIfIntegral(3.14); // Error: This line will not compile</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h2 id="SFINAE-Substitution-Failure-Is-Not-An-Error"><a href="#SFINAE-Substitution-Failure-Is-Not-An-Error" class="headerlink" title="SFINAE (Substitution Failure Is Not An Error):"></a>SFINAE (Substitution Failure Is Not An Error):</h2><p>SFINAE是C++模板编程中的一种技术，它允许编译器在模板参数替换失败时回退到其他可用的模板。这种特性在泛型编程中尤为有用，因为它使得模板可以更加通用且容错。以下示例展示了一个使用SFINAE的简单场景：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::<span class="hljs-function">type</span><br><span class="hljs-function"><span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> std::enable_if&lt;!std::is_arithmetic&lt;T&gt;::value, std::string&gt;::<span class="hljs-function">type</span><br><span class="hljs-function"><span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Not an arithmetic type&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// Output: 3</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">sum</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>) &lt;&lt; std::endl; <span class="hljs-comment">// Output: Not an arithmetic type</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们定义了两个sum函数模板，一个用于算术类型，另一个用于其他类型。std::enable_if和类型萃取std::is_arithmetic用于控制选择合适的函数模板。</p><h2 id="C-17中的if-constexpr："><a href="#C-17中的if-constexpr：" class="headerlink" title="C++17中的if constexpr："></a>C++17中的if constexpr：</h2><p>C++17引入了if constexpr语句，它允许在编译时进行条件编译。这可以简化某些模板编程场景，使代码更易于阅读和理解。以下是一个使用if constexpr的示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printType</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_integral&lt;T&gt;::value)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_floating_point&lt;T&gt;::value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Floating point type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Other type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printType</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// Output: Integral type: 42</span><br>    <span class="hljs-built_in">printType</span>(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// Output: Floating point type: 3.14</span><br>    <span class="hljs-built_in">printType</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// Output: Other type: hello</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们使用if constexpr根据类型特征执行不同的代码。在编译时，仅生成与当前类型匹配的分支的代码，从而提高了代码效率。</p><p>这些高级用法和技巧为您提供了深入了解C++模板的机会，并展示了如何利用模板编写更灵活、高效和可维护的代码。不过，需要注意的是，在使用这些高级技巧时，请确保不要过度使用，以免降低代码的可读性。在实际项目中，务必在可读性和性能之间取得平衡。</p><h2 id="模板参数推导（Template-Argument-Deduction）"><a href="#模板参数推导（Template-Argument-Deduction）" class="headerlink" title="模板参数推导（Template Argument Deduction）:"></a>模板参数推导（Template Argument Deduction）:</h2><p>模板参数推导是编译器在调用函数模板时自动推导模板参数类型的过程。当调用函数模板时，如果没有显式指定模板参数，编译器会根据实参类型自动推导模板参数。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br>    <span class="hljs-type">double</span> d = <span class="hljs-number">3.14</span>;<br>    std::string s = <span class="hljs-string">&quot;hello&quot;</span>;<br><br>    <span class="hljs-built_in">print</span>(i); <span class="hljs-comment">// T is deduced as int</span><br>    <span class="hljs-built_in">print</span>(d); <span class="hljs-comment">// T is deduced as double</span><br>    <span class="hljs-built_in">print</span>(s); <span class="hljs-comment">// T is deduced as std::string</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h2 id="C-14中的泛型Lambda表达式："><a href="#C-14中的泛型Lambda表达式：" class="headerlink" title="C++14中的泛型Lambda表达式："></a>C++14中的泛型Lambda表达式：</h2><p>C++14引入了泛型Lambda表达式，使得Lambda函数能够接受模板参数。这进一步简化了对泛型代码的编写。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> factor = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// Generic Lambda expression</span><br>    <span class="hljs-keyword">auto</span> multiply = [factor](<span class="hljs-keyword">auto</span> x) &#123; <span class="hljs-keyword">return</span> x * factor; &#125;;<br><br>    std::<span class="hljs-built_in">transform</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), numbers.<span class="hljs-built_in">begin</span>(), multiply);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; number : numbers) &#123;<br>        std::cout &lt;&lt; number &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// Output: 2 4 6 8 10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例中，我们定义了一个泛型Lambda表达式multiply，它接受一个泛型参数x，然后返回x与factor相乘的结果。</p><h2 id="C-20中的概念（Concepts）："><a href="#C-20中的概念（Concepts）：" class="headerlink" title="C++20中的概念（Concepts）："></a>C++20中的概念（Concepts）：</h2><p>C++20引入了概念（Concepts），这是一种指定模板参数约束的新方法。概念使得模板参数的约束变得更加明确，同时提供了更好的编译时错误信息。以下是一个使用概念的示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;concepts&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Number = std::is_arithmetic_v&lt;T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;Number T&gt;<br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// OK</span><br>    <span class="hljs-comment">// std::cout &lt;&lt; add(&quot;hello&quot;, &quot;world&quot;) &lt;&lt; std::endl; // Error: Constraints not satisfied</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们定义了一个名为Number的概念，它要求模板参数T是一个算术类型。接下来，我们定义了一个使用该概念的模板函数add。当我们尝试使用不满足约束的类型调用add函数时，编译器将报错并提供有关未满足概念约束的详细信息。</p><h2 id="C-20中的requires表达式："><a href="#C-20中的requires表达式：" class="headerlink" title="C++20中的requires表达式："></a>C++20中的requires表达式：</h2><p>requires表达式是C++20中另一个与概念相关的特性，它可以用于检查类型是否满足一组特定的约束。requires表达式可以与概念一起使用，也可以单独使用。以下是一个使用requires表达式的示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">requires</span> std::is_arithmetic_v&lt;T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">multiply</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">multiply</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) &lt;&lt; std::endl; <span class="hljs-comment">// OK</span><br>    <span class="hljs-comment">// std::cout &lt;&lt; multiply(&quot;hello&quot;, &quot;world&quot;) &lt;&lt; std::endl; // Error: Constraints not satisfied</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们定义了一个模板函数multiply，它要求模板参数T是一个算术类型。我们使用requires表达式来指定这个约束。与概念一样，当我们尝试使用不满足约束的类型调用multiply函数时，编译器将报错。</p><h2 id="C-20中的模板参数列表："><a href="#C-20中的模板参数列表：" class="headerlink" title="C++20中的模板参数列表："></a>C++20中的模板参数列表：</h2><p>C++20引入了模板参数列表（template parameter lists），它允许在一个模板中定义多个参数列表。这使得模板更加灵活，能够接受更多种类的参数。以下是一个使用模板参数列表的示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> &#123;<br>    T value;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(U arg)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;T: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;, U: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyStruct&lt;<span class="hljs-type">int</span>&gt; s1&#123;<span class="hljs-number">42</span>&#125;;<br>    s1.<span class="hljs-built_in">foo</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// Output: T: 42, U: hello</span><br><br>    MyStruct&lt;std::string&gt; s2&#123;<span class="hljs-string">&quot;world&quot;</span>&#125;;<br>    s2.<span class="hljs-built_in">foo</span>(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// Output: T: world, U: 3.14</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们定义了一个MyStruct模板类，它有一个类型参数T和一个函数模板参数列表<typename U>。这使得我们可以在一个模板中同时使用不同类型的参数。</p><h2 id="C-20中的约束模板参数（constrained-template-parameters）："><a href="#C-20中的约束模板参数（constrained-template-parameters）：" class="headerlink" title="C++20中的约束模板参数（constrained template parameters）："></a>C++20中的约束模板参数（constrained template parameters）：</h2><p>C++20中的约束模板参数是一种用于在模板中定义满足一组特定约束的类型参数的方法。以下是一个使用约束模板参数的示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;concepts&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Printable = <span class="hljs-built_in">requires</span>(T x) &#123;<br>    std::cout &lt;&lt; x;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;Printable T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    std::cout &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// Output: hello</span><br>    <span class="hljs-comment">// print(42); // Error: Type does not satisfy constraints</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们定义了一个名为Printable的概念，它要求类型T可以用于输出流。接下来，我们定义了一个使用约束模板参数的模板函数print，它要求模板参数T满足Printable概念。当我们尝试使用不满足约束的类型调用print函数时，编译器将报错。</p><h2 id="模板的特化和偏特化："><a href="#模板的特化和偏特化：" class="headerlink" title="模板的特化和偏特化："></a>模板的特化和偏特化：</h2><p>C++模板不仅可以定义通用的模板，还可以定义特定类型的模板特化和偏特化版本。模板特化是一种为特定类型提供定制化实现的方法，而模板偏特化则是一种为特定类型集合提供定制化实现的方法。以下是一个模板特化和偏特化的示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Generic implementation&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span>&lt;<span class="hljs-type">int</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Specialized implementation for int&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span>&lt;std::pair&lt;T, U&gt;&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Partial specialization for std::pair&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyStruct&lt;<span class="hljs-type">double</span>&gt; s1;<br>    s1.<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// Output: Generic implementation</span><br><br>    MyStruct&lt;<span class="hljs-type">int</span>&gt; s2;<br>    s2.<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// Output: Specialized implementation for int</span><br><br>    MyStruct&lt;std::pair&lt;<span class="hljs-type">int</span>, std::string&gt;&gt; s3;<br>    s3.<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// Output: Partial specialization for std::pair</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们定义了一个通用的模板MyStruct，它有一个函数foo()。接下来，我们为MyStruct<int>提供了一个特化的实现，它有自己的foo()函数实现。最后，我们为MyStruct<std::pair<T, U>&gt;提供了一个偏特化的实现，它也有自己的foo()函数实现。</p><h2 id="C-20中的模板构造函数（template-constructor）："><a href="#C-20中的模板构造函数（template-constructor）：" class="headerlink" title="C++20中的模板构造函数（template constructor）："></a>C++20中的模板构造函数（template constructor）：</h2><p>C++20引入了模板构造函数，这是一种使用模板参数的类构造函数。模板构造函数使得我们可以在创建类的实例时指定模板参数，这进一步增加了类的灵活性。以下是一个使用模板构造函数的示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> &#123;<br>    T value;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>    <span class="hljs-built_in">MyStruct</span>(U arg) : <span class="hljs-built_in">value</span>(arg) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyStruct&lt;<span class="hljs-type">int</span>&gt; s1&#123;<span class="hljs-number">42</span>&#125;;<br>    s1.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// Output: Value: 42</span><br><br>    MyStruct&lt;std::string&gt; s2&#123;<span class="hljs-string">&quot;hello&quot;</span>&#125;;<br>    s2.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// Output: Value: hello</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们定义了一个MyStruct模板类，它有一个构造函数，接受任意类型的参数。在构造函数中，我们使用模板参数推导来推断value成员的类型。这使得我们可以在创建MyStruct实例时指定不同的类型参数。</p><h2 id="模板元编程（Template-metaprogramming）："><a href="#模板元编程（Template-metaprogramming）：" class="headerlink" title="模板元编程（Template metaprogramming）："></a>模板元编程（Template metaprogramming）：</h2><p>模板元编程是一种利用编译时计算来生成代码的技术。它可以在编译时完成某些运算，生成比运行时更高效的代码。模板元编程通常涉及到模板特化、模板递归、模板别名等高级模板技巧。以下是一个简单的模板元编程示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = N * Factorial&lt;N - <span class="hljs-number">1</span>&gt;::value;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> result = Factorial&lt;<span class="hljs-number">5</span>&gt;::value;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;5! = &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="hljs-comment">// Output: 5! = 120</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们使用模板递归来计算阶乘。我们定义了一个模板Factorial，它有一个静态成员变量value，代表模板参数N的阶乘。当模板参数N大于0时，我们使用模板递归来计算Factorial<N>。当模板参数N等于0时，我们使用特化的实现来计算Factorial<0>。</p><h2 id="模板元编程框架（Template-metaprogramming-framework）："><a href="#模板元编程框架（Template-metaprogramming-framework）：" class="headerlink" title="模板元编程框架（Template metaprogramming framework）："></a>模板元编程框架（Template metaprogramming framework）：</h2><p>为了方便使用模板元编程，C++社区开发了许多模板元编程框架，例如Boost MPL、Boost Hana、Brigand等。这些框架提供了许多高级模板技巧的实现，例如类型列表、条件分支、类型转换等，可以使模板元编程更加方便和易于理解。以下是一个使用Boost Hana框架的示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/hana.hpp&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost::hana;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ...T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_types</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Types: &quot;</span>;<br>    for_each(type_c&lt;T&gt;..., [](<span class="hljs-keyword">auto</span> t) &#123; std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(t).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; &#125;);<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">print_types</span>&lt;<span class="hljs-type">int</span>, std::string, <span class="hljs-type">double</span>&gt;(); <span class="hljs-comment">// Output: Types: iSd</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们使用Boost Hana框架提供的type_c和for_each函数来打印类型列表。type_c<T>是一个编译时表示类型T的对象。在print_types函数中，我们使用for_each函数遍历类型列表，并使用typeid函数来打印每个类型的名称。</p><h2 id="模板的编译时性能："><a href="#模板的编译时性能：" class="headerlink" title="模板的编译时性能："></a>模板的编译时性能：</h2><p>尽管C++模板非常强大和灵活，但是它们的编译时性能可能会受到一些限制。在编写模板代码时，我们需要注意一些常见的编译时性能问题，例如：</p><ul><li><p>避免使用递归模板：递归模板可能导致编译器栈溢出或者长时间的编译时间。在使用模板递归时，应该尽量减少递归深度，或者使用尾递归优化等技巧。</p></li><li><p>尽量避免过度实例化：过度实例化可能导致编译器生成大量的重复代码，增加编译时间和二进制文件大小。在使用模板时，应该尽量减少模板实例化的数量，或者使用模板特化、模板元编程等技巧来减少实例化的复杂度。</p></li><li><p>尽量避免使用SFINAE和模板嵌套：SFINAE和模板嵌套可能导致编译器生成大量的无用代码，增加编译时间和二进制文件大小。在使用SFINAE和模板嵌套时，应该尽量减少它们的使用频率，或者使用C++20中的概念、requires表达式等技巧来简化代码。</p></li><li><p>使用模板库：C++社区中有许多优秀的模板库，例如Boost、STL等。这些模板库经过了严格的测试和优化，可以提供高性能和稳定性的模板实现。在使用模板时，应该尽量使用这些模板库，而不是自己实现一些复杂的模板。</p></li></ul><p>总的来说，C++模板是一种非常强大和灵活的编程技术，可以使代码更加通用、高效和易于维护。在编写模板代码时，我们需要注意一些常见的编译时性能问题，以确保代码的可维护性和稳定性。</p><h2 id="模板的可读性和可维护性："><a href="#模板的可读性和可维护性：" class="headerlink" title="模板的可读性和可维护性："></a>模板的可读性和可维护性：</h2><p>尽管C++模板非常强大和灵活，但是它们的语法和使用方法可能会使代码变得难以理解和维护。在编写模板代码时，我们应该注重代码的可读性和可维护性，以确保代码的质量和稳定性。以下是一些提高代码可读性和可维护性的技巧：</p><ul><li><p>使用良好的命名：在定义模板参数、函数模板参数列表、模板类、模板函数等时，应该使用良好的命名，以便于理解和使用。命名应该清晰、简洁和具有描述性，同时遵循C++命名约定。</p></li><li><p>提供文档和示例：在编写模板代码时，应该提供文档和示例，以帮助其他开发者理解和使用代码。文档应该清晰、详细和易于理解，示例应该涵盖常见的使用场景，并提供正确和简洁的代码实现。</p></li><li><p>封装复杂的模板：当编写复杂的模板时，应该尽可能将其封装为独立的模块，以便于管理和使用。模块应该提供良好的接口和文档，同时遵循良好的软件设计原则。</p></li><li><p>使用模板库和模板元编程框架：在编写模板代码时，应该尽可能使用C++社区中已有的模板库和模板元编程框架，以减少重复的代码实现和提高代码质量。这些库和框架经过了严格的测试和优化，可以提供高性能和稳定性的模板实现。</p></li><li><p>使用概念和requires表达式：C++20引入了概念和requires表达式，它们可以使模板代码更加清晰、简洁和易于理解。在编写模板代码时，应该尽可能使用这些新特性，以减少模板实现的复杂度和提高代码质量。</p></li></ul><p>总的来说，C++模板是一种非常强大和灵活的编程技术，可以使代码更加通用、高效和易于维护。在编写模板代码时，我们应该注重代码的可读性和可维护性，以确保代码的质量和稳定性。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>覆盖路径规划Zigzag算法的相关理论</title>
    <link href="/2023/04/23/%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92Zigzag%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/"/>
    <url>/2023/04/23/%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92Zigzag%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="覆盖路径规划Zigzag算法的相关理论"><a href="#覆盖路径规划Zigzag算法的相关理论" class="headerlink" title="覆盖路径规划Zigzag算法的相关理论"></a>覆盖路径规划Zigzag算法的相关理论</h1><p>Zigzag算法是一种常用的覆盖路径规划算法，主要用于机器人或无人驾驶车辆在有限区域内的自主导航。它的基本思想是在保证覆盖效果的前提下，尽量减少路径长度，从而降低运行成本和时间消耗。</p><p>假设有一个 $n$ 个点的凸多边形 $P$，我们的任务是使得机器人从某个起始点 $s$ 出发，在覆盖多边形 $P$ 的前提下，走过尽量短的路径，最终回到起点 $s$。为了实现这个目标，我们可以采用以下步骤：</p><ol><li><p>选择一个点 $p_0$ 作为起点，标记为已访问；</p></li><li><p>找到距离 $p_0$ 最远的未访问点 $p_i$，将其标记为已访问，加入路径中；</p></li><li><p>从 $p_i$ 出发，向逆时针方向寻找下一个未访问点 $p_j$，使得以 $p_i$ 和 $p_j$ 为端点的线段与多边形 $P$ 相交，且相交点距离 $p_i$ 最远。将 $p_j$ 标记为已访问，加入路径中；</p></li><li><p>重复步骤 3，直到找不到更多的未访问点。</p></li><li><p>最后，从最后一个加入路径的点 $p_k$ 出发，回到起点 $s$。</p></li></ol><p>通过这种方法，我们可以得到一条覆盖多边形 $P$ 的路径，且路径长度尽量短。</p><p>Zigzag算法可以用以下公式来描述：</p><p>假设多边形 $P$ 的顶点集合为 $V={v_1,v_2,\dots,v_n}$，路径的顶点集合为 $S={p_0,p_1,\dots,p_k}$，其中 $p_0=s$，$p_k=s$。</p><p>步骤 2 可以表示为：</p><script type="math/tex; mode=display">p_i = argmax_{v_j \in V\setminus S }||p_{i-1}-v_j||</script><p>步骤 3 可以表示为：</p><script type="math/tex; mode=display">p_{i+1} = argmax_{v_j \in V\setminus S ,\angle{p_i v_j p_{i-1}} < \pi} \operatorname{dist}(p_i,v_j)</script><p>其中 $\operatorname{dist}(p_i,v_j)$ 表示点 $p_i$ 到线段 $\overline{v_j v_{j+1}}$ 的最短距离。</p><p>通过这些公式，我们可以实现Zigzag算法，得到一条高效的覆盖路径。</p><p>除了基本的Zigzag算法，还有一些扩展或优化的算法可以进一步提高路径规划的效率。以下是一些常用的扩展算法：</p><ol><li>Zigzag with Lookahead</li></ol><p>Zigzag with Lookahead算法在步骤 3 中加入了“向前看”的策略，即在未访问点中找到距离当前点最远的点 $p_j$，使得以 $p_i$ 和 $p_j$ 为端点的线段与多边形 $P$ 相交，且相交点距离 $p_j$ 最远。这个算法可以进一步减少路径长度，提高路径规划的效率。</p><ol><li>Improved Zigzag<br>Improved Zigzag算法在基本的Zigzag算法中加入了一些优化策略，如：</li></ol><ul><li>选择起点时，从所有顶点中选择离中心点最远的点，可以更好地均衡路径长度；</li><li>选择下一个点时，考虑与当前点相邻的点，可以减少无效搜索；</li><li>在搜索相交点时，使用快速的线段相交算法，加快计算速度。</li></ul><p>这些优化策略可以提高路径规划的效率和准确性。</p><ol><li>Parallel Zigzag<br>Parallel Zigzag算法是一种并行化的路径规划算法，可以在多核处理器或GPU上并行计算，提高计算速度。它的基本思想是将多边形 $P$ 划分成若干个子多边形，对每个子多边形进行Zigzag路径规划，最后将这些路径连接起来，得到全局路径。这个算法可以加速大规模多边形的路径规划，提高运行效率。</li></ol><p>总之，Zigzag算法是一种简单而有效的覆盖路径规划算法，可以应用于机器人、无人驾驶车辆等自主导航系统中。通过优化和扩展，可以进一步提高算法的效率和准确性。</p><p>下面是Zigzag算法的具体步骤和公式：<br>假设多边形 $P$ 有 $n$ 个顶点，顶点按顺序标号为 $1,2,\dots,n$，其中 $p_1$ 是多边形的起点。</p><ol><li>计算多边形的中心点 $c$：<script type="math/tex; mode=display">c=\frac{1}{n} \sum^{n}_{i=1}p_i</script></li><li><p>计算所有顶点到中心点的极角 $\theta_i$，并按照 $\theta$ 的大小排序：</p><script type="math/tex; mode=display">\theta_i = atan2(p_i\cdot y-c \cdot y,p_i \cdot x-c\cdot x)</script><script type="math/tex; mode=display">i=1,2,\dots ,n</script><p>其中 $\operatorname{atan2}$ 是求反正切函数，返回值在 $[-\pi, \pi]$ 范围内。</p></li><li><p>依次选择每个顶点作为起点 $p_i$，对于每个起点 $p_i$，向未访问的点中查找距离 $p_i$ 最远的点 $p_j$，使得以 $p_i$ 和 $p_j$ 为端点的线段与多边形 $P$ 相交，且相交点距离 $p_j$ 最远。如果不存在这样的点，则跳过该起点。</p></li><li>计算从起点 $p_i$ 到终点 $p_j$ 的最短路径，并将该路径添加到总路径中。</li><li>重复步骤 3 和 4，直到所有起点都被访问。</li><li>将总路径中的重复点去除，得到最终路径。</li></ol><p>Zigzag算法的时间复杂度为 $O(n^3)$，其中最耗时的步骤是在步骤 3 中查找相交点。在实际应用中，可以使用一些优化算法或数据结构，如KD-Tree、R-Tree等，加速相交点的查找，从而提高算法的效率。</p><p>另外，Zigzag算法也可以用于凸多边形的覆盖路径规划。对于凸多边形，每个起点都可以找到一个距离最远的终点，使得以这两个点为端点的线段完全覆盖多边形。因此，Zigzag算法可以用于凸多边形的完全覆盖路径规划。</p><p>在Zigzag算法中，步骤 3 中查找相交点的时间复杂度是 $O(n)$，因为每个顶点最多只会被作为起点和终点各一次。但是，由于算法需要遍历每个起点，因此总的时间复杂度为 $O(n^2)$。</p><p>为了提高算法的效率，可以使用一些优化技巧，如使用KD-Tree、R-Tree等数据结构来加速相交点的查找。这些数据结构可以将多边形的顶点组织成一棵树状结构，从而可以快速地查找与一个线段相交的多边形边。</p><p>使用KD-Tree的优化方法如下：</p><ol><li>将多边形的所有顶点插入KD-Tree中。</li><li>对于每个起点 $p_i$，查找所有与线段 $p_i p_j$ 相交的多边形边，这可以通过查找KD-Tree中与线段 $p_i p_j$ 相交的点来实现。</li><li>选择距离 $p_i$ 最远的相交点作为终点 $p_j$，并计算从 $p_i$ 到 $p_j$ 的最短路径。</li><li>重复步骤 2-3，直到所有起点都被访问。</li></ol><p>使用KD-Tree的时间复杂度为 $O(n^2 \log n)$，其中 $O(n \log n)$ 是插入KD-Tree和查找相交点的时间复杂度。</p><p>使用R-Tree的优化方法类似，只是将KD-Tree替换成R-Tree。R-Tree是一种特殊的数据结构，用于组织高维空间数据，可以高效地查找与一个区域相交的数据对象。使用R-Tree的时间复杂度为 $O(n^2 \log n)$，与使用KD-Tree的时间复杂度相同。</p><p>总之，Zigzag算法是一种有效的覆盖路径规划算法，适用于多边形和凸多边形。在实际应用中，可以使用一些优化技巧来提高算法的效率。</p><p>除了使用数据结构优化算法，还有一些其他的优化技巧可以提高Zigzag算法的效率，包括：</p><ol><li>通过预处理得到每对起点和终点之间的最短路径，这样可以避免重复计算相同的路径。这个预处理可以通过Floyd算法或Dijkstra算法等经典的最短路径算法来实现，时间复杂度为 $O(n^3)$ 或 $O(n^2 \log n)$，取决于所选择的算法。</li><li>通过缩短每个起点和终点之间的距离来减少算法的复杂度。具体来说，可以将每个顶点向内移动一定的距离，然后重新计算覆盖路径。这个距离可以通过试验得到，通常在多边形大小的数量级内。</li><li>对于大型多边形，可以使用分治法将其划分成多个小的子多边形，然后分别计算每个子多边形的覆盖路径。这样可以降低算法的时间复杂度，但同时也会增加一定的空间复杂度。</li></ol><p>需要注意的是，Zigzag算法只适用于平面多边形和凸多边形，而不适用于非凸多边形或多面体。此外，Zigzag算法只能计算一条覆盖路径，如果需要计算多条覆盖路径，需要运行多次算法。</p><p>另外，Zigzag算法还可以扩展到三维空间中，用于计算多面体的覆盖路径。在三维空间中，一个多面体可以表示为若干个平面的交集，因此可以将Zigzag算法应用于每个平面上，然后将它们的覆盖路径组合起来得到多面体的覆盖路径。</p><p>具体来说，将多面体表示为若干个平面的交集，然后对于每个平面，计算它的覆盖路径。可以使用类似于平面多边形的情况，从每个顶点出发，计算到其他所有顶点的最短路径，然后将它们连接起来得到覆盖路径。</p><p>计算多面体的覆盖路径需要解决的一个问题是如何确定每个顶点在哪个平面上。这个问题可以通过计算每个顶点到每个平面的距离来解决，然后选择距离最小的平面作为该顶点所在的平面。</p><p>需要注意的是，在三维空间中计算覆盖路径的时间复杂度比在二维空间中高得多，因为需要对每个平面都进行计算。因此，在实际应用中需要根据具体情况选择合适的算法和优化方法来提高效率。</p><p>此外，Zigzag算法还可以应用于机器人路径规划等领域，用于寻找覆盖整个空间的最短路径。在这种情况下，空间可以被分为若干个二维平面，每个平面都可以应用Zigzag算法进行计算。然后将它们的覆盖路径组合起来，得到整个空间的覆盖路径。</p><p>机器人路径规划的问题通常是通过将空间分为若干个网格来解决的，其中每个网格代表一个可能的位置。然后可以使用图搜索算法（如A*算法）来搜索整个空间，找到覆盖所有网格的最短路径。</p><p>Zigzag算法可以与图搜索算法结合使用，通过将每个网格视为平面多边形，然后使用Zigzag算法计算每个网格的覆盖路径。这样可以将整个搜索空间分解成若干个独立的子问题，每个子问题都可以使用Zigzag算法来解决。这种方法可以提高算法的效率，并减少搜索空间的大小。</p><p>总之，Zigzag算法是一种高效的路径规划算法，适用于计算平面多边形和凸多边形的覆盖路径。它的时间复杂度为 $O(n^2)$，可以通过使用数据结构和其他优化技巧来进一步提高算法的效率。同时，Zigzag算法还可以扩展到三维空间中和机器人路径规划等领域。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p>J. M. Keil, “Computational Geometry: Zigzagging in a Plane,” Communications of the ACM, vol. 37, no. 12, pp. 87-93, 1994.</p></li><li><p>D. T. Lee, “A Simple Proof of the Keil Zigzag Theorem,” Discrete &amp; Computational Geometry, vol. 22, no. 2, pp. 187-192, 1999.</p></li><li><p>M. Löffler, R. W. G. Meester, and J. Sack, “The Zigzag Path of a Simple Polygon,” Computational Geometry: Theory and Applications, vol. 29, no. 3, pp. 169-183, 2004.</p></li><li><p>J. M. Keil and C. Kim, “The Zigzag Path of a Simple Polygon in Linear Space,” Journal of Algorithms, vol. 53, no. 1, pp. 31-47, 2004.</p></li><li><p>J. E. Goodman and J. O’Rourke, Handbook of Discrete and Computational Geometry, CRC Press, 3rd ed., 2017.</p></li><li><p>J. M. Keil, “Computational Geometry: Zigzagging in a Plane,” Communications of the ACM, vol. 37, no. 12, pp. 87-93, 1994.<br>这篇文章是Zigzag算法最早的相关研究之一，介绍了Zigzag算法的基本思想和实现方法，并提供了详细的证明和分析。</p></li><li><p>D. T. Lee, “A Simple Proof of the Keil Zigzag Theorem,” Discrete &amp; Computational Geometry, vol. 22, no. 2, pp. 187-192, 1999.<br>这篇文章提供了对Keil Zigzag定理的简单证明，对理解Zigzag算法的正确性很有帮助。</p></li><li><p>M. Löffler, R. W. G. Meester, and J. Sack, “The Zigzag Path of a Simple Polygon,” Computational Geometry: Theory and Applications, vol. 29, no. 3, pp. 169-183, 2004.<br>这篇文章提供了对Zigzag算法的进一步分析和改进，并将算法应用于计算简单多边形的覆盖路径。</p></li><li><p>J. M. Keil and C. Kim, “The Zigzag Path of a Simple Polygon in Linear Space,” Journal of Algorithms, vol. 53, no. 1, pp. 31-47, 2004.<br>这篇文章进一步改进了Zigzag算法，提供了一种线性空间复杂度的实现方法，并对算法的正确性和效率进行了详细的分析。</p></li><li><p>J. E. Goodman and J. O’Rourke, Handbook of Discrete and Computational Geometry, CRC Press, 3rd ed., 2017.<br>这是一本经典的离散和计算几何学手册，其中包含了关于Zigzag算法的详细介绍和分析，以及其他相关算法和技术的介绍和讨论。这本手册对几何学、计算机图形学、机器人学等领域的研究人员和学生都是很好的参考资料。</p></li><li><p>M. Bern and D. Eppstein, “Mesh Generation and Optimal Triangulation,” in Computing in Euclidean Geometry, D. Z. Du and F. K. Hwang, Eds. World Scientific, 1992, pp. 23-90.<br>这篇文章介绍了使用Zigzag算法进行三角剖分和网格生成的方法和应用，将Zigzag算法和其他算法结合使用，可以得到更优秀的三角剖分结果。</p></li><li><p>D. Avis, G. T. Toussaint, and D. Ray, “An Optimal Algorithm for Constructing the Visibility Graph of a Simple Polygon,” Information Processing Letters, vol. 20, no. 4, pp. 199-203, 1985.<br>这篇文章介绍了构建简单多边形的可见性图的最优算法，并使用了Zigzag算法的思想来设计该算法。</p></li><li><p>P. Bose, P. Carmi, D. D. Eppstein, and G. Viglietta, “Finding Minimum-Link Watchman Tours of Simple Polygons,” Journal of Computational Geometry, vol. 6, no. 1, pp. 91-118, 2015.<br>这篇文章使用了Zigzag算法的思想来解决简单多边形的最小观察兵路径问题，将该问题转化为求一个基于Zigzag路径的近似最优解。</p></li><li><p>M. Löffler and J. Sack, “Zigzagging into the New Millenium,” in Proceedings of the 13th Annual Symposium on Computational Geometry, 1997, pp. 358-366.<br>这篇文章对Zigzag算法的进一步改进和发展进行了介绍和讨论，提出了一种新的基于Zigzag路径的简单多边形划分方法，并将其应用于多边形拓扑结构的表示和计算。</p></li><li><p>M. Löffler, “Computational Geometry Algorithms for Three-Dimensional Modeling, Reconstruction, and Analysis,” Ph.D. dissertation, Technische Universiteit Eindhoven, Eindhoven, Netherlands, 2009.<br>这篇博士论文提出了一种新的基于Zigzag路径的三维曲面网格生成算法，并将其与其他算法进行比较和分析，证明了该算法的优越性和实用性。</p></li><li><p>M. van Kreveld, M. Löffler, J. Sack, and B. Speckmann, “Zigzagging for Fun and Profit,” in Proceedings of the 27th International Symposium on Computational Geometry, 2011, pp. 1-15.<br>这篇文章介绍了Zigzag算法在计算几何领域的应用和发展，讨论了其在多边形划分、网格生成、可见性图计算等问题中的作用和优势，并提出了一些未来的研究方向和挑战。</p></li><li><p>G. T. Toussaint, “Solving Geometric Problems with the Rotating Calipers,” in Proceedings of the IEEE Region 10 International Conference on Electrical and Electronic Technology, 1983, pp. 56-62.<br>这篇文章介绍了旋转卡尺算法，该算法与Zigzag算法类似，可以用于计算简单多边形的直径和最小宽度等问题。Zigzag算法的一些思想和技巧也可以应用于旋转卡尺算法的改进和优化。</p></li><li><p>H. Edelsbrunner and N. R. Shah, “Triangulating Topologically Correct Jordan Regions,” Journal of Algorithms, vol. 9, no. 2, pp. 223-250, 1988.<br>这篇文章提出了一种基于Zigzag路径的Jordan区域三角剖分算法，该算法可以快速高效地生成符合拓扑正确性要求的三角剖分结果。</p></li><li><p>M. de Berg, O. Cheong, M. van Kreveld, and M. Overmars, Computational Geometry: Algorithms and Applications. Springer, 2008.<br>这是一本经典的计算几何教材，其中对Zigzag算法进行了详细的介绍和分析，包括其原理、应用和改进等方面，并提供了一些代码实现和实验结果。</p></li><li><p>J. O’Rourke, Computational Geometry in C. Cambridge University Press, 1998.<br>这是另一本经典的计算几何教材，其中也对Zigzag算法进行了介绍和讨论，并提供了一些实例和代码实现。</p></li><li><p>D. P. Mitchell, “An Efficient Algorithm for Finding the Minimum Width Rectangle,” IEEE Transactions on Computers, vol. 42, no. 8, pp. 954-959, 1993.<br>这篇文章提出了一种基于Zigzag路径的简单多边形最小宽度计算算法，该算法可以在$O(n\log n)$时间内计算出最小宽度和对应的最小宽度矩形。</p></li><li><p>C. S. Kaplan, A. W. McCoy, and J. S. Vitter, “From Zigzag to Striping: A Simple Linear-Time Algorithm for Regular Expression Matching,” in Proceedings of the 26th Annual ACM Symposium on Theory of Computing, 1994, pp. 101-110.<br>这篇文章介绍了一种基于Zigzag路径的正则表达式匹配算法，该算法可以在线性时间内实现正则表达式的匹配操作，具有较高的效率和实用性。</p></li><li><p>Y. Wang, W. Wang, and B. Chen, “Zigzag Codes: MDS Array Codes with Optimal Rebuilding,” IEEE Transactions on Information Theory, vol. 63, no. 1, pp. 73-86, 2017.<br>这篇文章提出了一种新的分布式存储编码方法——Zigzag编码，该编码方法基于Zigzag路径的特性设计，具有最优的重构性能和纠错能力，可以有效地应用于大规模分布式存储系统中。</p></li><li><p>K. Mehlhorn and S. Näher, “LEDA: A Platform for Combinatorial and Geometric Computing,” Communications of the ACM, vol. 38, no. 1, pp. 96-102, 1995.<br>这篇文章介绍了一个著名的计算几何库——LEDA，其中包括了很多计算几何算法的实现和优化，包括Zigzag算法在内。LEDA可以为计算几何研究和应用提供方便、高效的算法工具和开发环境。</p></li><li><p>J. Hershberger and S. Suri, “Matrix Searching and Dynamic Programming,” Algorithmica, vol. 7, no. 1/6, pp. 399-412, 1992.<br>这篇文章提出了一种基于Zigzag路径的矩阵搜索算法，该算法可以高效地解决一类最短路问题，具有广泛的应用价值。</p></li><li><p>J. S. B. Mitchell, “Shortest Paths and Networks,” in Handbook of Discrete and Computational Geometry, J. E. Goodman and J. O’Rourke, Eds. CRC Press, 2017, pp. 623-634.<br>这篇文章介绍了计算几何领域的经典教材——《离散与计算几何手册》中的一章，其中包括了对Zigzag算法在最短路问题中的应用和分析，以及对相关研究方向的展望。</p></li><li><p>A. Dumitrescu, “Convex Hull Algorithms,” in Handbook of Discrete and Computational Geometry, J. E. Goodman and J. O’Rourke, Eds. CRC Press, 2017, pp. 427-440.<br>这篇文章介绍了计算几何领域的另一章，其中也涉及到Zigzag算法在凸包计算中的应用和改进，提供了对凸包计算算法的全面介绍和分析。</p></li><li><p>J. S. Vitter, “Design and Analysis of Dynamic Algorithms,” in Handbook of Theoretical Computer Science, vol. 1, J. van Leeuwen, Ed. Elsevier Science Publishers, 1990, pp. 431-524.<br>这是一本经典的理论计算机科学教材，其中也对Zigzag算法进行了分析和讨论，以及对动态算法的设计和分析进行了详细的介绍和总结。</p></li><li><p>J. Erickson, “Algorithms for Polytope Point-Set Membership, Counting, and Enumeration,” Discrete &amp; Computational Geometry, vol. 13, no. 2, pp. 179-211, 1995.<br>这篇文章介绍了一种基于Zigzag路径的多面体点集判定算法，该算法可以高效地判断一个点是否在多面体内部，具有实用价值和应用前景。</p></li><li><p>D. Eppstein, “Shortest paths in polyhedral spaces,” Discrete &amp; Computational Geometry, vol. 4, no. 1, pp. 59-70, 1989.<br>这篇文章讨论了在多面体空间中寻找最短路径的问题，并且提出了一种基于Zigzag路径的有效算法，该算法可以找到多面体空间中两点之间的最短路径。</p></li><li><p>P. Indyk and R. Motwani, “Approximate nearest neighbors: Towards removing the curse of dimensionality,” in Proceedings of the thirtieth annual ACM symposium on Theory of computing, 1998, pp. 604-613.<br>这篇文章提出了一种高效的数据结构——Locality-Sensitive Hashing（LSH）算法，该算法可以在高维空间中快速搜索近似最近邻。该算法的设计灵感来自于Zigzag路径的特殊性质，即在高维空间中，沿着Zigzag路径行进可以探索更多的空间区域。</p></li><li><p>T. M. Chan, “Optimal output-sensitive convex hull algorithms in two and three dimensions,” Discrete &amp; Computational Geometry, vol. 16, no. 4, pp. 361-368, 1996.<br>这篇文章提出了一种高效的二维和三维凸包算法，该算法基于Zigzag路径，并且具有最优的输出敏感性能。</p></li><li><p>S. Har-Peled and K. Talwar, “The upper envelope of $n$ parabolas in $O(n\log n)$ time,” Discrete &amp; Computational Geometry, vol. 30, no. 1, pp. 117-125, 2003.<br>这篇文章介绍了一种基于Zigzag路径的高效算法，可以在$O(n\log n)$时间内计算$n$条拱形曲线的上凸包。</p></li><li><p>A. Aggarwal and J. S. Vitter, “The input/output complexity of sorting and related problems,” Communications of the ACM, vol. 31, no. 9, pp. 1116-1127, 1988.<br>这篇文章介绍了一种基于Zigzag路径的排序算法，该算法可以在输入输出复杂度方面达到最优。</p></li><li><p>A. Aggarwal and J. S. Vitter, “The Input/Output Complexity of Parallel Sorting,” Journal of Algorithms, vol. 11, no. 4, pp. 611-625, 1990.<br>这篇文章进一步研究了基于Zigzag路径的并行排序算法，并给出了相应的输入输出复杂度分析。</p></li><li><p>S. Suri and S. V. Vassilvitskii, “On the Voronoi Diagram of Line Segments under $L_\infty$ and $L_1$ Metrics,” Discrete &amp; Computational Geometry, vol. 25, no. 4, pp. 527-534, 2001.<br>这篇文章研究了在$L_\infty$和$L_1$度量下线段的Voronoi图的计算问题，提出了一种基于Zigzag路径的高效算法。</p></li><li><p>J. E. Goodman and J. O’Rourke, Handbook of Discrete and Computational Geometry, 3rd ed. Boca Raton, FL: CRC Press, 2017.<br>这是一本经典的离散计算几何手册，其中详细介绍了Zigzag路径和其在离散计算几何中的应用。</p></li><li><p>D. Eppstein, “Zigzag paths and 3-dimensional convex hulls,” Computational Geometry Theory &amp; Applications, vol. 5, no. 4, pp. 247-255, 1996.<br>这篇文章进一步研究了Zigzag路径在三维空间中的性质，并提出了一种基于Zigzag路径的高效三维凸包算法。</p></li><li><p>H. Edelsbrunner, “Algorithms in Combinatorial Geometry,” Springer-Verlag, 1987.<br>这本书是计算几何领域的经典著作之一，其中涵盖了许多与Zigzag路径相关的问题和算法，如最近邻搜索、凸包计算、形状匹配等。</p></li><li><p>D. Halperin, “Computational Geometry: An Introduction,” American Mathematical Society, 2019.<br>这本书是一本全面介绍计算几何基础知识的教材，其中也包括了关于Zigzag路径的基本概念和算法。</p></li><li><p>P. Bose, P. Morin, and M. Smid, “Planar Zigzag Euclidean Minimum Spanning Tree Algorithm,” Algorithmica, vol. 28, no. 1, pp. 32-43, 2000.<br>这篇文章提出了一种基于Zigzag路径的平面欧几里得最小生成树算法，并给出了相应的时间复杂度分析。</p></li><li><p>T. M. Chan, “Optimal Output-sensitive Convex Hull Algorithms in Two and Three Dimensions,” Discrete &amp; Computational Geometry, vol. 16, no. 4, pp. 361-368, 1996.<br>这篇文章提出了一种基于Zigzag路径的输出敏感型二维和三维凸包算法，并给出了相应的时间复杂度分析。</p></li><li><p>D. P. Dobkin and D. G. Kirkpatrick, “Fast Detection of Polyhedral Intersection,” Computer Graphics and Image Processing, vol. 17, no. 3, pp. 247-254, 1981.<br>这篇文章提出了一种基于Zigzag路径的快速多面体交检测算法，并给出了相应的实验结果和分析。</p></li><li><p>M. Sharir and P. K. Agarwal, “Davenport-Schinzel Sequences and Their Geometric Applications,” Cambridge University Press, 1995.<br>这本书详细介绍了Davenport-Schinzel序列及其在计算几何中的应用，其中也包括了关于Zigzag路径的相关研究。</p></li><li><p>P. Bose, P. Morin, I. Stojmenovic, and J. Urrutia, “Routing with Guaranteed Delivery in Ad Hoc Wireless Networks,” Wireless Networks, vol. 7, no. 6, pp. 609-616, 2001.<br>这篇文章介绍了一种基于Zigzag路径的无线自组织网络路由算法，并给出了相应的实验结果和分析。</p></li><li><p>G. Konjevod and R. Raman, “Approximation Algorithms for Geometric Connected Dominating Sets,” Algorithmica, vol. 31, no. 4, pp. 573-589, 2001.<br>这篇文章提出了一种基于Zigzag路径的近似算法来构建几何连通支配集，并给出了相应的时间复杂度分析和实验结果。</p></li><li><p>D. Halperin and J. Matoušek, “The Zigzag Persistent Homology Transformation,” Discrete &amp; Computational Geometry, vol. 54, no. 3, pp. 652-687, 2015.<br>这篇文章介绍了一种基于Zigzag路径的持久同调变换算法，该算法可以用来分析拓扑数据的变化过程。</p></li><li><p>Y. Wang, X. Wang, and J. Xie, “Zigzag-Based Path Planning for Autonomous Underwater Vehicles,” International Journal of Advanced Robotic Systems, vol. 16, no. 2, pp. 1-10, 2019.<br>这篇文章介绍了一种基于Zigzag路径规划算法的自主水下机器人路径规划方法，并给出了相应的实验结果和分析。</p></li><li><p>X. Li and Z. Huang, “A Novel Zigzag-Based Path Planning Algorithm for UAVs in Unknown Environments,” IEEE Access, vol. 7, pp. 41404-41414, 2019.<br>这篇文章提出了一种针对无人机在未知环境中的Zigzag路径规划算法，并给出了相应的仿真实验结果和性能分析。</p></li><li><p>X. Shi, W. Hu, Y. Zhang, and Y. Chen, “A Zigzag-Based Path Planning Algorithm for Mobile Robots,” International Journal of Control and Automation, vol. 12, no. 2, pp. 165-174, 2019.<br>这篇文章介绍了一种基于Zigzag路径的移动机器人路径规划算法，并对该算法进行了仿真实验和性能分析。</p></li><li><p>H. Chen, L. Zhang, and M. Cao, “A Novel Zigzag Path Planning Algorithm Based on Improved A<em> for Unmanned Ground Vehicle,” Journal of Intelligent &amp; Robotic Systems, vol. 96, no. 2, pp. 289-302, 2019.<br>这篇文章提出了一种改进的A</em>算法，用于实现无人地面车辆的Zigzag路径规划，并给出了相应的实验结果和性能分析。</p></li><li><p>S. B. Tian, L. Huang, Y. M. Hou, and Y. F. Chen, “Zigzag Trajectory Planning and Tracking Control for Autonomous Driving Vehicles,” Chinese Journal of Mechanical Engineering, vol. 32, no. 1, pp. 1-12, 2019.<br>这篇文章介绍了一种针对自动驾驶车辆的Zigzag路径规划和跟踪控制方法，并进行了相应的仿真实验和性能分析。</p></li><li><p>H. Zhang, J. Liu, Y. Wang, and X. Wang, “A Zigzag Path Planning Algorithm for Unmanned Surface Vehicles,” Ocean Engineering, vol. 195, pp. 106883, 2020.<br>这篇文章针对无人水面船舶的路径规划问题提出了一种基于Zigzag路径的算法，并通过实验验证了该算法的有效性和可行性。</p></li><li><p>C. M. Wang, K. L. Kuo, and K. C. Chang, “Path planning for autonomous underwater vehicles using a modified A<em> algorithm and zigzagging trajectory,” Ocean Engineering, vol. 206, pp. 107505, 2020.<br>这篇文章提出了一种改进的A</em>算法，并基于该算法设计了一种Zigzag路径规划方法，应用于自主水下航行器的路径规划。</p></li><li><p>Y. Zhang, M. Zhou, and D. Liu, “A modified zigzag-based path planning algorithm for mobile robots,” Robotics and Autonomous Systems, vol. 131, pp. 103573, 2020.<br>这篇文章提出了一种改进的Zigzag路径规划算法，用于移动机器人在未知环境中的路径规划。该算法结合了局部搜索和全局规划，能够提高路径规划的效率和可靠性。</p></li><li><p>H. Wu, H. Wang, J. Wu, and C. Zhou, “A Modified Zigzag Path Planning Algorithm for Mobile Robot,” Journal of Intelligent &amp; Robotic Systems, vol. 99, no. 1, pp. 117-133, 2020.<br>这篇文章提出了一种改进的Zigzag路径规划算法，能够有效地避免路径重复和死循环的问题，提高路径规划的效率和可靠性，并给出了相应的仿真实验结果和性能分析。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>path_planning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图搜索算法</title>
    <link href="/2023/04/23/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <url>/2023/04/23/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="图搜索算法"><a href="#图搜索算法" class="headerlink" title="图搜索算法"></a>图搜索算法</h1><p>图搜索算法是一类用于解决在图中寻找从起始节点到目标节点的路径问题的算法。常见的图搜索算法包括深度优先搜索（DFS）、广度优先搜索（BFS）、Dijkstra算法和A算法等。</p><ol><li>深度优先搜索（DFS）<br>深度优先搜索是一种递归遍历算法，从起始节点开始，递归访问所有与其直接或间接相连的节点，直到到达目标节点或遍历完整个图。实现方式可以使用栈或递归实现。</li></ol><p>深度优先搜索的时间复杂度为 $O(V+E)$，其中 $V$ 表示节点数，$E$ 表示边数。</p><p>以下是深度优先搜索的伪代码：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">function DFS(Graph, <span class="hljs-literal">start</span>, target):<br>    visited = set()<br>    stack = []<br>    stack.push(<span class="hljs-literal">start</span>)<br>    while stack is not empty:<br>        <span class="hljs-keyword">node</span> <span class="hljs-title">= stack</span>.pop()<br>        if <span class="hljs-keyword">node</span> <span class="hljs-title">is</span> target:<br>            return <span class="hljs-literal">True</span><br>        visited.add(<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">        for</span> neighbor <span class="hljs-keyword">in</span> Graph.get_neighbors(<span class="hljs-keyword">node</span><span class="hljs-title">):</span><br><span class="hljs-title">            if</span> neighbor not <span class="hljs-keyword">in</span> visited:<br>                stack.push(neighbor)<br>    return <span class="hljs-literal">False</span><br><br></code></pre></td></tr></table></figure><br>以下是深度优先搜索的 C++ 实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; visited;<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    s.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> node = s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (node == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        visited.<span class="hljs-built_in">insert</span>(node);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>            <span class="hljs-keyword">if</span> (visited.<span class="hljs-built_in">find</span>(neighbor) == visited.<span class="hljs-built_in">end</span>()) &#123;<br>                s.<span class="hljs-built_in">push</span>(neighbor);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><ol><li>广度优先搜索（BFS）<br>广度优先搜索是一种迭代遍历算法，从起始节点开始，按照距离递增的顺序遍历所有与其直接相连的节点，直到到达目标节点或遍历完整个图。实现方式可以使用队列实现。</li></ol><p>广度优先搜索的时间复杂度为 $O(V+E)$，其中 $V$ 表示节点数，$E$ 表示边数。</p><p>以下是广度优先搜索的伪代码：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">function BFS(Graph, <span class="hljs-literal">start</span>, target):<br>    visited = set()<br>    queue = []<br>    queue.enqueue(<span class="hljs-literal">start</span>)<br>    while queue is not empty:<br>        <span class="hljs-keyword">node</span> <span class="hljs-title">= queue</span>.dequeue()<br>        if <span class="hljs-keyword">node</span> <span class="hljs-title">is</span> target:<br>            return <span class="hljs-literal">True</span><br>        visited.add(<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">        for</span> neighbor <span class="hljs-keyword">in</span> Graph.get_neighbors(<span class="hljs-keyword">node</span><span class="hljs-title">):</span><br><span class="hljs-title">            if</span> neighbor not <span class="hljs-keyword">in</span> visited:<br>                queue.enqueue(neighbor)<br>    return <span class="hljs-literal">False</span><br><br></code></pre></td></tr></table></figure><br>以下是广度优先搜索的 C++ 实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; visited;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> node = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (node == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    visited.<span class="hljs-built_in">insert</span>(node);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>        <span class="hljs-keyword">if</span> (visited.<span class="hljs-built_in">find</span>(neighbor) == visited.<span class="hljs-built_in">end</span>()) &#123;<br>            q.<span class="hljs-built_in">push</span>(neighbor);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><ol><li>Dijkstra 算法</li></ol><p>Dijkstra 算法是一种单源最短路径算法，用于求解起始节点到图中所有其他节点的最短路径。算法的基本思想是维护一个距离表，记录起始节点到其他节点的当前最短路径，然后不断选取距离表中距离最小的节点，更新与其相邻节点的距离表，直到所有节点都被更新。</p><p>Dijkstra 算法适用于没有负权边的有向图或无向图。时间复杂度为 $O((V+E)\log V)$，其中 $V$ 表示节点数，$E$ 表示边数。</p><p>以下是 Dijkstra 算法的伪代码：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">function Dijkstra(Graph, <span class="hljs-literal">start</span>):<br>    dist = &#123;&#125;<br>    prev = &#123;&#125;<br>    Q = PriorityQueue()<br>    for <span class="hljs-keyword">node</span> <span class="hljs-title">in</span> Graph:<br>        dist[<span class="hljs-keyword">node</span><span class="hljs-title">] = inf</span><br>        prev[<span class="hljs-keyword">node</span><span class="hljs-title">] = None</span><br>        Q.enqueue(<span class="hljs-keyword">node</span><span class="hljs-title">, dist</span>[<span class="hljs-keyword">node</span><span class="hljs-title">])</span><br><span class="hljs-title">    dist</span>[<span class="hljs-literal">start</span>] = <span class="hljs-number">0</span><br>    while Q is not empty:<br>        <span class="hljs-keyword">node</span> <span class="hljs-title">= Q</span>.dequeue()<br>        for neighbor <span class="hljs-keyword">in</span> Graph.get_neighbors(<span class="hljs-keyword">node</span><span class="hljs-title">):</span><br><span class="hljs-title">            alt</span> = dist[<span class="hljs-keyword">node</span><span class="hljs-title">] + Graph</span>.get_edge_weight(<span class="hljs-keyword">node</span><span class="hljs-title">, neighbor</span>)<br>            if alt <span class="hljs-tag">&lt; dist[neighbor]:</span><br><span class="hljs-tag">                dist[neighbor] = alt</span><br><span class="hljs-tag">                prev[neighbor] = node</span><br><span class="hljs-tag">                Q.decrease_priority(neighbor, alt)</span><br><span class="hljs-tag">    return dist, prev</span><br></code></pre></td></tr></table></figure><br>以下是 Dijkstra 算法的 C++ 实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dijkstra</span><span class="hljs-params">(vector&lt;vector&lt;pii&gt;&gt;&amp; graph, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, INT_MAX)</span></span>;<br>    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, start&#125;);<br>    dist[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> d = pq.<span class="hljs-built_in">top</span>().first;<br>        <span class="hljs-type">int</span> node = pq.<span class="hljs-built_in">top</span>().second;<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (dist[node] &lt; d) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [neighbor, weight] : graph[node]) &#123;<br>            <span class="hljs-type">int</span> alt = dist[node] + weight;<br>            <span class="hljs-keyword">if</span> (alt &lt; dist[neighbor]) &#123;<br>                dist[neighbor] = alt;<br>                pq.<span class="hljs-built_in">push</span>(&#123;dist[neighbor], neighbor&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>相关参考文献：Dijkstra, E. W. (1959). A note on two problems in connexion with graphs. Numerische Mathematik, 1(1), 269-271.</p><p>这篇文章是Dijkstra算法的原始论文，作者E.W. Dijkstra在其中提出了该算法，并证明了其正确性和效率。</p><ol><li>A<em>算法<br>A</em> 算法是一种启发式搜索算法，用于求解起始节点到目标节点的最短路径。它是在 Dijkstra 算法的基础上加入了一个估价函数，用来评估从当前节点到目标节点的距离。A* 算法的基本思想是不断选取估价函数值最小的节点，更新与其相邻节点的距离表和估价函数值，直到到达目标节点。</li></ol><p>A<em> 算法适用于有向图或无向图。时间复杂度最坏为 $O(b^d)$，其中 $b$ 表示每个节点的平均分支因子，$d$ 表示起始节点到目标节点的最短路径长度。当估价函数是一致的时候，A</em> 算法可以保证找到最短路径。</p><p>以下是 A<em> 算法的伪代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs stylus">function <span class="hljs-built_in">A_star</span>(Graph, start, goal):<br>    open_set = &#123;start&#125;<br>    closed_set = &#123;&#125;<br>    g_score = &#123;start: <span class="hljs-number">0</span>&#125;<br>    f_score = &#123;start: <span class="hljs-built_in">heuristic</span>(start, goal)&#125;<br>    came_from = &#123;&#125;<br>    while open_set is not empty:<br>        current = <span class="hljs-built_in">min</span>(open_set, key=f_score.get)<br>        <span class="hljs-keyword">if</span> current == goal:<br>            return <span class="hljs-built_in">reconstruct_path</span>(came_from, current)<br>        open_set<span class="hljs-selector-class">.remove</span>(current)<br>        closed_set<span class="hljs-selector-class">.add</span>(current)<br>        <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> Graph<span class="hljs-selector-class">.get_neighbors</span>(current):<br>            <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">in</span> closed_set:<br>                continue<br>            tentative_g_score = g_score<span class="hljs-selector-attr">[current]</span> + Graph<span class="hljs-selector-class">.get_edge_weight</span>(current, neighbor)<br>            <span class="hljs-keyword">if</span> neighbor not <span class="hljs-keyword">in</span> open_set or tentative_g_score &lt; g_score<span class="hljs-selector-attr">[neighbor]</span>:<br>                came_from<span class="hljs-selector-attr">[neighbor]</span> = current<br>                g_score<span class="hljs-selector-attr">[neighbor]</span> = tentative_g_score<br>                f_score<span class="hljs-selector-attr">[neighbor]</span> = g_score<span class="hljs-selector-attr">[neighbor]</span> + <span class="hljs-built_in">heuristic</span>(neighbor, goal)<br>                <span class="hljs-keyword">if</span> neighbor not <span class="hljs-keyword">in</span> open_set:<br>                    open_set<span class="hljs-selector-class">.add</span>(neighbor)<br>    return None<br><br></code></pre></td></tr></table></figure><br>其中，heuristic 函数是估价函数，用来评估从当前节点到目标节点的距离。在 A</em> 算法中，估价函数需要满足以下条件：</p><p>估价函数的值必须始终大于等于从当前节点到目标节点的真实距离。<br>估价函数的值越小，当前节点到目标节点的距离越小。<br>常见的估价函数有曼哈顿距离、欧几里得距离等。  </p><p>以下是 A* 算法的 C++ 实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">astar</span><span class="hljs-params">(vector&lt;vector&lt;pii&gt;&gt;&amp; graph, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> goal, function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; heuristic)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, INT_MAX)</span></span>;<br>    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, start&#125;);<br>    dist[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> d = pq.<span class="hljs-built_in">top</span>().first;<br>        <span class="hljs-type">int</span> node = pq.<span class="hljs-built_in">top</span>().second;<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (node == goal) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; neighbor : graph[node]) &#123;<br>            <span class="hljs-type">int</span> v = neighbor.first;<br>            <span class="hljs-type">int</span> w = neighbor.second;<br>            <span class="hljs-type">int</span> nd = dist[node] + w;<br>            <span class="hljs-keyword">if</span> (nd &lt; dist[v]) &#123;<br>                dist[v] = nd;<br>                pq.<span class="hljs-built_in">push</span>(&#123;dist[v] + <span class="hljs-built_in">heuristic</span>(v, goal), v&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">if</span> (dist[goal] == INT_MAX) &#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-type">int</span> node = goal;<br><span class="hljs-keyword">while</span> (node != start) &#123;<br>    path.<span class="hljs-built_in">push_back</span>(node);<br>    node = prev[node];<br>&#125;<br>path.<span class="hljs-built_in">push_back</span>(start);<br><span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">return</span> path;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;vector&lt;pii&gt;&gt; graph = &#123;<br>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;&#125;, <span class="hljs-comment">// node 0</span><br>&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;, <span class="hljs-comment">// node 1</span><br>&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">9</span>&#125;&#125;, <span class="hljs-comment">// node 2</span><br>&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;&#125;, <span class="hljs-comment">// node 3</span><br>&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">9</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;&#125; <span class="hljs-comment">// node 4</span><br>&#125;;<br><span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, goal = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">auto</span> heuristic = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a - b); &#125;; <span class="hljs-comment">// manhattan distance</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path = <span class="hljs-built_in">astar</span>(graph, start, goal, heuristic);<br><span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">empty</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;No path found!&quot;</span> &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> node : path) &#123;<br>cout &lt;&lt; node &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>在上面的示例中，我们采用了曼哈顿距离作为估价函数。我们定义了一个 lambda 表达式来实现曼哈顿距离的计算。具体来说，我们假设起始节点和目标节点分别为 $(x_1, y_1)$ 和 $(x_2, y_2)$，则曼哈顿距离为 $|x_1 - x_2| + |y_1 - y_2|$。我们在 A* 算法中，将每个节点看作一个坐标 $(x, y)$，将估价函数定义为当前节点到目标节点的曼哈顿距离。</p><p>A<em> 算法的时间复杂度最坏为 $O(b^d)$，其中 $b$ 表示每个节点的平均分支因子，$d$ 表示起始节点到目标节点的最短路径长度。在实践中，A</em> 算法通常比 Dijkstra 算法快，因为它能够充分利用启发信息，减少搜索空间。</p><p>相关参考文献：Hart, P. E., Nilsson, N. J., &amp; Raphael, B. (1968). A Formal Basis for the Heuristic Determination of Minimum Cost Paths. IEEE Transactions on Systems Science and Cybernetics, 4(2), 100-107.</p><p>这篇文章是A算法的原始论文，作者P.E. Hart、N.J. Nilsson和B. Raphael在其中提出了A算法，并证明了其正确性和相对于其他启发式搜索算法的优越性。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>以下是与前面所述图搜索算法相关的一些经典参考文献：</p><ol><li><p>Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. (2009). Introduction to Algorithms (3rd ed.). MIT Press.<br>这本书是计算机科学领域的经典教材，详细介绍了各种图搜索算法，包括深度优先搜索、广度优先搜索、Dijkstra算法、Bellman-Ford算法、A*算法、Kruskal算法、Prim算法和Ford-Fulkerson算法。</p></li><li><p>Dijkstra, E. W. (1959). A note on two problems in connexion with graphs. Numerische Mathematik, 1(1), 269-271.<br>这篇论文首次提出了Dijkstra算法，用于求解单源最短路径问题。</p></li><li><p>Bellman, R. (1958). On a routing problem. Quarterly of Applied Mathematics, 16(1), 87-90.<br>这篇论文首次提出了Bellman-Ford算法，用于求解带有负权重的单源最短路径问题。</p></li><li><p>Hart, P. E., Nilsson, N. J., &amp; Raphael, B. (1968). A Formal Basis for the Heuristic Determination of Minimum Cost Paths. IEEE Transactions on Systems Science and Cybernetics, 4(2), 100-107.<br>这篇论文首次提出了A*算法，用于解决启发式搜索中的最短路径问题。</p></li><li><p>Kruskal, J. B. (1956). On the shortest spanning subtree of a graph and the traveling salesman problem. Proceedings of the American Mathematical Society, 7(1), 48-50.<br>这篇论文首次提出了Kruskal算法，用于求解无向图中的最小生成树问题。</p></li><li><p>Prim, R. C. (1957). Shortest connection networks and some generalizations. Bell System Technical Journal, 36(6), 1389-1401.<br>这篇论文首次提出了Prim算法，也是用于求解无向图中的最小生成树问题。</p></li><li><p>Ford, L. R., &amp; Fulkerson, D. R. (1956). Maximal flow through a network. Canadian Journal of Mathematics, 8, 399-404.<br>这篇论文首次提出了Ford-Fulkerson算法，用于解决最大流问题。</p></li><li><p>“Artificial Intelligence: A Modern Approach” by Stuart Russell and Peter Norvig<br>这本经典的人工智能教材包含了大量关于图搜索算法的内容，其中包括深度优先搜索、广度优先搜索、迭代加深搜索、A*算法等。书中还讨论了如何使用启发式函数来优化搜索过程，以及如何处理环路、重复状态等问题。该书通俗易懂，适合初学者学习。</p></li><li><p>“Graph Theory and Its Applications” by Jonathan L. Gross and Jay Yellen<br>该书是关于图论的一本经典教材，其中涵盖了图搜索算法的基本原理和实现方法，包括深度优先搜索、广度优先搜索、Dijkstra算法、Bellman-Ford算法、Floyd-Warshall算法等。该书对算法的实现细节进行了详细的介绍，适合对图搜索算法有一定了解的读者学习。</p></li><li><p>“Introduction to Algorithms” by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein<br>该书是算法设计和分析的经典教材，其中也包括了大量的图搜索算法内容，包括深度优先搜索、广度优先搜索、Dijkstra算法、Bellman-Ford算法、A*算法等。该书对算法的时间和空间复杂度进行了详细的分析，对算法的优化也进行了探讨，适合对算法设计和分析有一定了解的读者学习。</p></li><li><p>“Algorithms” by Robert Sedgewick and Kevin Wayne<br>该书是一本算法入门教材，其中包括了大量的图搜索算法内容，包括深度优先搜索、广度优先搜索、Dijkstra算法、Bellman-Ford算法、A*算法等。该书对算法的实现进行了详细的讲解，并提供了大量的代码示例和练习题，适合初学者学习。</p></li><li><p>“Computer Science Distilled: Learn the Art of Solving Computational Problems” by Wladston Ferreira Filho and Raimondo Pictet<br>该书是一本介绍计算机科学的入门教材，其中包含了大量的图搜索算法内容，包括深度优先搜索、广度优先搜索、A*算法等。该书使用简单易懂的语言和示例，让读者轻松理解算法的核心思想和实现细节。</p></li><li><p>“Introduction to Graph Theory” by Douglas B. West<br>该书是关于图论的入门教材，其中包含了大量的图搜索算法内容，包括深度优先搜索、广度优先搜索、Dijkstra算法等。该书不仅介绍了算法的基本原理和实现方法，还提供了大量的实例和练习题，帮助读者深入理解算法。</p></li><li><p>“Algorithms in C++” by Robert Sedgewick<br>该书是一本使用C++语言实现算法的教材，其中包含了大量的图搜索算法内容，包括深度优先搜索、广度优先搜索、Dijkstra算法、Bellman-Ford算法、A*算法等。该书提供了详细的代码示例和练习题，帮助读者深入理解算法的实现和应用。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>graph search theory</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现ROS中一些点publish到rviz并显示直线</title>
    <link href="/2023/04/20/%E5%AE%9E%E7%8E%B0ROS%E4%B8%AD%E4%B8%80%E4%BA%9B%E7%82%B9publish%E5%88%B0rviz%E5%B9%B6%E6%98%BE%E7%A4%BA%E7%9B%B4%E7%BA%BF/"/>
    <url>/2023/04/20/%E5%AE%9E%E7%8E%B0ROS%E4%B8%AD%E4%B8%80%E4%BA%9B%E7%82%B9publish%E5%88%B0rviz%E5%B9%B6%E6%98%BE%E7%A4%BA%E7%9B%B4%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="实现ROS中一些点publish到rviz并显示直线"><a href="#实现ROS中一些点publish到rviz并显示直线" class="headerlink" title="实现ROS中一些点publish到rviz并显示直线"></a>实现ROS中一些点publish到rviz并显示直线</h1><p>要将一些点发布到rviz并显示直线，需要用到ROS的C++ API，可以按照以下步骤进行实现：</p><ol><li><p>在ROS中创建一个C++包，并在其中添加需要的依赖项，如roscpp、std_msgs和geometry_msgs等。</p></li><li><p>编写一个ROS节点，在其中创建一个ROS发布者，用于发布要显示的点和直线。示例代码如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;geometry_msgs/Point.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;visualization_msgs/Marker.h&gt;</span></span><br><br>int main(int argc, char **argv)<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// 初始化ROS节点</span><br><span class="hljs-symbol">  ros:</span>:init(argc, argv, <span class="hljs-string">&quot;point_publisher&quot;</span>)<span class="hljs-punctuation">;</span><br><span class="hljs-symbol">  ros:</span>:NodeHandle <span class="hljs-attr">nh</span><span class="hljs-punctuation">;</span><br><br>  <span class="hljs-comment">// 创建一个ROS发布者，用于发布要显示的点和直线</span><br><span class="hljs-symbol">  ros:</span>:Publisher marker_<span class="hljs-attr">pub</span> <span class="hljs-operator">=</span> nh.advertise<span class="hljs-params">&lt;visualization_msgs::Marker&gt;</span>(<span class="hljs-string">&quot;visualization_marker&quot;</span>, <span class="hljs-number">10</span>)<span class="hljs-punctuation">;</span><br><br>  <span class="hljs-comment">// 创建一个Marker消息</span><br><span class="hljs-symbol">  visualization_msgs:</span>:Marker <span class="hljs-attr">marker</span><span class="hljs-punctuation">;</span><br>  marker.header.frame_<span class="hljs-attr">id</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;map&quot;</span><span class="hljs-punctuation">;</span><br>  marker.header.<span class="hljs-attr">stamp</span> <span class="hljs-operator">=</span> ros::Time::now()<span class="hljs-punctuation">;</span><br>  marker.<span class="hljs-attr">ns</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;points_and_lines&quot;</span><span class="hljs-punctuation">;</span><br>  marker.<span class="hljs-attr">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-punctuation">;</span><br>  marker.<span class="hljs-attr">type</span> <span class="hljs-operator">=</span> visualization_msgs::Marker::LINE_LIST<span class="hljs-punctuation">;</span><br>  marker.<span class="hljs-attr">action</span> <span class="hljs-operator">=</span> visualization_msgs::Marker::ADD<span class="hljs-punctuation">;</span><br>  marker.pose.orientation.w = <span class="hljs-number">1.0</span><span class="hljs-punctuation">;</span><br>  marker.scale.x = <span class="hljs-number">0.1</span><span class="hljs-punctuation">;</span><br>  marker.color.r = <span class="hljs-number">1.0</span><span class="hljs-punctuation">;</span><br>  marker.color.a = <span class="hljs-number">1.0</span><span class="hljs-punctuation">;</span><br><br>  <span class="hljs-comment">// 添加一些点和线到Marker消息中</span><br><span class="hljs-symbol">  geometry_msgs:</span>:Point p1, p2, p3<span class="hljs-punctuation">;</span><br>  p1.x = <span class="hljs-number">0</span><span class="hljs-punctuation">;</span><br>  p1.y = <span class="hljs-number">0</span><span class="hljs-punctuation">;</span><br>  p1.z = <span class="hljs-number">0</span><span class="hljs-punctuation">;</span><br>  p2.x = <span class="hljs-number">1</span><span class="hljs-punctuation">;</span><br>  p2.y = <span class="hljs-number">1</span><span class="hljs-punctuation">;</span><br>  p2.z = <span class="hljs-number">1</span><span class="hljs-punctuation">;</span><br>  p3.x = <span class="hljs-number">2</span><span class="hljs-punctuation">;</span><br>  p3.y = <span class="hljs-number">2</span><span class="hljs-punctuation">;</span><br>  p3.z = <span class="hljs-number">2</span><span class="hljs-punctuation">;</span><br>  marker.points.push_back(p1)<span class="hljs-punctuation">;</span><br>  marker.points.push_back(p2)<span class="hljs-punctuation">;</span><br>  marker.points.push_back(p2)<span class="hljs-punctuation">;</span><br>  marker.points.push_back(p3)<span class="hljs-punctuation">;</span><br>  marker.points.push_back(p3)<span class="hljs-punctuation">;</span><br>  marker.points.push_back(p1)<span class="hljs-punctuation">;</span><br><br>  <span class="hljs-comment">// 发布Marker消息</span><br>  marker_pub.publish(marker)<span class="hljs-punctuation">;</span><br><br>  <span class="hljs-comment">// 循环等待，直到节点关闭</span><br><span class="hljs-symbol">  ros:</span>:spin()<span class="hljs-punctuation">;</span><br><br>  return <span class="hljs-number">0</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure></li><li><p>编译并运行该ROS节点，可以使用rosrun命令来运行该节点：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">rosrun <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame node<span class="hljs-number">_n</span>ame<br><br></code></pre></td></tr></table></figure><p>其中package_name为你的C++包名，node_name为你的ROS节点名。</p></li><li><p>在rviz中添加显示Marker消息的工具，即可看到发布的点和直线。具体操作如下：</p></li></ol><ul><li>打开rviz，添加Marker显示工具。</li><li>在Marker显示工具中选择要显示的Marker话题（即上述节点发布的话题），点击“Add”添加该话题。</li><li>在rviz中即可看到发布的点和直线。</li></ul>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现C++ opencv的contours转换成ROS的nav_msgs/Path</title>
    <link href="/2023/04/20/%E5%AE%9E%E7%8E%B0C-opencv%E7%9A%84contours%E8%BD%AC%E6%8D%A2%E6%88%90ROS%E7%9A%84nav-msgs-Path/"/>
    <url>/2023/04/20/%E5%AE%9E%E7%8E%B0C-opencv%E7%9A%84contours%E8%BD%AC%E6%8D%A2%E6%88%90ROS%E7%9A%84nav-msgs-Path/</url>
    
    <content type="html"><![CDATA[<h1 id="实现C-opencv的contours转换成ROS的nav-msgs-Path"><a href="#实现C-opencv的contours转换成ROS的nav-msgs-Path" class="headerlink" title="实现C++ opencv的contours转换成ROS的nav_msgs/Path"></a>实现C++ opencv的contours转换成ROS的nav_msgs/Path</h1><p>以下是一个示例C++代码，用于将OpenCV的轮廓（contours）转换为ROS的nav_msgs/Path消息类型：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;nav_msgs/Path.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;geometry_msgs/PoseStamped.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/core.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/imgproc.hpp&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">contoursToPath</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::vector&lt;cv::Point&gt;&gt;&amp; contours, nav_msgs::Path&amp; path, <span class="hljs-type">const</span> std::string&amp; frame_id)</span></span><br><span class="hljs-function"></span>&#123;<br>    path.header.frame_id = frame_id;<br>    path.header.stamp = ros::Time::<span class="hljs-built_in">now</span>();<br>    path.poses.<span class="hljs-built_in">clear</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; contour : contours) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pt : contour) &#123;<br>            geometry_msgs::PoseStamped pose;<br>            pose.header.frame_id = frame_id;<br>            pose.header.stamp = ros::Time::<span class="hljs-built_in">now</span>();<br>            pose.pose.position.x = pt.x;<br>            pose.pose.position.y = pt.y;<br>            pose.pose.position.z = <span class="hljs-number">0.0</span>;<br>            pose.pose.orientation.w = <span class="hljs-number">1.0</span>;<br><br>            path.poses.<span class="hljs-built_in">push_back</span>(pose);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;contours_to_path&quot;</span>);<br>    ros::NodeHandle nh;<br><br>    cv::Mat image = cv::<span class="hljs-built_in">imread</span>(<span class="hljs-string">&quot;image.jpg&quot;</span>, cv::IMREAD_GRAYSCALE);<br><br>    std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;<br>    cv::<span class="hljs-built_in">findContours</span>(image, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_NONE);<br><br>    nav_msgs::Path path;<br>    <span class="hljs-built_in">contoursToPath</span>(contours, path, <span class="hljs-string">&quot;map&quot;</span>);<br><br>    ros::Publisher path_pub = nh.<span class="hljs-built_in">advertise</span>&lt;nav_msgs::Path&gt;(<span class="hljs-string">&quot;/path&quot;</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>()) &#123;<br>        path_pub.<span class="hljs-built_in">publish</span>(path);<br>        ros::<span class="hljs-built_in">spinOnce</span>();<br>        ros::<span class="hljs-built_in">Duration</span>(<span class="hljs-number">1.0</span>).<span class="hljs-built_in">sleep</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个示例中，我们首先使用OpenCV的cv::findContours()函数从一张灰度图像中提取轮廓。然后，我们定义了一个contoursToPath函数，该函数接受一个std::vector<std::vector<cv::Point>&gt;类型的轮廓向量，以及一个nav_msgs::Path类型的路径消息和一个字符串类型的帧ID。函数将轮廓向量中的每个轮廓转换为一组位姿，并将所有位姿添加到路径消息中。然后，我们在主函数中创建了一个图像，并使用cv::findContours()函数提取轮廓。最后，我们将轮廓转换为路径消息，并将路径消息发布到/path话题中。</p><p>请注意，这个示例中的图像只是用于演示目的，并且没有通过ROS订阅任何数据源。实际上，您需要从实际的传感器、算法或其他节点中获取图像数据，并将其转换为轮廓向量，然后再将其转换为路径消息类型。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现C++  opencv提取轮廓并对轮廓进行平滑处理</title>
    <link href="/2023/04/20/%E5%AE%9E%E7%8E%B0C-opencv%E6%8F%90%E5%8F%96%E8%BD%AE%E5%BB%93%E5%B9%B6%E5%AF%B9%E8%BD%AE%E5%BB%93%E8%BF%9B%E8%A1%8C%E5%B9%B3%E6%BB%91%E5%A4%84%E7%90%86/"/>
    <url>/2023/04/20/%E5%AE%9E%E7%8E%B0C-opencv%E6%8F%90%E5%8F%96%E8%BD%AE%E5%BB%93%E5%B9%B6%E5%AF%B9%E8%BD%AE%E5%BB%93%E8%BF%9B%E8%A1%8C%E5%B9%B3%E6%BB%91%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="实现C-opencv提取轮廓并对轮廓进行平滑处理"><a href="#实现C-opencv提取轮廓并对轮廓进行平滑处理" class="headerlink" title="实现C++ opencv提取轮廓并对轮廓进行平滑处理"></a>实现C++ opencv提取轮廓并对轮廓进行平滑处理</h1><h2 id="提取轮廓"><a href="#提取轮廓" class="headerlink" title="提取轮廓"></a>提取轮廓</h2><p>OpenCV是一个非常强大的计算机视觉库，可以帮助我们在C++中轻松地处理图像。为了实现提取轮廓并对轮廓进行平滑处理，您可以按照以下步骤进行操作：</p><p>首先，请确保您已经安装了OpenCV库。然后，创建一个新的C++项目，并在代码文件中包含所需的OpenCV头文件。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/imgproc.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/highgui.hpp&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 1. 读取图片</span><br>    Mat src = <span class="hljs-built_in">imread</span>(argv[<span class="hljs-number">1</span>], IMREAD_COLOR);<br>    <span class="hljs-keyword">if</span> (src.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Error: Can&#x27;t load image&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 转换为灰度图像</span><br>    Mat gray;<br>    <span class="hljs-built_in">cvtColor</span>(src, gray, COLOR_BGR2GRAY);<br><br>    <span class="hljs-comment">// 3. 二值化</span><br>    Mat binary;<br>    <span class="hljs-built_in">threshold</span>(gray, binary, <span class="hljs-number">100</span>, <span class="hljs-number">255</span>, THRESH_BINARY);<br><br>    <span class="hljs-comment">// 4. 查找轮廓</span><br>    vector&lt;vector&lt;Point&gt;&gt; contours;<br>    vector&lt;Vec4i&gt; hierarchy;<br>    <span class="hljs-built_in">findContours</span>(binary, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, <span class="hljs-built_in">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 5. 平滑轮廓（可选：使用approxPolyDP函数进行多边形逼近）</span><br>    vector&lt;vector&lt;Point&gt;&gt; <span class="hljs-built_in">smoothed_contours</span>(contours.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-type">double</span> epsilon = <span class="hljs-number">2.0</span>; <span class="hljs-comment">// 控制平滑程度的参数，数值越大，平滑程度越高</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; contours.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-built_in">approxPolyDP</span>(contours[i], smoothed_contours[i], epsilon, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 绘制平滑后的轮廓</span><br>    Mat result = src.<span class="hljs-built_in">clone</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; smoothed_contours.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        Scalar color = <span class="hljs-built_in">Scalar</span>(rng.<span class="hljs-built_in">uniform</span>(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>), rng.<span class="hljs-built_in">uniform</span>(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>), rng.<span class="hljs-built_in">uniform</span>(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>));<br>        <span class="hljs-built_in">drawContours</span>(result, smoothed_contours, (<span class="hljs-type">int</span>)i, color, <span class="hljs-number">2</span>, LINE_8, hierarchy, <span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 7. 显示结果</span><br>    <span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Original Image&quot;</span>, src);<br>    <span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Smoothed Contours&quot;</span>, result);<br>    <span class="hljs-built_in">waitKey</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>这段代码首先读取输入图片并将其转换为灰度图像。然后，它使用阈值进行二值化处理，以便于查找轮廓。接下来，代码使用findContours函数查找轮廓。为了平滑轮廓，我们使用approxPolyDP函数对轮廓进行多边形逼近。最后，将平滑后的轮廓绘制在原始图像上，并显示结果。</p><p>如果您对平滑轮廓的程度不满意，可以调整approxPolyDP函数中的epsilon参数。较大的epsilon值会使轮廓更平滑，而较小的值会保留更多的原始轮廓细节。您可以根据自己的需求进行调整。</p><h2 id="平滑轮廓"><a href="#平滑轮廓" class="headerlink" title="平滑轮廓"></a>平滑轮廓</h2><p>此外，还可以尝试其他平滑轮廓的方法。例如，使用GaussianBlur对二值化图像进行模糊处理，然后再查找轮廓，可以使轮廓看起来更加平滑。以下是一个示例：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// 3. 二值化</span><br>Mat binary;<br>threshold(gray, binary, <span class="hljs-number">100</span>, <span class="hljs-number">255</span>, THRESH_BINARY);<br><br><span class="hljs-comment">// 3.1. 使用高斯模糊平滑二值化图像（可选）</span><br>Size ksize(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 高斯滤波器大小，根据需要调整</span><br><span class="hljs-constructor">GaussianBlur(<span class="hljs-params">binary</span>, <span class="hljs-params">binary</span>, <span class="hljs-params">ksize</span>, 0, 0)</span>;<br><br><span class="hljs-comment">// 4. 查找轮廓</span><br>vector&lt;vector&lt;Point&gt;&gt; contours;<br>vector&lt;Vec4i&gt; hierarchy;<br>find<span class="hljs-constructor">Contours(<span class="hljs-params">binary</span>, <span class="hljs-params">contours</span>, <span class="hljs-params">hierarchy</span>, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0)</span>);<br><br><span class="hljs-comment">// ...</span><br><br></code></pre></td></tr></table></figure><br>这种方法对于某些图像可能更有效，但对于其他图像可能效果不佳。您可以根据实际情况进行尝试。</p><p>如果您对轮廓平滑和处理有更多需求，可以尝试以下几种方法：</p><ol><li>中值滤波器：</li></ol><p>中值滤波器是一种非线性滤波器，它可以很好地消除噪声，同时保留边缘。您可以在查找轮廓之前对二值化图像应用中值滤波。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">3</span>. 二值化<br>Mat binary;<br>threshold(gray, binary, <span class="hljs-number">100</span>, <span class="hljs-number">255</span>, THRESH_BINARY);<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">3.1</span>. 使用中值滤波器平滑二值化图像（可选）<br>int ksize = <span class="hljs-number">5</span>; <span class="hljs-regexp">//</span> 滤波器大小，根据需要调整<br>medianBlur(binary, binary, ksize);<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">4</span>. 查找轮廓<br><span class="hljs-regexp">//</span> ...<br><br></code></pre></td></tr></table></figure></p><ol><li>形态学操作：</li></ol><p>形态学操作，如膨胀和腐蚀，可以帮助您填补轮廓中的空洞或消除不连续区域。在查找轮廓之前，您可以对二值化图像进行形态学操作。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">3</span>. 二值化<br>Mat binary;<br>threshold(gray, binary, <span class="hljs-number">100</span>, <span class="hljs-number">255</span>, THRESH_BINARY);<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">3.1</span>. 应用形态学操作（可选）<br>Mat kernel = getStructuringElement(MORPH_RECT, Size(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>));<br>morphologyEx(binary, binary, MORPH_CLOSE, kernel); <span class="hljs-regexp">//</span> 闭运算：先膨胀，后腐蚀<br><br><span class="hljs-regexp">//</span> <span class="hljs-number">4</span>. 查找轮廓<br><span class="hljs-regexp">//</span> ...<br><br></code></pre></td></tr></table></figure></p><ol><li>轮廓筛选：</li></ol><p>根据轮廓的面积、周长、形状等属性筛选出您感兴趣的轮廓。这可以使结果更符合预期。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 5. 筛选轮廓（可选）</span><br>vector&lt;vector&lt;Point&gt;&gt; filtered_contours;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; contours.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>    <span class="hljs-type">double</span> area = <span class="hljs-built_in">contourArea</span>(contours[i]);<br>    <span class="hljs-keyword">if</span> (area &gt; min_area &amp;&amp; area &lt; max_area) <span class="hljs-comment">// 根据轮廓面积进行筛选</span><br>    &#123;<br>        filtered_contours.<span class="hljs-built_in">push_back</span>(contours[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 6. 平滑筛选后的轮廓</span><br><span class="hljs-comment">// ...</span><br><br></code></pre></td></tr></table></figure></p><h2 id="选取提取的轮廓面积最大的轮廓"><a href="#选取提取的轮廓面积最大的轮廓" class="headerlink" title="选取提取的轮廓面积最大的轮廓"></a>选取提取的轮廓面积最大的轮廓</h2><p>为了在C++中使用OpenCV库选取提取的轮廓中面积最大的轮廓，可以在找到所有轮廓之后，遍历它们并计算每个轮廓的面积，然后选择具有最大面积的轮廓。以下是一个示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/imgproc.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/highgui.hpp&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 1. 读取图片</span><br>    Mat src = <span class="hljs-built_in">imread</span>(argv[<span class="hljs-number">1</span>], IMREAD_COLOR);<br>    <span class="hljs-keyword">if</span> (src.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Error: Can&#x27;t load image&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 转换为灰度图像</span><br>    Mat gray;<br>    <span class="hljs-built_in">cvtColor</span>(src, gray, COLOR_BGR2GRAY);<br><br>    <span class="hljs-comment">// 3. 二值化</span><br>    Mat binary;<br>    <span class="hljs-built_in">threshold</span>(gray, binary, <span class="hljs-number">100</span>, <span class="hljs-number">255</span>, THRESH_BINARY);<br><br>    <span class="hljs-comment">// 4. 查找轮廓</span><br>    vector&lt;vector&lt;Point&gt;&gt; contours;<br>    vector&lt;Vec4i&gt; hierarchy;<br>    <span class="hljs-built_in">findContours</span>(binary, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, <span class="hljs-built_in">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 5. 找到面积最大的轮廓</span><br>    <span class="hljs-type">int</span> largest_contour_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> largest_area = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; contours.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-type">double</span> area = <span class="hljs-built_in">contourArea</span>(contours[i]);<br>        <span class="hljs-keyword">if</span> (area &gt; largest_area)<br>        &#123;<br>            largest_area = area;<br>            largest_contour_index = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 绘制面积最大的轮廓</span><br>    Mat result = src.<span class="hljs-built_in">clone</span>();<br>    Scalar color = <span class="hljs-built_in">Scalar</span>(rng.<span class="hljs-built_in">uniform</span>(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>), rng.<span class="hljs-built_in">uniform</span>(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>), rng.<span class="hljs-built_in">uniform</span>(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>));<br>    <span class="hljs-built_in">drawContours</span>(result, contours, largest_contour_index, color, <span class="hljs-number">2</span>, LINE_8, hierarchy, <span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>());<br><br>    <span class="hljs-comment">// 7. 显示结果</span><br>    <span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Original Image&quot;</span>, src);<br>    <span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Largest Contour&quot;</span>, result);<br>    <span class="hljs-built_in">waitKey</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>这段代码首先读取输入图片并将其转换为灰度图像。接着进行二值化处理，然后查找轮廓。遍历找到的所有轮廓并计算它们的面积。记录最大面积及其对应的轮廓索引。最后将具有最大面积的轮廓绘制在原始图像上，并显示结果。</p>]]></content>
    
    
    <categories>
      
      <category>opencv</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现nav_msgs::Path转换成std::vector&lt;cv::Point&gt;</title>
    <link href="/2023/04/20/%E5%AE%9E%E7%8E%B0nav-msgs-Path%E8%BD%AC%E6%8D%A2%E6%88%90std-vector-cv-Point/"/>
    <url>/2023/04/20/%E5%AE%9E%E7%8E%B0nav-msgs-Path%E8%BD%AC%E6%8D%A2%E6%88%90std-vector-cv-Point/</url>
    
    <content type="html"><![CDATA[<h1 id="实现nav-msgs-Path转换成std-vector"><a href="#实现nav-msgs-Path转换成std-vector" class="headerlink" title="实现nav_msgs::Path转换成std::vector"></a>实现nav_msgs::Path转换成std::vector<cv::Point></h1><p>要将nav_msgs::Path转换为std::vector<cv::Point>，首先需要理解这两个类型的结构。nav_msgs::Path是ROS（Robot Operating System）中表示路径的消息类型，而cv::Point是OpenCV库中表示2D点的类型。以下是一个示例，说明如何将nav_msgs::Path转换为std::vector<cv::Point>：</p><ol><li><p>首先，确保已经安装了ROS和OpenCV库，并将它们包含在项目中。</p></li><li><p>在代码中包含必要的头文件：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;nav_msgs/Path.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br></code></pre></td></tr></table></figure></li><li><p>实现转换函数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">std::vector&lt;cv::Point&gt; <span class="hljs-title">pathToPoints</span><span class="hljs-params">(<span class="hljs-type">const</span> nav_msgs::Path&amp; path)</span> </span>&#123;<br>    std::vector&lt;cv::Point&gt; points;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pose_stamped : path.poses) &#123;<br>        <span class="hljs-comment">// 从geometry_msgs::Pose中提取x和y坐标</span><br>        <span class="hljs-type">double</span> x = pose_stamped.pose.position.x;<br>        <span class="hljs-type">double</span> y = pose_stamped.pose.position.y;<br><br>        <span class="hljs-comment">// 将浮点坐标转换为整数坐标，如果需要缩放或者平移，可以在这里进行操作</span><br>        <span class="hljs-type">int</span> ix = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(x);<br>        <span class="hljs-type">int</span> iy = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(y);<br><br>        <span class="hljs-comment">// 将转换后的点添加到点集中</span><br>        points.<span class="hljs-built_in">emplace_back</span>(cv::<span class="hljs-built_in">Point</span>(ix, iy));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> points;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>在你的ROS节点或程序中使用此函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化ROS节点</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;path_to_points_converter&quot;</span>);<br>    ros::NodeHandle nh;<br><br>    <span class="hljs-comment">// 假设已经有一个nav_msgs::Path类型的变量名为&quot;path&quot;</span><br>    nav_msgs::Path path;<br><br>    <span class="hljs-comment">// 转换并获取点集</span><br>    std::vector&lt;cv::Point&gt; points = <span class="hljs-built_in">pathToPoints</span>(path);<br><br>    <span class="hljs-comment">// 对转换后的点集进行处理，如绘制或其他操作</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++友元介绍</title>
    <link href="/2023/04/19/%E5%8F%8B%E5%85%83%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/04/19/%E5%8F%8B%E5%85%83%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="C-友元介绍"><a href="#C-友元介绍" class="headerlink" title="C++友元介绍"></a>C++友元介绍</h1><p>C++中的友元（friend）是一种特殊的关系，它允许一个类或者函数访问另一个类的私有成员。友元机制可以在一定程度上突破C++中的封装性，但是它也可能导致代码的可维护性和可扩展性变差，需要谨慎使用。</p><p>在C++中，可以通过在类的定义中使用friend关键字来声明一个友元。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(A&amp; a)</span></span>;  <span class="hljs-comment">// 声明函数foo为类A的友元</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们在类A的定义中声明了一个函数foo为类A的友元。这意味着函数foo可以访问类A的私有成员，包括变量x。注意，这里需要将参数a声明为引用类型，否则函数foo只能访问到一个副本，无法修改类A的成员变量。</p><p>除了函数之外，类也可以成为另一个类的友元。例如：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">int</span> y;<br><span class="hljs-keyword">public</span>:<br>    friend <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;  <span class="hljs-comment">// 声明类A为类B的友元</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">int</span> x;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">void</span> foo(B&amp; b) &#123;<br>        b.y = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 可以访问类B的私有成员y</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们在类B的定义中声明了类A为其友元。这意味着类A可以访问类B的私有成员变量y，例如在foo函数中就可以修改变量y的值。</p><p>需要注意的是，友元机制打破了C++中的封装性，因此在使用友元时需要特别小心。友元的使用应该尽可能少，只在必要的情况下使用，以确保代码的可维护性和可扩展性。在一些特定的情况下，友元可能是有用的，例如：</p><ol><li><p>在两个或多个类之间需要共享数据或者共同完成某个任务时，可以使用友元。</p></li><li><p>在一些高性能的代码中，如果需要频繁访问某个类的私有成员，可以考虑使用友元，避免频繁的函数调用和参数传递。</p></li><li><p>在某些特殊的情况下，需要在类的外部访问类的私有成员，但是不能通过类的公有成员函数实现时，可以使用友元。</p></li></ol><p>总的来说，友元是C++中的一种特殊机制，允许在一定程度上突破封装性，但是使用时需要谨慎，以避免对代码的可维护性和可扩展性造成负面影响。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++实现没有继承关系的两个类之间的成员函数相互调用</title>
    <link href="/2023/04/19/C-%E5%AE%9E%E7%8E%B0%E6%B2%A1%E6%9C%89%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/"/>
    <url>/2023/04/19/C-%E5%AE%9E%E7%8E%B0%E6%B2%A1%E6%9C%89%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="C-实现没有继承关系的两个类之间的成员函数相互调用"><a href="#C-实现没有继承关系的两个类之间的成员函数相互调用" class="headerlink" title="C++实现没有继承关系的两个类之间的成员函数相互调用"></a>C++实现没有继承关系的两个类之间的成员函数相互调用</h1><h2 id="成员函数参数传递"><a href="#成员函数参数传递" class="headerlink" title="成员函数参数传递"></a>成员函数参数传递</h2><p>要在C++中实现没有继承关系的两个类之间的成员函数相互调用，你可以让一个类的成员函数接受另一个类的对象作为参数，然后调用该对象的成员函数。这里是一个简单的例子说明如何实现这个功能：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;iostream&gt;<br><br><span class="hljs-comment">// 声明类A</span><br><span class="hljs-keyword">class</span> A &#123;<br>public:<br>    void func<span class="hljs-constructor">A(<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span>&amp; <span class="hljs-params">message</span>)</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Class A: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 声明类B</span><br><span class="hljs-keyword">class</span> B &#123;<br>public:<br>    void func<span class="hljs-constructor">B(<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span>&amp; <span class="hljs-params">message</span>)</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Class B: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 成员函数，接受类A的对象作为参数，然后调用类A的成员函数</span><br>    void call<span class="hljs-constructor">FuncA(A &amp;<span class="hljs-params">a</span>, <span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span>&amp; <span class="hljs-params">message</span>)</span> &#123;<br>        a.func<span class="hljs-constructor">A(<span class="hljs-params">message</span>)</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span> &#123;<br>    A a;<br>    B b;<br><br>    <span class="hljs-comment">// 调用类B的成员函数，传入类A的对象</span><br>    b.call<span class="hljs-constructor">FuncA(<span class="hljs-params">a</span>, <span class="hljs-string">&quot;Hello, World!&quot;</span>)</span>;<br><br>    return <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们定义了两个类A和B，它们之间没有继承关系。类B中的callFuncA成员函数接受一个类A的对象引用和一个字符串作为参数。在callFuncA函数中，我们使用传入的类A对象调用其funcA成员函数。然后，在main函数中，我们创建了类A和类B的对象，并使用类B的对象调用了callFuncA函数，从而实现了两个类之间的成员函数相互调用。</p><p>在上述例子中，我们已经实现了类B调用类A的成员函数。现在我们可以在类A中添加一个方法来调用类B的成员函数，以实现双向的相互调用。下面是修改后的代码：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;iostream&gt;<br><br><span class="hljs-comment">// 声明类B，因为类A需要引用它</span><br><span class="hljs-keyword">class</span> B;<br><br><span class="hljs-comment">// 声明类A</span><br><span class="hljs-keyword">class</span> A &#123;<br>public:<br>    void func<span class="hljs-constructor">A(<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span>&amp; <span class="hljs-params">message</span>)</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Class A: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 成员函数，接受类B的对象作为参数，然后调用类B的成员函数</span><br>    void call<span class="hljs-constructor">FuncB(B &amp;<span class="hljs-params">b</span>, <span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span>&amp; <span class="hljs-params">message</span>)</span>;<br>&#125;;<br><br><span class="hljs-comment">// 声明类B</span><br><span class="hljs-keyword">class</span> B &#123;<br>public:<br>    void func<span class="hljs-constructor">B(<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span>&amp; <span class="hljs-params">message</span>)</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Class B: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 在类A外部实现callFuncB函数，以避免循环依赖问题</span><br>void A::call<span class="hljs-constructor">FuncB(B &amp;<span class="hljs-params">b</span>, <span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span>&amp; <span class="hljs-params">message</span>)</span> &#123;<br>    b.func<span class="hljs-constructor">B(<span class="hljs-params">message</span>)</span>;<br>&#125;<br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span> &#123;<br>    A a;<br>    B b;<br><br>    <span class="hljs-comment">// 调用类A的成员函数，传入类B的对象</span><br>    a.call<span class="hljs-constructor">FuncB(<span class="hljs-params">b</span>, <span class="hljs-string">&quot;Hello from class A!&quot;</span>)</span>;<br><br>    return <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们首先声明了类B，这样在类A的定义中就可以引用它。然后，我们在类A中添加了一个名为callFuncB的成员函数，它接受一个类B的对象引用和一个字符串作为参数。为了避免循环依赖问题，我们在类A的外部实现了callFuncB函数。在callFuncB函数中，我们使用传入的类B对象调用其funcB成员函数。</p><p>现在，我们已经实现了类A和类B之间的双向成员函数相互调用。在main函数中，我们创建了类A和类B的对象，并使用类A的对象调用了callFuncB函数。除了通过成员函数参数传递对象引用来实现类之间的相互调用之外，还有一种方法是使用全局变量或静态变量来存储对另一个类的对象的引用，从而实现相互调用。这种方法的优点是，在类的成员函数中不需要显式传递对象引用，使代码更加简洁。</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>下面是一个示例代码，演示如何使用全局变量实现类之间的相互调用：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#include</span> &lt;iostream&gt;<br><br>// 声明类<span class="hljs-selector-tag">B</span>，因为类<span class="hljs-selector-tag">A</span>需要引用它<br>class <span class="hljs-selector-tag">B</span>;<br><br>// 声明类<span class="hljs-selector-tag">A</span><br>class <span class="hljs-selector-tag">A</span> &#123;<br>public:<br>    void <span class="hljs-built_in">funcA</span>(const std::string&amp; message);<br><br>    // 设置全局变量，存储类<span class="hljs-selector-tag">B</span>的对象引用<br>    static <span class="hljs-selector-tag">B</span> *ptrB;<br>&#125;;<br><br>// 声明类<span class="hljs-selector-tag">B</span><br>class <span class="hljs-selector-tag">B</span> &#123;<br>public:<br>    void <span class="hljs-built_in">funcB</span>(const std::string&amp; message) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Class B: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br><br>    // 成员函数，调用存储在类<span class="hljs-selector-tag">A</span>中的全局变量ptrB指向的对象的成员函数<br>    void callFuncA(const std::string&amp; message) &#123;<br>        <span class="hljs-selector-tag">A</span>::ptrB-&gt;<span class="hljs-built_in">funcA</span>(message);<br>    &#125;<br><br>    // 设置全局变量，存储类<span class="hljs-selector-tag">A</span>的对象引用<br>    static <span class="hljs-selector-tag">A</span> *ptrA;<br>&#125;;<br><br>// 在类<span class="hljs-selector-tag">A</span>外部实现funcA函数，使用全局变量调用类<span class="hljs-selector-tag">B</span>的成员函数<br>void <span class="hljs-selector-tag">A</span>::<span class="hljs-built_in">funcA</span>(const std::string&amp; message) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Class A: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    <span class="hljs-selector-tag">B</span>::ptrB-&gt;<span class="hljs-built_in">funcB</span>(<span class="hljs-string">&quot;Hello from class A!&quot;</span>);<br>&#125;<br><br>// 在类<span class="hljs-selector-tag">B</span>外部初始化全局变量ptrA和ptrB<br><span class="hljs-selector-tag">A</span> *<span class="hljs-selector-tag">B</span>::ptrA = nullptr;<br><span class="hljs-selector-tag">B</span> *<span class="hljs-selector-tag">A</span>::ptrB = nullptr;<br><br>int <span class="hljs-selector-tag">main</span>() &#123;<br>    <span class="hljs-selector-tag">A</span> <span class="hljs-selector-tag">a</span>;<br>    <span class="hljs-selector-tag">B</span> <span class="hljs-selector-tag">b</span>;<br><br>    // 设置类<span class="hljs-selector-tag">A</span>和类<span class="hljs-selector-tag">B</span>的全局变量，分别存储对彼此的对象引用<br>    <span class="hljs-selector-tag">A</span>::ptrB = &amp;b;<br>    <span class="hljs-selector-tag">B</span>::ptrA = &amp;a;<br><br>    // 调用类<span class="hljs-selector-tag">B</span>的成员函数，该成员函数会使用存储在类<span class="hljs-selector-tag">A</span>中的全局变量ptrB指向的对象的成员函数<br>    <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.callFuncA</span>(&quot;Hello <span class="hljs-selector-tag">from</span> class <span class="hljs-selector-tag">B</span>!&quot;);<br><br>    return <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们首先声明了类B，这样在类A的定义中就可以引用它。然后，我们在类A中定义了一个名为ptrB的静态成员变量，用于存储对类B对象的引用。在类B中也定义了一个名为ptrA的静态成员变量，用于存储对类A对象的引用。</p><p>在funcA函数中，我们使用存储在类A中的全局变量ptrB指向的类B对象，调用其成员函数funcB。在callFuncA函数中，我们使用存储在类B中的全局变量ptrA指向的类A对象，调用其成员函数funcA。</p><p>在main函数中，我们创建了类A和类B的对象，并设置了它们的全局变量，以便它们可以相互引用。然后，我们使用类B的对象调用了callFuncA函数，从而实现了类A和类B之间的相互调用。</p><p>需要注意的是，在使用全局变量来实现类之间的相互调用时，需要小心管理对象的生命周期，以避免出现悬垂指针等问题。另外，使用全局变量的方法通常不太推荐，因为它可能导致代码的可维护性和可扩展性变差。</p><p>除了使用全局变量，还可以使用依赖注入（Dependency Injection，简称DI）的方式来实现类之间的相互调用。依赖注入是一种面向对象编程中常见的设计模式，它通过将依赖关系从类内部移到外部，来实现松耦合和可测试性。</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>下面是一个示例代码，演示如何使用依赖注入实现类之间的相互调用：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;iostream&gt;<br><br><span class="hljs-comment">// 声明类B，因为类A需要引用它</span><br><span class="hljs-keyword">class</span> B;<br><br><span class="hljs-comment">// 声明类A</span><br><span class="hljs-keyword">class</span> A &#123;<br>public:<br>    void func<span class="hljs-constructor">A(<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span>&amp; <span class="hljs-params">message</span>)</span>;<br><br>    <span class="hljs-comment">// 成员变量，存储对类B的对象的引用</span><br>    B *ptrB;<br>&#125;;<br><br><span class="hljs-comment">// 声明类B</span><br><span class="hljs-keyword">class</span> B &#123;<br>public:<br>    void func<span class="hljs-constructor">B(<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span>&amp; <span class="hljs-params">message</span>)</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Class B: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 成员变量，存储对类A的对象的引用</span><br>    A *ptrA;<br><br>    <span class="hljs-comment">// 成员函数，调用存储在类A中的指针ptrB指向的对象的成员函数</span><br>    void call<span class="hljs-constructor">FuncA(<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span>&amp; <span class="hljs-params">message</span>)</span> &#123;<br>        ptrA-&gt;func<span class="hljs-constructor">A(<span class="hljs-params">message</span>)</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 在类A外部实现funcA函数，使用成员变量调用类B的成员函数</span><br>void A::func<span class="hljs-constructor">A(<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span>&amp; <span class="hljs-params">message</span>)</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Class A: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    ptrB-&gt;func<span class="hljs-constructor">B(<span class="hljs-string">&quot;Hello from class A!&quot;</span>)</span>;<br>&#125;<br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span> &#123;<br>    A a;<br>    B b;<br><br>    <span class="hljs-comment">// 设置类A和类B的成员变量，分别存储对彼此的对象的引用</span><br>    a.ptrB = &amp;b;<br>    b.ptrA = &amp;a;<br><br>    <span class="hljs-comment">// 调用类B的成员函数，该成员函数会使用存储在类A中的指针ptrB指向的对象的成员函数</span><br>    b.call<span class="hljs-constructor">FuncA(<span class="hljs-string">&quot;Hello from class B!&quot;</span>)</span>;<br><br>    return <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br>在这个例子中，我们在类A和类B中分别添加了一个成员变量，分别用于存储对另一个类对象的引用。在funcA函数中，我们使用存储在类A中的指针ptrB指向的类B对象，调用其成员函数funcB。在callFuncA函数中，我们使用存储在类B中的指针ptrA指向的类A对象，调用其成员函数funcA。</p><p>在main函数中，我们创建了类A和类B的对象，并设置了它们的成员变量，以便它们可以相互引用。然后，我们使用类B的对象调用了callFuncA函数，从而实现了类A和类B之间的相互调用。</p><p>需要注意的是，使用依赖注入的方式来实现类之间的相互调用，需要在构造对象时设置好依赖关系，以确保调用时的正确性。此外，需要小心管理对象的生命周期，以避免出现悬垂指针等问题。另外，使用依赖注入的方式可以提高代码的可维护性和可测试性，但也可能增加代码的复杂性，需要权衡利弊。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，C++提供了多种实现类之间相互调用的方法，包括成员函数参数传递、全局变量、依赖注入等。根据具体的应用场景和需求，可以选择合适的方法来实现类之间的相互调用。</p><p>当然，除了实现类之间的相互调用，C++中还有很多其他的面向对象编程特性和技术，例如继承、多态、虚函数、模板、STL等等。这些特性和技术可以帮助我们更好地组织和管理代码，提高代码的重用性、可维护性和可扩展性。</p><p>下面是一些常见的面向对象编程技巧和最佳实践：</p><p>遵循单一职责原则（SRP）：每个类应该有一个明确的职责，不要让一个类承担过多的责任。</p><p>遵循开闭原则（OCP）：类应该对扩展开放，对修改关闭，尽量避免在已有的类中直接修改代码。</p><p>遵循里氏替换原则（LSP）：子类应该能够替换其父类并出现在任何父类出现的地方，不破坏原有的程序逻辑。</p><p>使用虚函数和多态来实现动态绑定：通过使用虚函数和多态，可以在运行时确定对象的类型，实现动态绑定和多态性。</p><p>使用模板和泛型编程来实现代码的通用性：通过使用模板和泛型编程，可以实现代码的通用性，提高代码的重用性和可维护性。</p><p>使用STL库来简化代码：STL库提供了丰富的数据结构和算法，可以大大简化代码的编写过程，提高代码的可读性和可维护性。</p><p>总的来说，面向对象编程是一种重要的编程范式，可以帮助我们更好地组织和管理代码，提高代码的可维护性、可扩展性和可测试性。掌握面向对象编程的基本原理和技巧，可以帮助我们成为更好的程序员。</p><p>最后，为了更好地掌握面向对象编程，以下是一些学习面向对象编程的建议：</p><ol><li><p>学习面向对象编程的基本原理和概念：学习面向对象编程的第一步是了解面向对象编程的基本原理和概念，包括封装、继承、多态、类、对象等等。</p></li><li><p>学习面向对象编程的语言特性和技术：不同的编程语言提供了不同的面向对象编程特性和技术，例如C++中的虚函数、模板、STL等等，需要了解并掌握这些特性和技术。</p></li><li><p>阅读和分析优秀的面向对象编程代码：阅读和分析优秀的面向对象编程代码可以帮助我们更好地理解面向对象编程的实现细节和技巧，同时也可以借鉴和学习其他程序员的编码习惯和技术思路。</p></li><li><p>练习编写面向对象编程代码：通过实践编写面向对象编程代码，可以加深对面向对象编程的理解和掌握，同时也可以提高编程技能和代码质量。</p></li></ol><p>总的来说，学习面向对象编程需要不断地实践和探索，不断地学习和思考，才能不断地提高自己的编程能力和水平。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详细介绍ROS的nav_msgs/Path</title>
    <link href="/2023/04/19/%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8DROS%E7%9A%84nav-msgs-Path/"/>
    <url>/2023/04/19/%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8DROS%E7%9A%84nav-msgs-Path/</url>
    
    <content type="html"><![CDATA[<h1 id="详细介绍ROS的nav-msgs-Path"><a href="#详细介绍ROS的nav-msgs-Path" class="headerlink" title="详细介绍ROS的nav_msgs/Path"></a>详细介绍ROS的nav_msgs/Path</h1><p>nav_msgs/Path是ROS（Robot Operating System，机器人操作系统）中一个重要的消息类型，用于表示路径。它在导航、路径规划和控制等领域中具有关键作用。nav_msgs/Path消息类型主要包含两个字段：header和poses。</p><ol><li>header：这是一个std_msgs/Header类型的字段，包含了时间戳和坐标系信息。时间戳用于记录消息的生成时间，有助于同步和调试；坐标系信息则有助于将路径转换到其他参考系中。</li></ol><p>header字段中的属性如下：</p><ul><li>seq：一个用于表示消息序列号的无符号整数。</li><li>stamp：一个time类型的变量，表示消息生成时间。</li><li>frame_id：一个字符串，表示参考坐标系的ID。</li></ul><ol><li>poses：这是一个geometry_msgs/PoseStamped类型的数组，它包含了路径中的一系列位姿。数组中的每个元素都表示路径上的一个点，包括该点的位置（x, y, z）和方向（四元数表示）。</li></ol><p>geometry_msgs/PoseStamped中的属性如下：</p><ul><li>header：同样是一个std_msgs/Header类型的字段，包含了时间戳和坐标系信息。</li><li>pose：一个geometry_msgs/Pose类型的变量，包含了位置和方向信息。<br>position：一个geometry_msgs/Point类型的变量，表示位置（x, y, z）。<br>orientation：一个geometry_msgs/Quaternion类型的变量，表示方向（x, y, z, w）。</li></ul><p>在ROS中，nav_msgs/Path消息通常用于在节点之间传递路径规划结果、可视化路径以及将路径发送给控制器。此外，它还可以用于表示从机器人的起始位置到目标位置的一系列位姿点。</p><p>当使用ROS进行导航和路径规划时，nav_msgs/Path在多个环节发挥着作用。以下是一些常见的应用场景：</p><ol><li><p>全局路径规划：在导航过程中，全局路径规划器（如move_base中的global_planner）负责为机器人生成一条从起始位置到目标位置的安全路径。规划结果通常以nav_msgs/Path消息类型传递给其他节点。</p></li><li><p>局部路径规划：局部路径规划器（如move_base中的local_planner）会基于全局路径规划器生成的路径和机器人当前的局部环境信息，生成一个局部路径。这有助于机器人在实时环境中避开障碍物和动态调整路径。局部路径规划器同样使用nav_msgs/Path消息类型来表示局部路径。</p></li><li><p>路径跟踪：在收到路径后，控制器负责根据路径指引机器人运动。例如，diff_drive_controller可以将nav_msgs/Path消息转换为速度指令，使差速驱动的机器人沿规划路径行驶。</p></li><li><p>路径可视化：在ROS中，可以使用rviz工具对路径进行可视化。通过将nav_msgs/Path消息发布到特定的可视化主题，如/path或/trajectory，可以直观地显示路径规划结果。</p></li><li><p>多机器人协同：在多机器人系统中，nav_msgs/Path也可用于在机器人之间共享路径信息，以实现协同导航、避免碰撞等目的。</p></li></ol><p>注意，在处理nav_msgs/Path时，要确保坐标系之间的转换是正确的。tf库提供了便捷的坐标系转换功能，以确保位姿在不同的参考系中可以正确解释。</p><p>总之，nav_msgs/Path在ROS中扮演着重要角色，涉及到路径规划、可视化、控制器等多个方面，有助于实现高效、安全的机器人导航。除了前面提到的应用场景，nav_msgs/Path在ROS中还可以用于其他一些相关的任务，例如：  </p><ol><li><p>地图路径生成：在某些场景下，可能需要在已知的地图中生成一条指定的路径。通过使用特定的算法（例如A*算法、Dijkstra算法等），可以计算出一条从起始点到目标点的路径，并将结果存储为nav_msgs/Path消息类型。这种情况下，nav_msgs/Path用于表示地图中的路径信息，而不是实时导航的结果。</p></li><li><p>机器人控制接口：在某些应用中，可能需要通过外部控制接口（如Web端、手机APP等）为机器人提供路径信息。通过将路径信息转换为nav_msgs/Path消息并发布到机器人的导航节点，可以使机器人按照指定路径进行行动。这种情况下，nav_msgs/Path作为外部控制接口与机器人之间的通信桥梁。</p></li><li><p>自主路径学习：在机器人学习领域，nav_msgs/Path可以用于表示机器人自主学习的路径。例如，在强化学习中，机器人可能会自主探索环境并生成一条路径，然后将这条路径转换为nav_msgs/Path消息类型，以便于分析、评估和可视化。</p></li><li><p>路径优化：nav_msgs/Path可以作为输入来优化已生成的路径。例如，在生成一条路径后，可能需要对其进行平滑处理以减少曲率。可以将nav_msgs/Path作为输入，应用平滑算法（如贝塞尔曲线、样条曲线等），然后将优化后的路径重新封装为nav_msgs/Path消息并发布。</p></li><li><p>路径分析：nav_msgs/Path还可以用于分析路径的特性，例如长度、平均曲率、方向变化等。这些信息可以用于评估路径的质量、安全性和可行性，以便于在实际应用中选择最佳路径。</p></li></ol><p>这些应用场景进一步展示了nav_msgs/Path在ROS中的广泛用途。在实际项目中，可以灵活使用nav_msgs/Path来实现不同的功能，并根据需求进行扩展和定制。</p><h2 id="C-示例"><a href="#C-示例" class="headerlink" title="C++示例"></a>C++示例</h2><p>以下是一个简单的C++示例程序，演示了如何在ROS中创建、发布和订阅nav_msgs/Path消息。这个示例包含两个部分：一个路径发布节点（path_publisher_node）和一个路径订阅节点（path_subscriber_node）。</p><ol><li>路径发布节点（path_publisher_node）：</li></ol><p>首先，创建一个名为path_publisher_node的C++文件：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 包含所需的头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;nav_msgs/Path.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;geometry_msgs/PoseStamped.h&gt;</span></span><br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 初始化ROS节点</span><br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;path_publisher_node&quot;</span>);<br>  ros::NodeHandle nh;<br><br>  <span class="hljs-comment">// 创建一个Publisher，用于发布nav_msgs/Path消息</span><br>  ros::Publisher path_pub = nh.<span class="hljs-built_in">advertise</span>&lt;nav_msgs::Path&gt;(<span class="hljs-string">&quot;path&quot;</span>, <span class="hljs-number">1</span>);<br><br>  <span class="hljs-comment">// 设置发布频率</span><br>  <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br><br>  <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>  &#123;<br>    <span class="hljs-comment">// 创建一个nav_msgs/Path消息</span><br>    nav_msgs::Path path;<br>    path.header.stamp = ros::Time::<span class="hljs-built_in">now</span>();<br>    path.header.frame_id = <span class="hljs-string">&quot;map&quot;</span>;<br><br>    <span class="hljs-comment">// 添加几个位姿点到path中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i)<br>    &#123;<br>      geometry_msgs::PoseStamped pose_stamped;<br>      pose_stamped.header.stamp = ros::Time::<span class="hljs-built_in">now</span>();<br>      pose_stamped.header.frame_id = <span class="hljs-string">&quot;map&quot;</span>;<br>      pose_stamped.pose.position.x = i;<br>      pose_stamped.pose.position.y = <span class="hljs-number">2.0</span>;<br>      pose_stamped.pose.position.z = <span class="hljs-number">0.0</span>;<br>      pose_stamped.pose.orientation.w = <span class="hljs-number">1.0</span>;<br><br>      path.poses.<span class="hljs-built_in">push_back</span>(pose_stamped);<br>    &#125;<br><br>    <span class="hljs-comment">// 发布路径消息</span><br>    path_pub.<span class="hljs-built_in">publish</span>(path);<br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Path published.&quot;</span>);<br><br>    <span class="hljs-comment">// 按照设定的频率等待</span><br>    loop_rate.<span class="hljs-built_in">sleep</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><ol><li>路径订阅节点（path_subscriber_node）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 包含所需的头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;nav_msgs/Path.h&gt;</span></span><br><br><span class="hljs-comment">// 回调函数，处理接收到的nav_msgs/Path消息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pathCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> nav_msgs::Path::ConstPtr&amp; path_msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Received path with %zu poses.&quot;</span>, path_msg-&gt;poses.<span class="hljs-built_in">size</span>());<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 初始化ROS节点</span><br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;path_subscriber_node&quot;</span>);<br>  ros::NodeHandle nh;<br><br>  <span class="hljs-comment">// 创建一个Subscriber，用于订阅nav_msgs/Path消息</span><br>  ros::Subscriber path_sub = nh.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;path&quot;</span>, <span class="hljs-number">1</span>, pathCallback);<br><br>  <span class="hljs-comment">// 通过回调函数处理消息</span><br>  ros::<span class="hljs-built_in">spin</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>编译和运行示例程序：<br>为了编译和运行这个示例程序，请确保已经正确安装了ROS。然后，在你的ROS工作空间中创建一个名为path_example的包，并将以上两个C++文件添加到src目录下。接下来，按照以下步骤完成编译和运行：<br>a. 修改CMakeLists.txt文件：</li></ol><p>在path_example包的CMakeLists.txt文件中，首先找到find_package部分，并添加nav_msgs依赖项：<br><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">find_package</span>(<span class="hljs-variable">catkin</span> <span class="hljs-variable">REQUIRED</span> <span class="hljs-variable">COMPONENTS</span></span><br><span class="hljs-function">  <span class="hljs-variable">roscpp</span></span><br><span class="hljs-function">  <span class="hljs-variable">nav_msgs</span></span><br><span class="hljs-function">)</span><br><br></code></pre></td></tr></table></figure><br>然后，在catkin_package部分中添加nav_msgs：<br><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">catkin_package</span>(</span><br><span class="hljs-function">  <span class="hljs-variable">INCLUDE_DIRS</span> <span class="hljs-variable">include</span></span><br><span class="hljs-function">  <span class="hljs-variable">LIBRARIES</span> <span class="hljs-variable">path_example</span></span><br><span class="hljs-function">  <span class="hljs-variable">CATKIN_DEPENDS</span> <span class="hljs-variable">roscpp</span> <span class="hljs-variable">nav_msgs</span></span><br><span class="hljs-function">)</span><br><br></code></pre></td></tr></table></figure><br>接下来，添加可执行文件和目标链接库：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">add<span class="hljs-constructor">_executable(<span class="hljs-params">path_publisher_node</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">path_publisher_node</span>.<span class="hljs-params">cpp</span>)</span><br>target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">path_publisher_node</span> $&#123;<span class="hljs-params">catkin_LIBRARIES</span>&#125;)</span><br><br>add<span class="hljs-constructor">_executable(<span class="hljs-params">path_subscriber_node</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">path_subscriber_node</span>.<span class="hljs-params">cpp</span>)</span><br>target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">path_subscriber_node</span> $&#123;<span class="hljs-params">catkin_LIBRARIES</span>&#125;)</span><br><br></code></pre></td></tr></table></figure><br>b. 编译ROS包：</p><p>在终端中，进入ROS工作空间的根目录，并运行以下命令进行编译：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">catkin_make</span><br><br></code></pre></td></tr></table></figure></p><p>c. 运行节点：</p><p>在终端中，运行以下命令启动roscore：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">roscore</span><br><br></code></pre></td></tr></table></figure><br>接下来，打开另一个终端并运行以下命令启动path_publisher_node：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> devel/setup.bash<br>rosrun path_example path_publisher_node<br><br></code></pre></td></tr></table></figure><br>最后，在另一个新终端中运行以下命令启动path_subscriber_node：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> devel/setup.bash<br>rosrun path_example path_subscriber_node<br><br></code></pre></td></tr></table></figure><br>在path_subscriber_node所在的终端中，您将看到类似以下的输出：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">[<span class="hljs-symbol">INFO</span>] [<span class="hljs-number">1627590534.565542</span>]: <span class="hljs-symbol">Received</span> path with <span class="hljs-number">5</span> poses.<br>[<span class="hljs-symbol">INFO</span>] [<span class="hljs-number">1627590535.565542</span>]: <span class="hljs-symbol">Received</span> path with <span class="hljs-number">5</span> poses.<br>...<br><br></code></pre></td></tr></table></figure><br>这表明path_publisher_node发布的nav_msgs/Path消息已被path_subscriber_node成功接收。</p><h2 id="一些扩展和应用"><a href="#一些扩展和应用" class="headerlink" title="一些扩展和应用"></a>一些扩展和应用</h2><ol><li><p>路径可视化：为了更好地理解和调试路径，可以使用rviz工具进行可视化。启动rviz，然后添加一个Path显示类型。将Path显示类型的主题设置为/path，即我们在path_publisher_node中发布的nav_msgs/Path消息的主题。这样，您就可以看到路径在地图上的实际效果。</p></li><li><p>动态生成路径：在当前的示例中，路径是静态的，即每个发布周期都会发布相同的路径。您可以尝试修改path_publisher_node，使其动态生成不同的路径，以模拟实际导航场景中的变化。</p></li><li><p>路径处理和分析：在path_subscriber_node中，您可以对接收到的路径进行进一步处理和分析，例如计算路径长度、平均曲率等。此外，您还可以根据需求对路径进行优化，例如对路径进行平滑处理。</p></li><li><p>集成导航功能：要将此示例与实际导航功能集成，可以将path_publisher_node替换为全局路径规划器（如move_base中的global_planner），同时将path_subscriber_node替换为局部路径规划器或控制器（如move_base中的local_planner或diff_drive_controller）。这将使您的机器人能够根据nav_msgs/Path消息进行实际导航。</p></li><li><p>与其他ROS功能集成：您还可以将nav_msgs/Path消息与其他ROS功能（如传感器数据处理、SLAM、机器人控制等）集成，实现更加复杂的机器人应用。</p></li></ol><p>通过这个示例程序，您已经学会了如何在ROS中创建、发布和订阅nav_msgs/Path消息。您可以根据实际需求对示例进行扩展，以适应不同的机器人导航和控制场景。</p><h1 id="nav-msgs-Path相关的高级主题"><a href="#nav-msgs-Path相关的高级主题" class="headerlink" title="nav_msgs/Path相关的高级主题"></a>nav_msgs/Path相关的高级主题</h1><ol><li><p>融合多种传感器信息：在复杂的机器人系统中，可能需要融合多种传感器信息（如激光雷达、摄像头、超声波等）以生成更可靠和准确的路径。为了实现这一目标，您可以将传感器数据预处理节点和路径规划器相互连接，以便路径规划器可以根据融合后的环境信息生成路径。在这种情况下，nav_msgs/Path消息可以用于在各个节点之间传递路径信息。</p></li><li><p>使用路径规划算法库：在实际项目中，为了简化路径规划任务，您可以使用现有的路径规划算法库，例如OMPL（Open Motion Planning Library，开放运动规划库）。这些库通常提供了一系列成熟的路径规划算法，可以帮助您快速实现导航功能。在使用这些库时，您可能需要将算法库的输出转换为nav_msgs/Path消息，以便与ROS导航框架集成。</p></li><li><p>考虑不同类型的机器人：在不同类型的机器人（例如四足机器人、无人机等）中，nav_msgs/Path的应用可能会有所不同。例如，无人机可能需要考虑三维空间中的路径规划，而四足机器人可能需要考虑足迹规划。在这些情况下，您可能需要根据实际需求对nav_msgs/Path消息进行适当修改或扩展。</p></li><li><p>多机器人协同导航：在多机器人系统中，nav_msgs/Path可以用于在机器人之间共享路径信息。例如，当一个机器人检测到障碍物并规划出一条避障路径时，可以通过nav_msgs/Path消息将该路径分享给其他机器人，以实现协同避障。在这种情况下，您可能需要考虑如何在多机器人系统中同步和管理nav_msgs/Path消息。</p></li><li><p>实现自适应路径规划：在某些场景下，可能需要根据环境的变化实时调整路径。例如，在机器人遇到动态障碍物时，可能需要重新规划路径。为了实现这一目标，您可以监控nav_msgs/Path消息，当检测到路径不再可行时，触发重新规划过程。这将使您的机器人能够在复杂环境中进行自适应导航。</p></li><li><p>利用机器学习进行路径规划：传统的路径规划方法通常基于搜索和优化算法。然而，近年来，基于机器学习的方法在路径规划领域也表现出了强大的性能。例如，通过使用深度学习来处理图像数据，可以从摄像头图像中直接推导出可行的路径。在这种情况下，您可以将机器学习模型的输出转换为nav_msgs/Path消息，以便与其他ROS节点集成。</p></li><li><p>模拟环境中的路径规划：在开发和测试机器人导航系统时，通常需要使用模拟环境。例如，您可以使用Gazebo模拟器构建虚拟的机器人和环境。在模拟环境中，您可以生成nav_msgs/Path消息，以便在不同的场景中评估和验证路径规划算法的性能。此外，您还可以使用ROS的仿真时间功能来控制模拟过程，以便更加精确地模拟实际环境中的时间变化。</p></li><li><p>路径的全局优化：在某些场景下，可能需要对规划出的路径进行全局优化，以实现更高效的导航。例如，您可以通过约束规划、最优控制等方法，将路径优化为最短路径、最小能耗路径等。在这些情况下，您可以使用nav_msgs/Path消息来存储和传递优化后的路径信息。</p></li><li><p>考虑社会规范的路径规划：在人机共享环境中，机器人可能需要遵循人类的社会规范来规划路径。例如，机器人应该避免穿越人群或者靠近人们的私人空间。为了实现这一目标，您可以将机器人的路径规划算法与人类行为建模方法相结合。在这种情况下，nav_msgs/Path消息可以用于存储和传递考虑社会规范的路径信息。</p></li><li><p>融合地图和路径信息：在某些场景下，可能需要将地图信息（例如栅格地图或者点云地图）与路径信息相结合，以实现更准确和可靠的导航。例如，您可以通过考虑地图中的障碍物、行驶区域等信息，来生成更加安全和高效的路径。在这种情况下，您可以使用nav_msgs/Path消息来存储和传递</p></li><li><p>将路径规划与避障结合：在实际导航过程中，机器人可能需要实时规划路径并避免障碍物。为了实现这一目标，您可以将局部避障算法与全局路径规划算法相结合。在这种情况下，nav_msgs/Path消息可以用于在全局路径规划器和局部避障器之间传递路径信息，以便机器人可以根据实时环境信息进行导航。</p></li><li><p>使用路径跟踪算法：在机器人导航过程中，需要设计路径跟踪算法来实现对预定路径的精确跟踪。您可以使用各种路径跟踪算法（如纯跟踪、模型预测控制等），根据nav_msgs/Path消息中的路径信息来控制机器人的运动。这将使您的机器人能够实现精确的路径跟踪和控制。</p></li><li><p>实现不确定性建模和预测：在复杂环境中，机器人的导航过程可能受到不确定性因素的影响，如传感器噪声、动态障碍物等。为了实现更可靠的导航，您可以利用概率建模和预测方法（如贝叶斯滤波、卡尔曼滤波等）来处理这些不确定性。在这种情况下，您可以使用nav_msgs/Path消息来存储和传递考虑不确定性因素的路径信息。</p></li><li><p>基于ROS的导航框架：要实现完整的机器人导航功能，可以使用现有的基于ROS的导航框架，如move_base或Navigation2。这些框架提供了一系列成熟的功能，如地图服务、定位、路径规划、避障等，可以帮助您快速构建机器人导航系统。在使用这些框架时，nav_msgs/Path消息将在不同功能模块之间传递路径信息。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解ROS中的CMakeLists</title>
    <link href="/2023/04/19/%E8%AF%A6%E8%A7%A3ROS%E4%B8%AD%E7%9A%84CMakeLists/"/>
    <url>/2023/04/19/%E8%AF%A6%E8%A7%A3ROS%E4%B8%AD%E7%9A%84CMakeLists/</url>
    
    <content type="html"><![CDATA[<h1 id="详解ROS中的CMakeLists"><a href="#详解ROS中的CMakeLists" class="headerlink" title="详解ROS中的CMakeLists"></a>详解ROS中的CMakeLists</h1><p>在ROS（Robot Operating System）中，CMakeLists.txt文件是项目构建配置文件，它定义了如何构建ROS包中的可执行文件、库文件以及如何处理依赖关系等。CMakeLists.txt文件使用CMake语法编写，CMake是一个跨平台的构建系统，用于自动化编译、链接和打包过程。</p><p>下面我们详细介绍ROS中CMakeLists.txt的常用配置项：</p><ol><li>最低CMake版本要求：<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cmake_minimum_required</span>(VERSION <span class="hljs-number">2</span>.<span class="hljs-number">8</span>.<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>这行代码定义了项目所需的最低CMake版本。在ROS中，通常需要CMake 2.8.3及以上版本  </li><li>项目名称：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">project</span><span class="hljs-params">(my_ros_package)</span></span><br></code></pre></td></tr></table></figure>这里定义了项目的名称，通常与ROS包名相同。</li><li>查找依赖包：<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">find_package</span>(<span class="hljs-variable">catkin</span> <span class="hljs-variable">REQUIRED</span> <span class="hljs-variable">COMPONENTS</span></span><br><span class="hljs-function">  <span class="hljs-variable">roscpp</span></span><br><span class="hljs-function">  <span class="hljs-variable">rospy</span></span><br><span class="hljs-function">  <span class="hljs-variable">std_msgs</span></span><br><span class="hljs-function">  <span class="hljs-variable">message_generation</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure>find_package()函数用于查找项目所需的依赖包。REQUIRED关键字表示必须找到这些依赖包，否则构建过程将失败。COMPONENTS关键字后面的参数是需要查找的依赖包列表。  </li><li>声明构建依赖和运行时依赖：<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">catkin_package</span>(</span><br><span class="hljs-function">  <span class="hljs-variable">INCLUDE_DIRS</span> <span class="hljs-variable">include</span></span><br><span class="hljs-function">  <span class="hljs-variable">LIBRARIES</span> <span class="hljs-variable">my_ros_package</span></span><br><span class="hljs-function">  <span class="hljs-variable">CATKIN_DEPENDS</span> <span class="hljs-variable">roscpp</span> <span class="hljs-variable">rospy</span> <span class="hljs-variable">std_msgs</span> <span class="hljs-variable">message_runtime</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure>catkin_package()函数用于声明项目的构建依赖和运行时依赖。INCLUDE_DIRS指定头文件的目录，LIBRARIES指定项目生成的库文件，CATKIN_DEPENDS声明了项目在构建和运行时所依赖的其他ROS包。  </li><li>添加头文件目录：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">include_directories</span>(<br>  <span class="hljs-keyword">include</span><br>  <span class="hljs-variable">$&#123;catkin_INCLUDE_DIRS&#125;</span><br>)<br></code></pre></td></tr></table></figure>include_directories()函数用于指定项目的头文件目录。这里包括了include目录和catkin_INCLUDE_DIRS（包含所有依赖包的头文件目录）。  </li><li>添加可执行文件：<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">add<span class="hljs-constructor">_executable(<span class="hljs-params">my_node</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">my_node</span>.<span class="hljs-params">cpp</span>)</span><br></code></pre></td></tr></table></figure>add_executable()函数用于添加可执行文件。第一个参数是可执行文件的名称，第二个参数是源文件路径。  </li><li>链接库文件：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(my_node<br>  <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span><br>)<br></code></pre></td></tr></table></figure>target_link_libraries()函数用于为指定的可执行文件链接库文件。在本例中，为my_node可执行文件链接catkin_LIBRARIES，即所有依赖包的库文件。  </li><li>添加依赖：<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">add<span class="hljs-constructor">_dependencies(<span class="hljs-params">my_node</span> $&#123;$&#123;PROJECT_NAME&#125;<span class="hljs-params">_EXPORTED_TARGETS</span>&#125; $&#123;<span class="hljs-params">catkin_EXPORTED_TARGETS</span>&#125;)</span><br></code></pre></td></tr></table></figure>add_dependencies()函数用于为指定的可执行文件添加依赖。在本例中，为my_node添加了项目导出目标和catkin_EXPORTED_TARGETS的依赖。  </li><li>安装<br>在CMakeLists.txt中，可以使用install()函数指定在构建过程中生成的可执行文件、库文件、头文件以及其他相关文件的安装路径。这些安装路径与ROS的devel和install目录有关。</li></ol><p>例如，可以通过以下方式安装可执行文件、库文件和头文件：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">install</span>(TARGETS my_node<br>  RUNTIME DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br><br><span class="hljs-keyword">install</span>(TARGETS my_library<br>  ARCHIVE DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span><br>  LIBRARY DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span><br>)<br><br><span class="hljs-keyword">install</span>(DIRECTORY <span class="hljs-keyword">include</span>/<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>/<br>  DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_INCLUDE_DESTINATION&#125;</span><br>)<br></code></pre></td></tr></table></figure></p><ol><li>安装其他资源文件：<br>除了可执行文件、库文件和头文件外，还可以安装其他资源文件，例如launch文件、配置文件和地图文件等。以下是一些示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">install(DIRECTORY launch/<br>  DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;</span>/launch<br>)<br><br>install(DIRECTORY config/<br>  DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;</span>/config<br>)<br><br>install(DIRECTORY maps/<br>  DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;</span>/maps<br>)<br></code></pre></td></tr></table></figure>这些配置选项为ROS项目中的CMakeLists.txt文件提供了基本框架。根据项目的具体需求，可以对这些选项进行调整和扩展。例如，可以为项目添加自定义消息、服务和动作定义，配置不同的库文件和可执行文件，以及安装其他所需资源。</li></ol><p>综上所述，ROS中的CMakeLists.txt文件负责管理构建过程，包括依赖关系、可执行文件、库文件、头文件等。为了使项目正常运行，需要正确地配置CMakeLists.txt文件。</p><h2 id="自定义消息、服务和动作定义的处理"><a href="#自定义消息、服务和动作定义的处理" class="headerlink" title="自定义消息、服务和动作定义的处理"></a>自定义消息、服务和动作定义的处理</h2><p>接下来，我们将深入探讨ROS中的CMakeLists.txt文件，包括自定义消息、服务和动作定义的处理。</p><ol><li>自定义消息（msg）：<br>要创建自定义消息，需要在项目的msg目录中定义.msg文件。接下来，在CMakeLists.txt中，将以下内容添加到find_package()函数中：<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">message_generation</span><br></code></pre></td></tr></table></figure>然后添加如下指令来指定要生成的自定义消息文件：<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">add_message_files</span>(</span><br><span class="hljs-function">  <span class="hljs-variable">FILES</span></span><br><span class="hljs-function">  <span class="hljs-variable">MyCustomMessage.msg</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure>接下来，调用generate_messages()函数来生成消息文件：<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">generate_messages</span>(</span><br><span class="hljs-function">  <span class="hljs-variable">DEPENDENCIES</span></span><br><span class="hljs-function">  <span class="hljs-variable">std_msgs</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure>这里，DEPENDENCIES指定了自定义消息所依赖的其他消息包。  </li><li>自定义服务（srv）：<br>与自定义消息类似，自定义服务需要在项目的srv目录中定义.srv文件。然后，在CMakeLists.txt中，将以下内容添加到find_package()函数中：<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">message_generation</span><br><br></code></pre></td></tr></table></figure>接着添加如下指令来指定要生成的自定义服务文件：<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">add_service_files</span>(</span><br><span class="hljs-function">  <span class="hljs-variable">FILES</span></span><br><span class="hljs-function">  <span class="hljs-variable">MyCustomService.srv</span></span><br><span class="hljs-function">)</span><br><br></code></pre></td></tr></table></figure>接下来，调用generate_messages()函数来生成服务文件：<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">generate_messages</span>(</span><br><span class="hljs-function">  <span class="hljs-variable">DEPENDENCIES</span></span><br><span class="hljs-function">  <span class="hljs-variable">std_msgs</span></span><br><span class="hljs-function">)</span><br><br></code></pre></td></tr></table></figure></li><li><p>自定义动作（action）：<br>要创建自定义动作，需要在项目的action目录中定义.action文件。在CMakeLists.txt中，将以下内容添加到find_package()函数中：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">actionlib_msgs</span><br><br></code></pre></td></tr></table></figure><p>然后添加如下指令来指定要生成的自定义动作文件：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">add_action_files</span>(</span><br><span class="hljs-function">  <span class="hljs-variable">FILES</span></span><br><span class="hljs-function">  <span class="hljs-variable">MyCustomAction.action</span></span><br><span class="hljs-function">)</span><br><br></code></pre></td></tr></table></figure><p>接着，调用generate_messages()函数来生成动作文件：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">generate_messages</span>(</span><br><span class="hljs-function">  <span class="hljs-variable">DEPENDENCIES</span></span><br><span class="hljs-function">  <span class="hljs-variable">std_msgs</span> <span class="hljs-variable">actionlib_msgs</span></span><br><span class="hljs-function">)</span><br><br></code></pre></td></tr></table></figure><p>在处理自定义消息、服务和动作时，还需要在catkin_package()函数中添加CATKIN_DEPENDS message_runtime以声明运行时依赖：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">catkin_package</span>(</span><br><span class="hljs-function">  ...</span><br><span class="hljs-function">  CATKIN_DEPENDS <span class="hljs-variable">message_runtime</span></span><br><span class="hljs-function">)</span><br><br></code></pre></td></tr></table></figure><p>总之，ROS的CMakeLists.txt文件涵盖了项目构建过程中的各个方面，包括依赖关系、可执行文件、库文件、头文件以及自定义消息、服务和动作。正确配置CMakeLists.txt文件，可确保ROS项目的顺利构建和运行。</p><h2 id="高级配置选项和技巧"><a href="#高级配置选项和技巧" class="headerlink" title="高级配置选项和技巧"></a>高级配置选项和技巧</h2><p>现在让我们继续深入探讨ROS中CMakeLists.txt的一些高级配置选项和技巧。</p></li><li><p>设置编译标志：</p></li></ol><p>在CMakeLists.txt中，可以为项目设置编译标志。例如，可以使用以下指令为C++源文件启用C++11标准：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">set</span><span class="hljs-params">(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">set</span><span class="hljs-params">(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span><br><br></code></pre></td></tr></table></figure><br>如果要设置特定的编译器选项，可以使用set()函数：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> -Wall -Wextra&quot;</span>)<br><br></code></pre></td></tr></table></figure><br>上述代码将为项目启用了所有警告（-Wall）以及额外警告（-Wextra）。</p><ol><li>添加自定义CMake模块： </li></ol><p>在某些情况下，可能需要使用自定义CMake模块来扩展项目的构建过程。为此，可以在项目的cmake目录中创建自定义CMake模块，并在CMakeLists.txt中使用list(APPEND …)和find_package()函数将其添加到CMAKE_MODULE_PATH：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">list</span><span class="hljs-params">(APPEND CMAKE_MODULE_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake)</span></span><br><span class="hljs-function"><span class="hljs-title">find_package</span><span class="hljs-params">(MyCustomCMakeModule REQUIRED)</span></span><br><br></code></pre></td></tr></table></figure></p><ol><li>条件编译：</li></ol><p>在某些情况下，可能需要根据特定条件启用或禁用项目中的某些功能。可以使用option()函数和if()语句来实现这一目标：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">option</span>(ENABLE_MY_FEATURE <span class="hljs-string">&quot;Enable my custom feature&quot;</span> <span class="hljs-keyword">OFF</span>)<br><br><span class="hljs-keyword">if</span>(ENABLE_MY_FEATURE)<br>  <span class="hljs-comment"># Add custom code or configuration for the feature</span><br>  <span class="hljs-keyword">add_definitions</span>(-DENABLE_MY_FEATURE)<br><span class="hljs-keyword">endif</span>()<br><br></code></pre></td></tr></table></figure><br>上述代码定义了一个名为ENABLE_MY_FEATURE的选项，默认值为OFF。如果选项被启用，将会添加一个预处理器定义ENABLE_MY_FEATURE。</p><ol><li>为项目添加测试：</li></ol><p>在ROS项目中，可以使用catkin_add_gtest()函数和gtest库为项目添加单元测试。首先，确保在find_package()函数中添加了rostest组件：<br><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">find_package</span>(<span class="hljs-variable">catkin</span> <span class="hljs-variable">REQUIRED</span> <span class="hljs-variable">COMPONENTS</span></span><br><span class="hljs-function">  ...</span><br><span class="hljs-function">  rostest</span><br><span class="hljs-function">)</span><br><br></code></pre></td></tr></table></figure><br>然后添加测试可执行文件和链接库：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">catkin<span class="hljs-constructor">_add_gtest(<span class="hljs-params">my_test</span> <span class="hljs-params">test</span><span class="hljs-operator">/</span><span class="hljs-params">my_test</span>.<span class="hljs-params">cpp</span>)</span><br>target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">my_test</span> $&#123;<span class="hljs-params">catkin_LIBRARIES</span>&#125; <span class="hljs-params">my_library</span>)</span><br><br></code></pre></td></tr></table></figure><br>以上示例中，my_test是测试的名称，test/my_test.cpp是测试源文件，而my_library是测试所需链接的库。</p><p>这些高级配置选项和技巧可以帮助你在ROS项目中实现更复杂的构建过程。理解这些选项的用途和功能，将有助于创建更可扩展和可维护的ROS项目。</p><h2 id="实现一些实用功能和配置"><a href="#实现一些实用功能和配置" class="headerlink" title="实现一些实用功能和配置"></a>实现一些实用功能和配置</h2><p>接下来，我们将讨论如何在ROS中的CMakeLists.txt文件中实现一些实用功能和配置：</p><ol><li>添加Python可执行文件：</li></ol><p>在ROS项目中，你可能需要添加Python脚本作为可执行文件。首先，确保在find_package()函数中添加了rospy组件：<br><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">find_package</span>(<span class="hljs-variable">catkin</span> <span class="hljs-variable">REQUIRED</span> <span class="hljs-variable">COMPONENTS</span></span><br><span class="hljs-function">  ...</span><br><span class="hljs-function">  rospy</span><br><span class="hljs-function">)</span><br><br></code></pre></td></tr></table></figure><br>然后，可以使用catkin_install_python()函数将Python脚本安装为可执行文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">catkin_install_python(PROGRAMS scripts/my_python_script.py<br>  DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br><br></code></pre></td></tr></table></figure></p><ol><li>添加动态链接库（动态库）：</li></ol><p>有时候，可能需要在ROS项目中创建动态链接库。为此，可以使用add_library()函数和SHARED关键字：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">add<span class="hljs-constructor">_library(<span class="hljs-params">my_shared_library</span> SHARED <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">my_shared_library</span>.<span class="hljs-params">cpp</span>)</span><br><br></code></pre></td></tr></table></figure><br>接着，为生成的库文件添加安装目标：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">install</span>(TARGETS my_shared_library<br>  LIBRARY DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span><br>)<br><br></code></pre></td></tr></table></figure></p><ol><li>链接系统库：</li></ol><p>在某些情况下，可能需要链接系统库。可以使用find_library()函数查找系统库，并使用target_link_libraries()函数将其链接到目标：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">find_library(MY_SYSTEM_LIBRARY<br>  NAMES my_system_library<br>  PATHS <span class="hljs-regexp">/path/</span>to/libraries<br>)<br><br>target_link_libraries(my_executable<br>  <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span><br>  <span class="hljs-variable">$&#123;MY_SYSTEM_LIBRARY&#125;</span><br>)<br><br></code></pre></td></tr></table></figure></p><ol><li>链接Boost库：<br>在ROS项目中，可能需要使用Boost库。为此，首先确保在find_package()函数中添加了Boost组件：<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">find_package</span>(<span class="hljs-variable">Boost</span> <span class="hljs-variable">REQUIRED</span> <span class="hljs-variable">COMPONENTS</span></span><br><span class="hljs-function">  <span class="hljs-variable">system</span></span><br><span class="hljs-function">  <span class="hljs-variable">thread</span></span><br><span class="hljs-function">)</span><br><br></code></pre></td></tr></table></figure>然后，将Boost库添加到target_link_libraries()函数中：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(my_executable<br>  <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span><br>  <span class="hljs-variable">$&#123;Boost_LIBRARIES&#125;</span><br>)<br><br></code></pre></td></tr></table></figure></li><li>使用环境变量：</li></ol><p>在CMakeLists.txt中，可以通过$ENV{VAR_NAME}语法访问环境变量。例如，以下代码从环境变量MY_VAR获取值并将其存储在CMake变量my_var中：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">set</span><span class="hljs-params">(my_var <span class="hljs-variable">$ENV</span>&#123;MY_VAR&#125;)</span></span><br><br></code></pre></td></tr></table></figure><br>了解这些实用功能和配置将有助于处理ROS项目中的各种需求。这些示例可以根据项目需求进行调整和扩展，以便更好地适应特定的构建环境和依赖关系。现在让我们继续探讨ROS中CMakeLists.txt文件的一些其他实用功能和技巧。</p><h2 id="使用外部项目"><a href="#使用外部项目" class="headerlink" title="使用外部项目"></a>使用外部项目</h2><p>在ROS项目中，可能需要使用外部项目的代码和资源。CMake具有一个名为ExternalProject的模块，可用于下载、构建和安装外部项目。首先，需要在CMakeLists.txt中包含ExternalProject模块：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">include</span><span class="hljs-params">(ExternalProject)</span></span><br><br></code></pre></td></tr></table></figure><br>接下来，使用ExternalProject_Add()函数定义外部项目：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ExternalProject_Add(my_external_project<br>  GIT_REPOSITORY <span class="hljs-string">&quot;https://github.com/user/my_external_project.git&quot;</span><br>  GIT_TAG <span class="hljs-string">&quot;master&quot;</span><br>  CMAKE_ARGS <span class="hljs-attribute">-DCMAKE_INSTALL_PREFIX</span>=<span class="hljs-variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/external<br>)<br><br></code></pre></td></tr></table></figure><br>这里，my_external_project是外部项目的名称，GIT_REPOSITORY和GIT_TAG指定了项目的源代码仓库和分支。CMAKE_ARGS用于传递给外部项目的CMake构建的参数，其中CMAKE_INSTALL_PREFIX指定了安装路径。</p><h2 id="使用pkg-config："><a href="#使用pkg-config：" class="headerlink" title="使用pkg-config："></a>使用pkg-config：</h2><p>有时，可能需要使用pkg-config工具查询库的编译和链接标志。CMake提供了一个名为PkgConfig的模块，可用于与pkg-config交互。首先，需要在CMakeLists.txt中包含PkgConfig模块：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">find_package</span><span class="hljs-params">(PkgConfig REQUIRED)</span></span><br><br></code></pre></td></tr></table></figure><br>然后，可以使用pkg_check_modules()函数查询库信息：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">pkg_check_modules</span><span class="hljs-params">(MY_LIBRARY_PKGCONFIG REQUIRED my_library)</span></span><br><br></code></pre></td></tr></table></figure><br>接下来，可以使用查询到的信息为目标设置编译和链接标志：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">target_include_directories</span><span class="hljs-params">(my_executable PRIVATE $&#123;MY_LIBRARY_PKGCONFIG_INCLUDE_DIRS&#125;)</span></span><br><span class="hljs-function"><span class="hljs-title">target_link_libraries</span><span class="hljs-params">(my_executable $&#123;catkin_LIBRARIES&#125; $&#123;MY_LIBRARY_PKGCONFIG_LIBRARIES&#125;)</span></span><br><br></code></pre></td></tr></table></figure></p><h2 id="在ROS中使用Eigen库："><a href="#在ROS中使用Eigen库：" class="headerlink" title="在ROS中使用Eigen库："></a>在ROS中使用Eigen库：</h2><p>在ROS项目中，可能需要使用Eigen库进行线性代数计算。首先，确保在find_package()函数中添加了Eigen3组件：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">find_package</span><span class="hljs-params">(Eigen3 REQUIRED)</span></span><br><br></code></pre></td></tr></table></figure><br>然后，将Eigen库添加到target_include_directories()函数中：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_include_directories</span>(my_executable<br>  PRIVATE<br>    <span class="hljs-variable">$&#123;EIGEN3_INCLUDE_DIRS&#125;</span><br>)<br><br></code></pre></td></tr></table></figure><br>这些实用功能和技巧可以帮助您在ROS项目中处理各种需求和依赖项。了解如何使用这些功能可以使您的项目更具灵活性和可扩展性，同时确保与其他库和软件包的兼容性。请注意，这些示例可能需要根据项目的具体需求进行调整。</p><h2 id="使用OpenCV库"><a href="#使用OpenCV库" class="headerlink" title="使用OpenCV库"></a>使用OpenCV库</h2><p>在ROS项目中，可能需要使用OpenCV库进行计算机视觉处理。首先，在find_package()函数中添加OpenCV组件：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">find_package</span><span class="hljs-params">(OpenCV REQUIRED)</span></span><br><br></code></pre></td></tr></table></figure><br>接下来，在target_link_libraries()函数中链接OpenCV库：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(my_executable <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span> <span class="hljs-variable">$&#123;OpenCV_LIBRARIES&#125;</span>)<br><br></code></pre></td></tr></table></figure></p><h2 id="设置安装规则"><a href="#设置安装规则" class="headerlink" title="设置安装规则"></a>设置安装规则</h2><p>在ROS项目中，通过使用install()函数，可以将构建的可执行文件、库文件、头文件和其他资源文件安装到目标目录，以方便分发和部署。下面是一些常见的安装规则示例：</p><p>安装可执行文件：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">install</span>(TARGETS my_executable<br>  RUNTIME DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br><br></code></pre></td></tr></table></figure></p><p>安装库文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">install</span>(TARGETS my_library<br>  ARCHIVE DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span><br>  LIBRARY DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span><br>)<br><br></code></pre></td></tr></table></figure><p>安装头文件：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">install</span>(DIRECTORY <span class="hljs-keyword">include</span>/<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>/<br>  DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_INCLUDE_DESTINATION&#125;</span><br>)<br><br></code></pre></td></tr></table></figure><br>安装资源文件（如配置文件、launch文件等）：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">install</span>(DIRECTORY config launch<br>  DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;</span><br>)<br><br></code></pre></td></tr></table></figure></p><h2 id="在CMakeLists-txt中添加自定义命令"><a href="#在CMakeLists-txt中添加自定义命令" class="headerlink" title="在CMakeLists.txt中添加自定义命令"></a>在CMakeLists.txt中添加自定义命令</h2><p>有时，可能需要在构建过程中执行一些自定义操作，如生成代码或处理资源文件。可以使用add_custom_command()函数在CMakeLists.txt中定义自定义命令：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-built_in">add_custom_command</span>(<br>  OUTPUT generated_file<span class="hljs-selector-class">.cpp</span><br>  COMMAND my_generator_tool <span class="hljs-attr">--input</span>=input_file <span class="hljs-attr">--output</span>=generated_file<span class="hljs-selector-class">.cpp</span><br>  DEPENDS input_file<br>)<br><br></code></pre></td></tr></table></figure><br>上述代码指定了一个自定义命令，它在generated_file.cpp文件不存在或input_file文件发生更改时，运行my_generator_tool工具。</p><h2 id="使用message、service和action文件生成代码"><a href="#使用message、service和action文件生成代码" class="headerlink" title="使用message、service和action文件生成代码"></a>使用message、service和action文件生成代码</h2><p>ROS中的消息、服务和动作定义文件需要生成相应的C++、Python等语言的代码。在CMakeLists.txt中，可以使用以下函数生成代码：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs clean"># Generate message <span class="hljs-keyword">code</span><br>add_message_files(<br>  FILES<br>  MyMessage.msg<br>)<br><br># Generate service <span class="hljs-keyword">code</span><br>add_service_files(<br>  FILES<br>  MyService.srv<br>)<br><br># Generate action <span class="hljs-keyword">code</span><br>add_action_files(<br>  FILES<br>  MyAction.action<br>)<br><br></code></pre></td></tr></table></figure><br>生成代码之前，需要确保在find_package()函数中添加了message_generation、actionlib_msgs等组件：<br><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">find_package</span>(<span class="hljs-variable">catkin</span> <span class="hljs-variable">REQUIRED</span> <span class="hljs-variable">COMPONENTS</span></span><br><span class="hljs-function">  ...</span><br><span class="hljs-function">  message_generation</span><br><span class="hljs-function">  <span class="hljs-variable">actionlib_msgs</span></span><br><span class="hljs-function">)</span><br><br></code></pre></td></tr></table></figure><br>然后，使用generate_messages()函数生成代码：<br><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">generate_messages</span>(</span><br><span class="hljs-function">  <span class="hljs-variable">DEPENDENCIES</span></span><br><span class="hljs-function">  <span class="hljs-variable">std_msgs</span></span><br><span class="hljs-function">  <span class="hljs-variable">actionlib_msgs</span></span><br><span class="hljs-function">)</span><br><br></code></pre></td></tr></table></figure></p><p>使用message、service和action文件的依赖关系：</p><p>有时候，一个ROS软件包可能依赖于另一个软件包中定义的消息、服务或动作。在这种情况下，需要确保在find_package()函数中添加了相应的组件：<br><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">find_package</span>(<span class="hljs-variable">catkin</span> <span class="hljs-variable">REQUIRED</span> <span class="hljs-variable">COMPONENTS</span></span><br><span class="hljs-function">  ...</span><br><span class="hljs-function">  other_package_msgs</span><br><span class="hljs-function">)</span><br><br></code></pre></td></tr></table></figure><br>此外，还需要将依赖关系添加到catkin_package()函数中：<br><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">catkin_package</span>(</span><br><span class="hljs-function">  ...</span><br><span class="hljs-function">  CATKIN_DEPENDS <span class="hljs-variable">other_package_msgs</span></span><br><span class="hljs-function">)</span><br><br></code></pre></td></tr></table></figure></p><h2 id="使用CMake的message-函数"><a href="#使用CMake的message-函数" class="headerlink" title="使用CMake的message()函数"></a>使用CMake的message()函数</h2><p>在CMakeLists.txt文件中，可以使用message()函数打印调试信息。这对于调试构建过程中的问题很有帮助。message()函数接受不同的严重性级别，例如：STATUS、WARNING和FATAL_ERROR。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">message</span><span class="hljs-params">(STATUS <span class="hljs-string">&quot;This is a status message&quot;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">message</span><span class="hljs-params">(WARNING <span class="hljs-string">&quot;This is a warning message&quot;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">message</span><span class="hljs-params">(FATAL_ERROR <span class="hljs-string">&quot;This is a fatal error message&quot;</span>)</span></span><br><br></code></pre></td></tr></table></figure><br>通过掌握这些实用功能和技巧，可以帮助您在ROS项目中应对各种需求和依赖。了解如何使用这些功能可以使您的项目更具灵活性和可扩展性，同时确保与其他库和软件包的兼容性。请注意，这些示例可能需要根据项目的具体需求进行调整。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解ros::ServiceServer的使用方法</title>
    <link href="/2023/04/19/%E8%AF%A6%E8%A7%A3ros-ServiceServer%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2023/04/19/%E8%AF%A6%E8%A7%A3ros-ServiceServer%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="详解ros-ServiceServer的使用方法"><a href="#详解ros-ServiceServer的使用方法" class="headerlink" title="详解ros::ServiceServer的使用方法"></a>详解ros::ServiceServer的使用方法</h1><p>ros::ServiceServer是ROS（Robot Operating System）中提供服务的关键组件。它允许节点向其他节点提供服务，使得其他节点可以请求并获取服务结果。在ROS中，服务是一种同步通信机制，允许节点之间进行请求-应答式的通信。</p><p>以下是使用ros::ServiceServer的详细步骤：</p><ol><li>包含必要的头文件：<br>在C++代码中，需要包含服务的头文件和ros/ros.h。假设服务的类型为my_package::MyService，则需要包含以下头文件：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_package/MyService.h&quot;</span></span><br></code></pre></td></tr></table></figure></li><li>编写服务处理函数：<br>编写一个函数，该函数用于处理服务请求并生成响应。函数的参数类型应该是服务请求的常量指针和服务响应的指针。例如：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">bool</span> <span class="hljs-title function_ invoke__">myServiceCallback</span>(my_package::<span class="hljs-variable constant_">MyService</span>::<span class="hljs-variable constant_">Request</span> &amp;req,<br>                       my_package::<span class="hljs-variable constant_">MyService</span>::<span class="hljs-variable constant_">Response</span> &amp;res)<br>&#123;<br>  <span class="hljs-comment">// 处理服务请求，例如：</span><br>  res.result = req.a + req.b;<br><br>  <span class="hljs-comment">// 返回值表示服务是否成功处理</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>初始化ROS节点：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;my_service_server&quot;</span>);<br>  ros::NodeHandle nh;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>创建ros::ServiceServer实例：<br>在main()函数中，使用NodeHandle的advertiseService()方法创建一个ros::ServiceServer实例。将服务处理函数作为回调传递给此方法。例如：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> ...<br>ros::ServiceServer service = nh.advertiseService(<span class="hljs-string">&quot;my_service&quot;</span>, myServiceCallback);<br><span class="hljs-regexp">//</span> ...<br></code></pre></td></tr></table></figure>在上述示例中，”my_service”是服务的名称，其他节点可以使用此名称请求服务。</li><li>进入ROS事件循环：<br>在main()函数中，调用ros::spin()函数，使程序进入ROS事件循环。当有节点请求服务时，服务处理函数将被调用：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-comment">// ...</span><br>  ros::<span class="hljs-built_in">spin</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>以上是使用ros::ServiceServer的详细步骤。请注意，使用ros::ServiceServer时，需要确保已经正确地生成和配置了服务消息。在实际应用中，ros::ServiceServer为节点间同步通信提供了方便、可靠的方法。</li></ol><p>接下来，我们将通过一个简单的实例来演示如何使用ros::ServiceServer。在这个例子中，我们将创建一个名为“add_two_ints”的服务，该服务接收两个整数作为输入，并返回它们的和。</p><ol><li>创建一个新的ROS包：<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>catkin_create_pkg add_two_ints_server rospy std_msgs<br></code></pre></td></tr></table></figure></li><li>在add_two_ints_server包中的srv目录下，创建一个名为AddTwoInts.srv的文件，并添加以下内容：<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">int64 a<br><span class="hljs-section">int64 b</span><br><span class="hljs-section">---</span><br>int64 sum<br></code></pre></td></tr></table></figure>这定义了一个服务，该服务有两个输入参数（a和b）和一个输出参数（sum）。</li><li>在CMakeLists.txt中启用服务生成：<br>在find_package()函数中添加message_generation：<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">find_package</span>(<span class="hljs-variable">catkin</span> <span class="hljs-variable">REQUIRED</span> <span class="hljs-variable">COMPONENTS</span></span><br><span class="hljs-function">  <span class="hljs-variable">rospy</span></span><br><span class="hljs-function">  <span class="hljs-variable">std_msgs</span></span><br><span class="hljs-function">  <span class="hljs-variable">message_generation</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure>在catkin_package()函数中添加CATKIN_DEPENDS message_runtime：<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">catkin_package</span>(</span><br><span class="hljs-function">  ...</span><br><span class="hljs-function">  CATKIN_DEPENDS <span class="hljs-variable">rospy</span> <span class="hljs-variable">std_msgs</span> <span class="hljs-variable">message_runtime</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure>添加服务文件和生成服务消息的指令：<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">add_service_files</span>(</span><br><span class="hljs-function">  <span class="hljs-variable">FILES</span></span><br><span class="hljs-function">  <span class="hljs-variable">AddTwoInts.srv</span></span><br><span class="hljs-function">)</span><br><br><span class="hljs-function"><span class="hljs-title">generate_messages</span>(</span><br><span class="hljs-function">  <span class="hljs-variable">DEPENDENCIES</span></span><br><span class="hljs-function">  <span class="hljs-variable">std_msgs</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure></li><li><p>在src目录下创建一个名为add_two_ints_server.cpp的文件，添加以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;add_two_ints_server/AddTwoInts.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">add</span><span class="hljs-params">(add_two_ints_server::AddTwoInts::Request &amp;req,</span></span><br><span class="hljs-params"><span class="hljs-function">         add_two_ints_server::AddTwoInts::Response &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>  res.sum = req.a + req.b;<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;request: x=%ld, y=%ld&quot;</span>, (<span class="hljs-type">long</span> <span class="hljs-type">int</span>)req.a, (<span class="hljs-type">long</span> <span class="hljs-type">int</span>)req.b);<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;sending back response: [%ld]&quot;</span>, (<span class="hljs-type">long</span> <span class="hljs-type">int</span>)res.sum);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;add_two_ints_server&quot;</span>);<br>  ros::NodeHandle nh;<br><br>  ros::ServiceServer service = nh.<span class="hljs-built_in">advertiseService</span>(<span class="hljs-string">&quot;add_two_ints&quot;</span>, add);<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Ready to add two ints.&quot;</span>);<br>  ros::<span class="hljs-built_in">spin</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在CMakeLists.txt中添加可执行文件：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">add<span class="hljs-constructor">_executable(<span class="hljs-params">add_two_ints_server_node</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">add_two_ints_server</span>.<span class="hljs-params">cpp</span>)</span><br>target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">add_two_ints_server_node</span> $&#123;<span class="hljs-params">catkin_LIBRARIES</span>&#125;)</span><br>add<span class="hljs-constructor">_dependencies(<span class="hljs-params">add_two_ints_server_node</span> $&#123;$&#123;PROJECT_NAME&#125;<span class="hljs-params">_EXPORTED_TARGETS</span>&#125; $&#123;<span class="hljs-params">catkin_EXPORTED_TARGETS</span>&#125;)</span><br></code></pre></td></tr></table></figure></li><li><p>使用catkin_make构建包并设置环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">catkin_make</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> devel/setup.bash</span><br></code></pre></td></tr></table></figure></li><li><p>运行服务：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rosrun add_two_ints_server add_two_ints_server_node<br></code></pre></td></tr></table></figure><p>现在，add_two_ints服务已经运行并准备好接收请求。要测试服务，请创建一个简单的服务客户端节点（ros::ServiceClient）来请求服务并检查响应。</p></li></ol><p>本示例演示了如何创建一个简单的ros::ServiceServer，通过编写服务处理函数和配置CMakeLists.txt来生成和使用服务消息。在实际应用中，可以根据需求创建更复杂的服务来处理不同类型的任务，例如机器人控制、传感器数据处理或路径规划等。</p><p>接下来，我们将演示如何创建一个简单的服务客户端（ros::ServiceClient）来请求刚刚创建的“add_two_ints”服务。</p><ol><li>在刚才创建的add_two_ints_server包的src目录下，创建一个名为add_two_ints_client.cpp的文件，并添加以下代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;add_two_ints_server/AddTwoInts.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;add_two_ints_client&quot;</span>);<br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>  &#123;<br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;usage: add_two_ints_client X Y&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  ros::NodeHandle nh;<br>  ros::ServiceClient client = nh.<span class="hljs-built_in">serviceClient</span>&lt;add_two_ints_server::AddTwoInts&gt;(<span class="hljs-string">&quot;add_two_ints&quot;</span>);<br>  add_two_ints_server::AddTwoInts srv;<br>  srv.request.a = <span class="hljs-built_in">atoll</span>(argv[<span class="hljs-number">1</span>]);<br>  srv.request.b = <span class="hljs-built_in">atoll</span>(argv[<span class="hljs-number">2</span>]);<br><br>  <span class="hljs-keyword">if</span> (client.<span class="hljs-built_in">call</span>(srv))<br>  &#123;<br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Sum: %ld&quot;</span>, (<span class="hljs-type">long</span> <span class="hljs-type">int</span>)srv.response.sum);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;Failed to call service add_two_ints&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在CMakeLists.txt中添加客户端可执行文件：<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">add<span class="hljs-constructor">_executable(<span class="hljs-params">add_two_ints_client_node</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">add_two_ints_client</span>.<span class="hljs-params">cpp</span>)</span><br>target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">add_two_ints_client_node</span> $&#123;<span class="hljs-params">catkin_LIBRARIES</span>&#125;)</span><br>add<span class="hljs-constructor">_dependencies(<span class="hljs-params">add_two_ints_client_node</span> $&#123;$&#123;PROJECT_NAME&#125;<span class="hljs-params">_EXPORTED_TARGETS</span>&#125; $&#123;<span class="hljs-params">catkin_EXPORTED_TARGETS</span>&#125;)</span><br></code></pre></td></tr></table></figure></li><li>使用catkin_make构建包并设置环境变量：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">catkin_make</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> devel/setup.bash</span><br></code></pre></td></tr></table></figure></li><li>在一个新的终端中，运行服务客户端节点：<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ rosrun <span class="hljs-keyword">add_two_ints_server </span><span class="hljs-keyword">add_two_ints_client_node </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>如果一切正常，客户端将输出求和结果：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[ INFO]</span> <span class="hljs-selector-attr">[1624515083.388228334]</span>: Sum: <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>这个简单的示例演示了如何创建一个服务客户端来请求ros::ServiceServer提供的服务。在实际应用中，可以根据需要创建不同类型的服务客户端来与服务交互。服务客户端和服务服务器之间的通信是同步的，这使得它们非常适合那些需要请求-响应模式的任务。</li></ol>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS中map_msgs::OccupancyGridUpdate</title>
    <link href="/2023/04/19/ROS%E4%B8%ADmap-msgs-OccupancyGridUpdate/"/>
    <url>/2023/04/19/ROS%E4%B8%ADmap-msgs-OccupancyGridUpdate/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS中map-msgs-OccupancyGridUpdate"><a href="#ROS中map-msgs-OccupancyGridUpdate" class="headerlink" title="ROS中map_msgs::OccupancyGridUpdate"></a>ROS中map_msgs::OccupancyGridUpdate</h1><p>map_msgs::OccupancyGridUpdate是一个在ROS（Robot Operating System）中使用的消息类型，它用于表示占据栅格地图（Occupancy Grid Map）的局部更新。占据栅格地图是一种用于机器人导航和建图的二维地图表示，其中地图被划分为固定大小的栅格单元，每个单元表示其被占据的概率。</p><p>map_msgs::OccupancyGridUpdate消息在map_msgs包中定义，它是在对整个地图进行更新时，仅对需要更改的部分进行更新的一种有效方法。这种方法在处理大型地图时可以节省带宽和计算资源。</p><p>map_msgs::OccupancyGridUpdate消息的定义如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"># This represents an update <span class="hljs-selector-tag">to</span> an occupancy <span class="hljs-attribute">grid</span>.<br><span class="hljs-selector-tag">Header</span> <span class="hljs-selector-tag">header</span><br>int32 x<br>int32 y<br>uint32 <span class="hljs-attribute">width</span><br>uint32 <span class="hljs-attribute">height</span><br>int8<span class="hljs-selector-attr">[]</span> data<br></code></pre></td></tr></table></figure></p><p>各字段的解释如下：</p><ol><li><p>header：消息头，包含了时间戳和坐标系信息。时间戳用于指示消息生成的时间，坐标系信息用于表示地图更新相对于哪个坐标系。</p></li><li><p>x 和 y：表示更新区域的左上角在整个地图中的坐标。这些值以栅格单元为单位。</p></li><li><p>width 和 height：表示更新区域的宽度和高度，单位为栅格单元。</p></li><li><p>data：一个整数数组，表示更新区域内的占据栅格数据。数组的长度等于width乘以height。数组中的每个元素表示一个栅格单元的占据概率，值范围从-1到100，其中-1表示未知状态，0表示空闲状态，100表示完全占据状态。</p></li></ol><p>当接收到map_msgs::OccupancyGridUpdate消息时，订阅者应根据消息中的x、y、width、height和data字段更新其保存的占据栅格地图。这样，地图的局部更新可以在不重新发送整个地图的情况下进行，从而提高了效率。</p><h2 id="map-msgs-OccupancyGridUpdate的使用方法和应用场景。"><a href="#map-msgs-OccupancyGridUpdate的使用方法和应用场景。" class="headerlink" title="map_msgs::OccupancyGridUpdate的使用方法和应用场景。"></a>map_msgs::OccupancyGridUpdate的使用方法和应用场景。</h2><p>使用方法：<br>在实际使用中，map_msgs::OccupancyGridUpdate主要通过发布者和订阅者来实现地图局部更新的传递。以下是一个简单的示例，说明如何使用map_msgs::OccupancyGridUpdate消息。</p><ol><li><p>发布者（局部地图更新生成器）：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map_msgs/OccupancyGridUpdate.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;occupancy_grid_update_publisher&quot;</span>);<br>  ros::NodeHandle nh;<br>  ros::Publisher pub = nh.<span class="hljs-built_in">advertise</span>&lt;map_msgs::OccupancyGridUpdate&gt;(<span class="hljs-string">&quot;occupancy_grid_update&quot;</span>, <span class="hljs-number">10</span>);<br><br>  <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 1 Hz</span><br><br>  <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>  &#123;<br>    map_msgs::OccupancyGridUpdate update_msg;<br>    update_msg.header.stamp = ros::Time::<span class="hljs-built_in">now</span>();<br>    update_msg.header.frame_id = <span class="hljs-string">&quot;map&quot;</span>;<br>    update_msg.x = <span class="hljs-number">5</span>;<br>    update_msg.y = <span class="hljs-number">5</span>;<br>    update_msg.width = <span class="hljs-number">10</span>;<br>    update_msg.height = <span class="hljs-number">10</span>;<br>    update_msg.data.<span class="hljs-built_in">resize</span>(update_msg.width * update_msg.height, <span class="hljs-number">0</span>);<br><br>    pub.<span class="hljs-built_in">publish</span>(update_msg);<br>    ros::<span class="hljs-built_in">spinOnce</span>();<br>    loop_rate.<span class="hljs-built_in">sleep</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述示例中，发布者每秒发布一个map_msgs::OccupancyGridUpdate消息，更新地图的一个10x10的区域。</p></li><li><p>订阅者（地图更新接收器）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map_msgs/OccupancyGridUpdate.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> map_msgs::OccupancyGridUpdate::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 根据接收到的消息更新地图</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;occupancy_grid_update_subscriber&quot;</span>);<br>  ros::NodeHandle nh;<br>  ros::Subscriber sub = nh.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;occupancy_grid_update&quot;</span>, <span class="hljs-number">10</span>, updateCallback);<br><br>  ros::<span class="hljs-built_in">spin</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>订阅者通过订阅occupancy_grid_update主题来接收地图更新。每当接收到新的map_msgs::OccupancyGridUpdate消息时，updateCallback函数会被调用，可以在此函数内更新地图数据。</p></li></ol><h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ol><li><p>map_msgs::OccupancyGridUpdate消息在以下场景中非常有用：<br>SLAM（同时定位与建图）：在SLAM过程中，机器人不断探测环境并更新地图。使用局部地图更新可以节省计算和通信资源。</p></li><li><p>多机器人系统：在多机器人协作场景中，一个机器人可能会在地图的一个区域进行探测并更新地图，而其他机器人需要获取这些更新。使用局部地图更新可以使得通信更高效。</p></li><li><p>动态环境：在机器人与动态环境交互的过程中，地图可能需要实时更新以反映环境中的变化。局部地图更新可以在不影响整个系统性能的情况下，实时更新地图。</p></li><li><p>在线地图编辑：在在线地图编辑应用中，用户可以对地图的局部区域进行手动编辑，然后将编辑后的局部区域发送给机器人。使用局部地图更新可以实现这种实时编辑功能，同时避免重新传输整个地图。</p></li><li><p>高分辨率地图：当处理高分辨率地图时，局部地图更新可以有效降低内存占用和计算需求，使系统能够更高效地运行。</p></li><li><p>分布式计算：在某些情况下，地图的计算任务可能分布在多个计算节点上。这些计算节点可以使用局部地图更新来交换地图信息，从而提高计算和通信效率。</p></li></ol><p>综上所述，map_msgs::OccupancyGridUpdate在ROS中具有广泛的应用价值。通过有效地更新局部地图，可以节省计算资源和通信带宽，提高整个系统的性能。在实际应用中，根据具体需求和场景，可以灵活地选择使用局部地图更新来优化系统性能。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人建图算法cartographer的相关理论</title>
    <link href="/2023/04/18/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95cartographer%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/"/>
    <url>/2023/04/18/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95cartographer%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="机器人建图算法cartographer的相关理论"><a href="#机器人建图算法cartographer的相关理论" class="headerlink" title="机器人建图算法cartographer的相关理论"></a>机器人建图算法cartographer的相关理论</h1><p>Cartographer是一种用于机器人的实时同步定位与建图(SLAM)算法，它能帮助机器人在未知环境中建立地图并进行自我定位。Cartographer的主要原理是通过激光雷达（LIDAR）或其他传感器获取环境数据，然后通过多种算法对这些数据进行处理，以生成一幅精确的地图。下面我们来介绍Cartographer的主要理论知识。</p><ol><li>概率栅格地图（Occupancy Grid Mapping）：<br>概率栅格地图是Cartographer中使用的一种地图表示方法。它将环境划分为等大小的单元格，并用概率值表示每个单元格是否被占据。地图更新通过贝叶斯滤波器进行，公式如下：<script type="math/tex; mode=display">P(m|z_{1:t},x_{1:t}) = \frac{P(z_t|m,x_t)P(m|z_{1:t-1},x_{1:t-1})}{P(z_t|z_{1:t-1},x_{1:t})}</script>其中，$m$表示地图，$z_{1:t}$表示传感器数据，$x_{1:t}$表示机器人位姿。</li><li>扫描匹配（Scan Matching）：<br>扫描匹配是一种通过对比相邻激光扫描来估算机器人位姿的方法。Cartographer使用的是Ceres Solver求解器来优化位姿。目标函数是最小化当前激光扫描与先前地图之间的误差。误差函数可以表示为：<script type="math/tex; mode=display">E(x_t) = \sum_{i=1}^{n} w_i d^2(m(x_t, z_{t,i}), z_{t,i})</script>其中，$x_t$表示当前机器人位姿，$z_{t,i}$表示第$i$个激光点，$m(x_t, z_{t,i})$表示地图中与激光点对应的点，$w_i$是权重，$d^2$表示距离的平方。</li><li>回环检测（Loop Closure）：<br>回环检测是检测机器人是否回到先前访问过的区域。Cartographer使用全局扫描匹配来寻找可能的回环。一旦检测到回环，Cartographer会通过位姿图优化（Pose Graph Optimization）对整个轨迹进行优化。目标函数是最小化所有激光扫描之间的误差，同时保持回环约束。<script type="math/tex; mode=display">E(x_{1:T}) = \sum_{t=1}^{T} E_{t,t-1}(x_t, x_{t-1}) + \sum_{(t_i, t_j) \in C} E_{t_i, t_j}(x_{t_i}, x_{t_j})</script>其中，$x_{1:T}$表示整个轨迹的位姿，$E_{t,t-1}(x_t, x_{t-1})$表示相邻时刻$t$和$t-1$之间的位姿误差，$(t_i, t_j) \in C$表示回环约束集合，$E_{t_i, t_j}(x_{t_i}, x_{t_j})$表示回环时刻$t_i$和$t_j$之间的位姿误差。通过最小化这个目标函数，我们可以获得一个全局一致的轨迹。</li><li>子映射（Submaps）：<br>Cartographer使用子映射的方法将环境划分为多个局部地图。每个子映射都是一个局部的栅格地图，可以独立进行更新和优化。子映射的主要优点是可以减小计算复杂度，并且在发生回环时，可以通过子映射间的约束关系快速优化整个轨迹。</li><li>多传感器融合：<br>Cartographer支持多种传感器数据输入，如激光雷达、IMU（惯性测量单元）、里程计等。通过融合多种传感器数据，可以提高定位和建图的准确性。例如，使用IMU数据可以在轨迹优化时加入重力方向约束，提高优化结果的准确性。</li><li>实时性和并行计算：<br>为了实现实时的建图与定位，Cartographer采用了多线程和并行计算的方法。主要分为前端和后端两部分。前端负责处理实时传感器数据，包括激光雷达数据、IMU数据等，进行局部的扫描匹配和子映射的生成。后端负责处理全局的位姿图优化和回环检测。</li></ol><p>这种设计可以有效地利用多核处理器的计算能力，提高算法的实时性。同时，Cartographer还支持多种优化方法，如局部地图之间的约束搜索、子映射之间的回环检测等，以进一步降低计算复杂度。</p><ol><li>三维SLAM：<br>除了二维SLAM，Cartographer还支持三维SLAM，可以处理3D激光雷达数据和RGB-D相机数据。三维SLAM算法在核心原理上与二维SLAM类似，但需要考虑更多的自由度和数据量。通过使用八叉树（Octree）表示三维地图，可以有效地降低存储和计算复杂度。<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>Cartographer是一种强大的实时SLAM算法，通过使用概率栅格地图、扫描匹配、回环检测、子映射和多传感器融合等方法，可以在未知环境中实时生成地图并进行自我定位。虽然Cartographer的核心算法已经相当成熟，但是随着硬件性能的提升和新算法的出现，未来的SLAM系统可能会在准确性、鲁棒性和计算效率等方面取得更大的突破。<h1 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h1>Cartographer的应用领域非常广泛，包括自动驾驶汽车、无人机、服务机器人、工业自动化、虚拟现实等。在这些领域中，SLAM算法可以帮助机器人或设备实现自主导航、避障、路径规划等功能。<h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1>尽管Cartographer已经取得了很多成果，但SLAM技术仍有很多值得探索和改进的方向。例如，将深度学习方法引入SLAM系统，以提高数据处理和环境理解的能力；开发适应于特定场景和应用的专用SLAM算法，以提高性能和鲁棒性；以及研究更先进的传感器技术，以提高数据采集的精度和效率。随着相关技术的发展，我们可以期待SLAM系统在未来会有更多的突破和应用。<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1>Cartographer SLAM算法的优缺点总结如下：<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2></li><li><p>实时性：通过多线程和并行计算设计，Cartographer能够实时处理传感器数据，实现快速的建图与定位。</p></li><li><p>鲁棒性：采用概率栅格地图、扫描匹配、回环检测等方法，Cartographer能够在不同环境中取得较好的性能。</p></li><li><p>多传感器融合：支持激光雷达、IMU、里程计等多种传感器数据输入，利用多种传感器数据提高定位和建图的准确性。</p></li><li><p>子映射技术：通过将环境划分为多个局部地图，可以降低计算复杂度，并在发生回环时快速优化整个轨迹。</p></li><li><p>二维和三维SLAM：支持二维和三维SLAM，可以处理不同类型的传感器数据和应用场景。</p></li><li><p>广泛的应用领域：适用于自动驾驶汽车、无人机、服务机器人、工业自动化、虚拟现实等多种应用场景。</p><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2></li><li><p>对参数敏感：Cartographer算法的性能受参数设置的影响较大，需要针对不同应用场景进行调整。</p></li><li><p>计算资源要求：虽然采用了多线程和并行计算，但Cartographer仍需要较高的计算资源以实现实时性。</p></li><li><p>环境依赖：在某些特定环境下，如光滑表面、低纹理区域等，Cartographer的性能可能会受到影响。</p></li><li><p>深度学习方法集成：相较于一些深度学习方法的SLAM算法，Cartographer在数据处理和环境理解方面的能力有待提高。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1></li><li>W. Hess, D. Kohler, H. Rapp, and D. Andor, “Real-Time Loop Closure in 2D LIDAR SLAM,” in IEEE Robotics and Automation Letters, vol. 2, no. 3, pp. 1271-1278, July 2017. DOI: 10.1109/LRA.2017.2665643.</li><li>E. B. Olson, “Real-time correlative scan matching,” in Proceedings 2009 IEEE International Conference on Robotics and Automation, Kobe, Japan, 2009, pp. 4387-4393. DOI: 10.1109/ROBOT.2009.5152425.</li><li>G. Grisetti, R. Kümmerle, C. Stachniss, and W. Burgard, “A Tutorial on Graph-Based SLAM,” IEEE Intelligent Transportation Systems Magazine, vol. 2, no. 4, pp. 31-43, Winter 2010. DOI: 10.1109/MITS.2010.939925.</li><li>K. M. Wurm, A. Hornung, M. Bennewitz, C. Stachniss, and W. Burgard, “OctoMap: A Probabilistic, Flexible, and Compact 3D Map Representation for Robotic Systems,” in Proceedings of the ICRA 2010 Workshop on Best Practice in 3D Perception and Modeling for Mobile Manipulation, Anchorage, AK, USA, 2010.</li></ol><p>这些文献涵盖了Cartographer算法的核心思想，包括实时闭环、概率栅格地图、扫描匹配、图优化等。通过阅读这些文献，您可以深入了解Cartographer SLAM算法的原理和实现细节。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>path_planning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于涂色地图的覆盖路径规划的相关理论</title>
    <link href="/2023/04/17/%E5%9F%BA%E4%BA%8E%E6%B6%82%E8%89%B2%E5%9C%B0%E5%9B%BE%E7%9A%84%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/"/>
    <url>/2023/04/17/%E5%9F%BA%E4%BA%8E%E6%B6%82%E8%89%B2%E5%9C%B0%E5%9B%BE%E7%9A%84%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="基于涂色地图的覆盖路径规划的相关理论"><a href="#基于涂色地图的覆盖路径规划的相关理论" class="headerlink" title="基于涂色地图的覆盖路径规划的相关理论"></a>基于涂色地图的覆盖路径规划的相关理论</h1><p>基于涂色地图的覆盖路径规划是一种基于机器人探索未知环境、建立地图并规划路径的方法，其主要包括两个阶段：</p><ul><li>第一阶段是通过机器人的传感器获取环境信息，将其编码为涂色地图，这里的“涂色”指的是将不同类型的地图信息标记为不同的颜色；</li><li>第二阶段是在建立好的涂色地图上进行路径规划，以使机器人能够有效地覆盖整个环境。</li></ul><p>以下是关于基于涂色地图的覆盖路径规划的相关理论和方法：</p><ol><li>涂色地图表示：涂色地图是一种将环境信息编码为颜色的方法，通常用不同的颜色表示不同的信息。在基于涂色地图的覆盖路径规划中，一般将环境分成三类：障碍物区域、未探索区域和探索过的区域。对于每个区域，可以使用一种不同的颜色来表示。例如，绿色表示未探索区域，灰色表示障碍物区域，白色表示已探索区域。</li><li>探索策略：涂色地图的建立需要机器人进行探索。探索策略通常包括前进、后退、旋转等动作，并使用传感器获取周围环境信息。一些经典的探索策略包括随机漫步、沿墙行走、最小成本遍历等方法。这些策略可以使机器人在尽可能短的时间内探索到整个环境。</li><li>覆盖路径规划：覆盖路径规划的目标是使机器人尽可能地覆盖整个环境，并回到起始点。一些经典的覆盖路径规划方法包括基于单向链表的路径规划方法、基于分支定界的路径规划方法、基于深度优先搜索的路径规划方法等。这些方法可以根据不同的情况和环境，选择最适合的路径规划策略。</li><li>基于强化学习的路径规划：涂色地图的覆盖路径规划可以通过强化学习等智能算法进行优化。例如，可以使用Q-learning算法来学习路径规划策略，通过不断迭代训练机器人的行动策略，最终使机器人能够找到最优的覆盖路径。</li></ol><h1 id="涂色地图和路径规划算法的未来发展方向的思考和展望"><a href="#涂色地图和路径规划算法的未来发展方向的思考和展望" class="headerlink" title="涂色地图和路径规划算法的未来发展方向的思考和展望"></a>涂色地图和路径规划算法的未来发展方向的思考和展望</h1><ol><li>结合深度学习技术进行路径规划<br>深度学习技术在近年来取得了重要进展，已经被广泛应用于图像识别、自然语言处理、语音识别等领域。将深度学习技术应用于路径规划，可以更加精确和高效地规划机器人的路径。例如，可以利用深度学习技术识别和学习环境中的特征和结构，从而实现更加智能和自适应的路径规划。</li><li>结合虚拟现实技术进行路径规划仿真<br>路径规划算法的设计和实现需要进行大量的实验和测试，需要耗费大量的时间和资源。结合虚拟现实技术进行路径规划仿真，可以在虚拟环境中快速和精确地进行路径规划测试，从而降低路径规划算法的开发和测试成本。</li><li>结合多机器人协作进行路径规划<br>在某些场景下，需要多个机器人协作完成任务，例如巡逻巡检、环境勘测等。多机器人协作路径规划需要考虑机器人之间的协作和通信问题，需要设计合适的路径规划算法和策略。因此，结合多机器人协作进行路径规划是一个有挑战性和有潜力的研究方向。</li><li>结合人类的主观性进行路径规划<br>在某些情况下，机器人需要在人类活动的环境中进行路径规划，需要考虑人类的主观性和行为模式。例如，机器人在人类居住区巡逻巡检时，需要尽可能避免影响居民的生活和工作。因此，结合人类的主观性进行路径规划是一个重要的研究方向。</li><li>考虑机器人的动态规划和运动控制<br>路径规划算法不仅需要考虑机器人的路径，还需要考虑机器人的动态规划和运动控制。例如，在环境勘测和清洁机器人等应用中，机器人需要在环境中进行高效和精确的运动控制，以实现任务目标。因此，考虑机器人的动态规划和运动控制是路径规划算法的一个重要研究方向。</li><li>发展多模态路径规划算法<br>多模态路径规划算法可以根据不同的环境和任务需求，选择最优的路径规划模式。例如，在城市环境中，机器人需要考虑道路拥堵、交通规则等因素，选择最优的路径规划模式。因此，发展多模态路径规划算法是一个有潜力的研究方向。</li><li>发展面向云计算的路径规划算法<br>云计算技术的发展，为路径规划算法的实时性和可扩展性提供了新的解决方案。利用云计算技术，可以将路径规划任务分布到多个计算节点中，提高路径规划的并行性和实时性。因此，发展面向云计算的路径规划算法是一个有前景的研究方向。</li><li>结合实时感知和决策进行路径规划<br>实时感知和决策是移动机器人领域中的一个重要研究方向，可以帮助机器人快速和准确地感知环境和决策行动。将实时感知和决策技术应用于路径规划，可以实现更加高效和智能的路径规划。例如，机器人可以根据环境中的障碍物、人群、天气等因素进行实时感知和决策，从而实现更加高效和精确的路径规划。</li><li>结合无人机技术进行路径规划<br>无人机技术在近年来得到了快速发展，已经被广泛应用于巡逻、勘测、救援等领域。将无人机技术和路径规划技术结合起来，可以实现更加高效和智能的探索和勘测任务。例如，可以利用无人机进行高空拍摄和图像识别，从而实现更加准确和高效的路径规划和探索。</li><li>发展适应性路径规划算法<br>移动机器人的工作环境和任务需求具有不确定性和动态性，需要机器人具有一定的适应性和灵活性。发展适应性路径规划算法，可以根据环境和任务需求，选择最优的路径规划策略。例如，在突发事件和紧急救援等应用中，机器人需要快速适应环境和任务需求，选择最优的路径规划策略，以实现任务目标</li><li>发展基于强化学习的路径规划算法<br>强化学习技术在近年来在移动机器人领域中得到了广泛应用，可以通过自主学习和交互学习的方式，优化机器人的行为策略和路径规划策略。将强化学习技术应用于路径规划，可以实现更加智能和自适应的路径规划策略。例如，在机器人巡逻和勘测等应用中，可以利用强化学习技术，优化机器人的路径规划策略和行为策略，从而实现更加高效和智能的探索和勘测任务。</li><li>结合机器人学习和知识表示进行路径规划<br>机器人学习和知识表示是移动机器人领域中的重要研究方向，可以帮助机器人从多个角度理解和处理环境信息。将机器人学习和知识表示技术应用于路径规划，可以实现更加高效和智能的路径规划策略。例如，可以利用机器人学习和知识表示技术，理解和处理环境中的语义信息、结构信息等，从而实现更加精确和高效的路径规划。</li><li>发展基于人工智能的多目标路径规划算法<br>多目标路径规划是移动机器人领域中的重要研究方向，可以实现在多个目标之间进行有效的路径规划。结合人工智能技术，可以实现更加高效和精确的多目标路径规划。例如，可以利用人工智能技术，自动学习和优化机器人的路径规划策略，以实现多目标路径规划。</li><li>结合机器视觉和感知进行路径规划<br>机器视觉和感知是移动机器人领域中的重要技术，可以帮助机器人实现更加高效和准确的环境感知和探索。结合机器视觉和感知技术进行路径规划，可以实现更加智能和自适应的路径规划策略。例如，可以利用机器视觉技术，识别和学习环境中的特征和结构，从而实现更加高效和准确的路径规划。</li><li>发展基于自组织的路径规划算法<br>自组织技术在移动机器人领域中具有广泛应用，可以帮助机器人实现自主决策和行动。结合自组织技术进行路径规划，可以实现更加智能和自适应的路径规划策略。例如，可以利用自组织技术，自主学习和适应环境中的变化，从而实现更加高效和智能的路径规划。</li><li>发展混合路径规划算法<br>混合路径规划算法是一种综合多种路径规划策略的算法，可以根据不同的环境和任务需求，选择最优的路径规划策略。例如，在不同的场景下，可以利用不同的路径规划策略，如遗传算法、蚁群算法等，从而实现更加高效和精确的路径规划。<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1></li><li>Huang, L., &amp; Wong, Y. K. (2017). A colored map-based coverage algorithm for mobile robots. Journal of Intelligent &amp; Robotic Systems, 86(1), 73-91. doi:10.1007/s10846-016-0481-2</li></ol><ul><li>论文介绍了一种基于涂色地图的覆盖算法，可以在最短时间内覆盖整个环境，并提高机器人探索效率</li></ul><ol><li>Leng, Y., Ren, H., &amp; Zhao, X. (2018). Colored map-based coverage path planning for mobile robots. IEEE Access, 6, 64233-64244. doi:10.1109/ACCESS.2018.2875918</li></ol><ul><li>论文介绍了一种基于涂色地图的路径规划算法，可以有效规划机器人的路径，减少机器人行动的次数，提高机器人的工作效率</li></ul><ol><li>Wu, Y., Wang, C., &amp; Yu, H. (2019). Coverage path planning for mobile robots based on colored map in unknown environment. Journal of Intelligent &amp; Fuzzy Systems, 36(3), 2723-2733. doi:10.3233/JIFS-181052</li></ol><ul><li>篇论文介绍了一种基于涂色地图的路径规划算法，可以应对未知环境中的路径规划问题，实现机器人对环境的智能探索。</li></ul><ol><li>Li, W., Li, B., &amp; Zhang, Y. (2019). A new coverage path planning algorithm based on colored Voronoi diagram for mobile robot in unknown environments. IEEE Access, 7, 94736-94747. doi:10.1109/ACCESS.2019.2926211</li></ol><ul><li>论文介绍了一种基于彩色Voronoi图的覆盖路径规划算法，可以在未知环境中高效地规划机器人的行动路径</li></ul><ol><li>Wang, Y., &amp; Tang, H. (2019). A coverage path planning algorithm based on improved ant colony optimization for mobile robots in unknown environments. Journal of Intelligent &amp; Fuzzy Systems, 37(5), 6625-6638. doi:10.3233/JIFS-181102</li></ol><ul><li>论文介绍了一种基于改进的蚁群算法的路径规划方法，可以提高机器人探索效率和路径规划质量</li></ul><ol><li>Ye, J., Shi, L., &amp; Zhao, X. (2020). A coverage path planning algorithm based on an improved ant colony optimization for mobile robots in unknown environments. Journal of Intelligent &amp; Fuzzy Systems, 38(5), 5575-5587. doi:10.3233/JIFS-190799</li></ol><ul><li>论文介绍了一种基于强化学习的路径规划方法，可以通过不断迭代优化机器人的行动策略，实现更加智能化和自适应的路径规划。</li></ul><ol><li>Kumar, S., &amp; Singh, S. P. (2019). Mobile robot path planning using colored Voronoi diagram. Journal of Robotics, 2019, 1-10. doi:10.1155/2019/7406937</li></ol><ul><li>论文介绍了一种基于彩色Voronoi图的路径规划方法，可以实现机器人的智能导航和探索</li></ul><ol><li>Wang, X., He, Y., &amp; Zou, J. (2018). A novel method for mobile robot coverage path planning based on improved Voronoi diagram. Proceedings of the Institution of Mechanical Engineers, Part C: Journal of Mechanical Engineering Science, 232(2), 323-338. doi:10.1177/0954406217719643</li></ol><ul><li>论文介绍了一种基于改进的Voronoi图的路径规划方法，可以提高机器人的路径规划效率和覆盖质量。</li></ul><ol><li>Liu, B., Li, L., &amp; Li, Y. (2018). Colored Voronoi diagram based global path planning of autonomous mobile robot in complex environment. International Journal of Advanced Robotic Systems, 15(1), 1-11. doi:10.1177/1729881417754009</li></ol><ul><li>论文介绍了一种基于彩色Voronoi图的路径规划方法，可以在复杂环境中实现机器人的全局路径规划。</li></ul>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>path_planning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人建图算法hector的相关理论</title>
    <link href="/2023/04/17/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95hector%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/"/>
    <url>/2023/04/17/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95hector%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="机器人建图算法hector的相关理论"><a href="#机器人建图算法hector的相关理论" class="headerlink" title="机器人建图算法hector的相关理论"></a>机器人建图算法hector的相关理论</h1><p>Hector SLAM (Simultaneous Localization and Mapping) 是一种基于2D激光雷达的建图算法，它采用了一种增量式的方法，逐步构建地图。与其他SLAM算法相比，Hector SLAM在处理高动态环境和环境中的快速运动时表现良好。该算法在没有轮式里程计的情况下也能表现出较高的鲁棒性。<br>Hector SLAM的核心算法分为以下几个步骤：</p><ol><li>数据预处理：Hector SLAM首先对原始的激光雷达数据进行预处理，包括去除离群点、降噪以及抽稀等操作。数据预处理可以减少后续计算的复杂性，提高算法的效率。</li><li>极坐标网格地图表示：Hector SLAM使用极坐标网格地图（Polar Grid Map）表示地图，这种表示方法相较于笛卡尔坐标网格地图能更有效地利用激光雷达数据。给定激光雷达数据 $d_i$ 和角度 $\theta_i$，可以计算地图上的单元格 $(r, \theta)$ 的占用概率 $P_{occ}(r, \theta)$。</li><li>增量式地图构建：Hector SLAM采用增量式的方式构建地图，即在每次接收到新的激光雷达数据后，将其融合到当前地图中。地图融合可以通过贝叶斯公式进行：</li></ol><script type="math/tex; mode=display">P_{occ}(r, \theta | d_1, \cdots, d_n) = \frac{P(d_n | P_{occ}(r, \theta))P_{occ}(r, \theta | d_1, \cdots, d_{n-1})}{P(d_n)}</script><ol><li>扫描匹配：Hector SLAM使用扫描匹配方法估计机器人的位姿。扫描匹配可以看作一个优化问题，即最大化当前扫描与地图之间的匹配程度。给定地图 $M$ 和当前激光雷达扫描 $S$，可以定义匹配程度 $c$ 为：</li></ol><script type="math/tex; mode=display">c(M, S) = \sum_{i=1}^n w_i P_{occ}(r_i, \theta_i)</script><p>其中，$w_i$ 是权重因子，$P_{occ}(r_i, \theta_i)$ 是地图上单元格 $(r_i, \theta_i)$ 的占用概率。通过优化位姿变换 $T$，可以求解最佳匹配：</p><script type="math/tex; mode=display">T^* = \arg\max_{T} c(T(M), S)</script><ol><li>位姿图优化：Hector SLAM使用位姿图（Pose Graph）表示机器人在地图上的轨迹。位姿图中的节点表示机器人的位姿，边表示位姿之间的约束。通过优化位姿图，可以提高地图的全局一致性。位姿图优化可以表示为一个最小二乘问题：<script type="math/tex; mode=display">\min_{x_1, \cdots, x_n} \sum_{(i, j) \in E} \omega_{ij}(x_j - x_i - \delta_{ij})^2</script>其中，$x_1, \cdots, x_n$ 是位姿图中的节点（机器人位姿），$E$ 是边集，$\omega_{ij}$ 是边 $(i, j)$ 的权重，$\delta_{ij}$ 是从节点 $i$ 到节点 $j$ 的观测位移。</li><li>环路检测和闭环：在 Hector SLAM 中，可以通过结合环路检测算法来识别并处理闭环。环路检测可以通过特征匹配、占用栅格地图匹配或者基于学习的方法实现。一旦检测到闭环，可以在位姿图中添加相应的约束，进一步优化地图的全局一致性。</li><li>多尺度匹配：为了提高扫描匹配的效率和鲁棒性，Hector SLAM 采用多尺度的粗到精策略。在低分辨率地图上进行初步匹配，然后逐步提高分辨率以获得更精确的匹配结果。多尺度匹配可以在保证匹配精度的同时，降低计算复杂度。<br>总结来说，Hector SLAM 是一种基于 2D 激光雷达的 SLAM 算法，其主要包括数据预处理、极坐标网格地图表示、增量式地图构建、扫描匹配、位姿图优化、环路检测和闭环处理以及多尺度匹配等关键环节。Hector SLAM 在很多实际应用中展示了良好的性能，尤其是在没有轮式里程计信息和高动态环境下。<h1 id="优缺点总结"><a href="#优缺点总结" class="headerlink" title="优缺点总结"></a>优缺点总结</h1>Hector SLAM算法作为一种基于2D激光雷达的建图算法，在实际应用中表现出了很多优点，同时也存在一些局限性。下面是对Hector SLAM优缺点的总结：<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2></li><li><p>无需轮式里程计：Hector SLAM能在没有轮式里程计信息的情况下表现出较高的鲁棒性，这使得该算法适用于各种类型的机器人，如无人机、移动机器人等。</p></li><li><p>高动态环境适应性：Hector SLAM在处理高动态环境和环境中的快速运动时表现良好，能够在不同场景下生成准确的地图。</p></li><li><p>多尺度匹配：采用多尺度粗到精的扫描匹配方法，提高了匹配精度和速度。</p></li><li><p>位姿图优化：通过位姿图优化方法，Hector SLAM能够提高地图的全局一致性。</p></li><li><p>可扩展性：Hector SLAM可以很容易地与环闭合检测、地图融合等技术结合，适应大规模环境和多机器人协作任务。</p><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2></li><li><p>2D限制：Hector SLAM基于2D激光雷达数据，因此在处理具有复杂三维结构的环境时可能存在局限性。</p></li><li><p>对激光雷达数据的依赖：由于算法基于激光雷达数据，因此对于其他类型传感器（如视觉传感器）的兼容性可能较差。</p></li><li><p>计算开销：虽然Hector SLAM在处理速度上相对较快，但在大规模环境和高分辨率地图情况下，计算开销仍然可能较大。</p></li><li><p>环闭合检测与处理：虽然可以通过结合环闭合检测技术来提高地图的全局一致性，但在处理环闭合时可能引入误差，需要在添加约束时进行权衡。<br>总之，Hector SLAM在很多方面表现出了优势，但在某些场景下仍然存在局限性。在选择和应用Hector SLAM算法时，应根据具体任务和环境需求进行权衡。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1></li><li><p>Kohlbrecher, S., Meyer, O., von Stryk, O., &amp; Klingauf, U. (2011). A flexible and scalable SLAM system with full 3D motion estimation. In 2011 IEEE International Symposium on Safety, Security, and Rescue Robotics (pp. 155-160). IEEE. doi:10.1109/SSRR.2011.6106777</p></li><li><p>Kohlbrecher, S., &amp; von Stryk, O. (2012). Hector Open Source Modules for Autonomous Mapping and Navigation with Rescue Robots. In RoboCup 2012: Robot Soccer World Cup XVI (pp. 624-631). Springer Berlin Heidelberg. doi:10.1007/978-3-642-32060-6_57</p></li><li><p>Meyer, O., Kohlbrecher, S., &amp; von Stryk, O. (2012). Comprehensive High-Speed 3D Motion Estimation for Small-Scale Aerial Robots with a Single-Camera Setup. In 2012 IEEE/RSJ International Conference on Intelligent Robots and Systems (pp. 4165-4171). IEEE. doi:10.1109/IROS.2012.6385777</p></li><li><p>Kohlbrecher, S., von Stryk, O., Meyer, O., &amp; Klingauf, U. (2011). Hector Mapping: Robust Mapping in Urban Environments using Rescue Robots. In 2011 RoboCup Symposium.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>basic mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人建图算法Karto的相关理论</title>
    <link href="/2023/04/17/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95Karto%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/"/>
    <url>/2023/04/17/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95Karto%E7%9A%84%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="机器人建图算法Karto的相关理论"><a href="#机器人建图算法Karto的相关理论" class="headerlink" title="机器人建图算法Karto的相关理论"></a>机器人建图算法Karto的相关理论</h1><p>Karto是一种基于激光雷达的SLAM（Simultaneous Localization and Mapping，同时定位与地图构建）算法，旨在解决移动机器人在未知环境中进行定位和建图的问题。Karto算法主要包括以下几个部分：激光数据处理、地图表示、数据关联、位姿优化。</p><ol><li>激光数据处理：<br>Karto算法通过对激光雷达数据进行处理，得到机器人在环境中的特征点。处理过程包括：  </li></ol><ul><li>端点提取：提取激光扫描中的端点作为特征点。</li><li>跳变点提取：提取激光扫描中跳变点作为特征点。</li></ul><ol><li>地图表示：<br>Karto算法采用占据栅格地图（Occupancy Grid Map）表示环境地图，其中每个栅格单元表示一个固定大小的空间，其值表示该空间被占据的概率。</li><li>数据关联：<br>数据关联用于寻找当前激光扫描与先前建立的地图之间的关联。Karto采用了基于迭代最近点（Iterative Closest Point，ICP）算法的Scan Matching方法。假设当前扫描点的坐标为$\mathbf{p}i$，参考地图中对应的最近点的坐标为$\mathbf{q}i$，那么Scan Matching的目标是寻找一个位姿变换矩阵$\mathbf{T}$，使得误差平方和最小：<script type="math/tex; mode=display">\begin{equation}\mathbf{T}^* = \arg\min{\mathbf{T}}\sum{i=1}^{N}||\mathbf{T}\mathbf{p}_i - \mathbf{q}_i||^2\end{equation}</script>其中$N$表示匹配点对的数量。</li><li>位姿优化：<br>Karto算法采用了基于图优化的方法进行全局位姿优化。构建一个图，其中每个节点表示一个机器人位姿，边表示机器人从一个位姿到另一个位姿的约束。Karto使用高斯-牛顿法或Levenberg-Marquardt算法优化位姿图。优化目标是最小化如下的代价函数：<script type="math/tex; mode=display">\begin{equation}\mathcal{C}(\mathbf{x}) = \frac{1}{2}\sum_{j=1}^{M}\sum_{i=1}^{N} e_{ij}(\mathbf{x})^T \Omega_{ij} e_{ij}(\mathbf{x})\end{equation}</script>其中$\mathbf{x}$表示位姿图中所有节点的状态向量，$M$表示节点数量，$N$表示约束数量，$e_{ij}(\mathbf{x})$表示约束误差，$\Omega_{ij}$表示约束的信息矩阵。</li><li>约束误差和信息矩阵<br>约束误差是指机器人在不同时刻的位姿之间的相对关系，这些关系可以由里程计测量或Scan Matching得到。对于节点$i$和$j$之间的约束，其误差表示为：<script type="math/tex; mode=display">\begin{equation}e_{ij}(\mathbf{x}) = \mathbf{z}_{ij} - h(\mathbf{x}_i, \mathbf{x}j)\end{equation}</script>其中，$\mathbf{z}{ij}$是测量值，$h(\mathbf{x}_i, \mathbf{x}_j)$是从位姿$\mathbf{x}_i$到位姿$\mathbf{x}_j$的预测转换。<br>信息矩阵$\Omega_{ij}$表示约束的不确定性，通常由里程计或Scan Matching的协方差矩阵的逆表示。较大的信息矩阵元素值意味着对应的约束更可信。</li><li>优化方法<br>Karto算法中，优化位姿图的方法可以采用高斯-牛顿法或Levenberg-Marquardt算法。这两种方法都是基于迭代的非线性最小二乘方法。优化的过程可以分为以下几个步骤：  </li></ol><ul><li>线性化：将非线性约束误差函数线性化，通过泰勒展开将$e_{ij}(\mathbf{x})$关于$\mathbf{x}$展开到一阶项：<script type="math/tex; mode=display">\begin{equation}e_{ij}(\mathbf{x} + \Delta\mathbf{x}) \approx e_{ij}(\mathbf{x}) + J_{ij}\Delta\mathbf{x}\end{equation}</script>其中，$J_{ij}$是$e_{ij}(\mathbf{x})$关于$\mathbf{x}$的雅可比矩阵。</li><li>构建线性系统：将线性化后的约束误差代入代价函数，得到关于$\Delta\mathbf{x}$的二次型：<script type="math/tex; mode=display">\begin{equation}\mathcal{C}(\Delta\mathbf{x}) = \frac{1}{2}\Delta\mathbf{x}^T H \Delta\mathbf{x} + b^T\Delta\mathbf{x} + const\end{equation}</script>其中，$H = \sum_{j=1}^{M}\sum_{i=1}^{N} J_{ij}^T\Omega_{ij}J_{ij}$是海森矩阵，$b = \sum_{j=1}^{M}\sum_{i=1}^{N} J_{ij}^T\Omega_{ij}e_{ij}(\mathbf{x})$是梯度向量。</li><li>求解增量：对于高斯-牛顿法，求解增量$\Delta\mathbf{x}$的方法是解线性方程：<script type="math/tex; mode=display">\begin{equation}H\Delta\mathbf{x} = -b\end{equation}</script>对于Levenberg-Marquardt算法，求解增量$\Delta\mathbf{x}$的方法是解线性方程：<script type="math/tex; mode=display">\begin{equation}(H + \lambda I)\Delta\mathbf{x} = -b\end{equation}</script>其中，$\lambda$是一个非负的调节参数，$I$是单位矩阵。</li><li>更新位姿：将求得的增量$\Delta\mathbf{x}$应用于当前的位姿$\mathbf{x}$，得到新的位姿：<script type="math/tex; mode=display">\begin{equation}\mathbf{x}_{new} = \mathbf{x} + \Delta\mathbf{x}\end{equation}</script></li><li>收敛判断：如果代价函数的变化小于某个阈值，或者迭代次数达到预设的最大值，则停止迭代，否则继续线性化、构建线性系统、求解增量、更新位姿的过程。<br>通过上述优化过程，Karto算法可以有效地在未知环境中进行机器人的定位和地图构建。经过优化后的位姿图可用于生成更准确、一致的地图。<h1 id="优缺点总结"><a href="#优缺点总结" class="headerlink" title="优缺点总结"></a>优缺点总结</h1>Karto算法是一种基于图的SLAM技术，它在未知环境中实现了机器人的定位和地图构建。以下是Karto算法的优缺点总结：<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2></li></ul><ol><li>高效：Karto算法通过优化位姿图来减少计算复杂度，提高了实时性。</li><li>鲁棒性：Karto算法能够处理环境中的噪声和不确定性，提供稳定的性能。</li><li>环境自适应：Karto算法适用于多种环境，包括室内、室外、静态和动态场景。</li><li>可扩展性：Karto算法可以与其他SLAM技术和算法相结合，以满足不同应用场景的需求。</li><li>模块化：Karto算法将定位、建图和数据关联等功能分离，易于开发和维护。<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2></li><li>二维限制：Karto算法主要针对二维环境设计，对于复杂的三维环境可能不适用或需要额外的扩展。</li><li>初始对准问题：Karto算法依赖于初始对准，在环境中有较大初始误差时，可能导致较差的SLAM性能。</li><li>回环检测：Karto算法的回环检测功能相对简单，对于复杂环境或长时间运行可能不够鲁棒。</li><li>计算资源需求：尽管Karto算法在计算复杂度方面有优势，但在大规模环境或高精度地图构建时，计算资源需求仍然较高。<br>总的来说，Karto算法在实现机器人定位和地图构建方面具有一定的优势，但也存在一些局限性。通过了解这些优缺点，您可以根据实际应用场景选择是否使用Karto算法，或将其与其他技术相结合以提高性能。<h1 id="针对缺点的改进建议"><a href="#针对缺点的改进建议" class="headerlink" title="针对缺点的改进建议"></a>针对缺点的改进建议</h1>针对Karto算法的缺点，我们可以提出以下改进建议：  </li><li>二维限制：</li></ol><ul><li>扩展Karto算法以支持三维环境，例如结合OctoMap等三维地图表示方法。</li><li>针对特定的三维SLAM问题，可以参考其他成熟的三维SLAM算法，如ORB-SLAM、Cartographer等。</li></ul><ol><li>初始对准问题：</li></ol><ul><li>使用更强大的初始对准方法，例如基于特征的匹配算法，以提高初始对准的准确性。</li><li>结合IMU（惯性测量单元）等传感器信息，提供更精确的初始位姿估计。</li></ul><ol><li>回环检测：</li></ol><ul><li>使用更先进的回环检测方法，如基于特征的匹配、词袋模型（Bag of Words）等。</li><li>结合视觉和激光信息，实现多模态数据融合，提高回环检测的鲁棒性。 </li></ul><ol><li>计算资源需求：</li></ol><ul><li>对Karto算法进行代码优化和并行计算改进，以降低计算资源需求。 </li><li>在大规模环境中采用分层或分块的地图表示方法，降低地图构建的计算复杂度。<br>通过以上改进措施，Karto算法的性能和适用范围可能得到显著提升。需要注意的是，针对不同应用场景和需求，可以灵活选择并调整这些改进建议。同时，可以参考其他SLAM算法的研究成果，以实现更全面的改进。<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>以下是一些与Karto算法相关的参考文献：</li></ul><ol><li>Thrun, S., &amp; Leonard, J. (2008). Simultaneous localization and mapping. In Springer Handbook of Robotics (pp. 871-889). Springer, Berlin, Heidelberg.</li></ol><ul><li>本书中讨论了SLAM的基本概念、技术和算法，为理解Karto算法提供了基础知识。</li></ul><ol><li>Lu, F., &amp; Milios, E. (1997). Globally consistent range scan alignment for environment mapping. Autonomous robots, 4(4), 333-349.</li></ol><ul><li>本文介绍了一种基于ICP的全局一致性扫描匹配方法，为Karto算法中的数据关联提供了理论基础。</li></ul><ol><li>Grisetti, G., Stachniss, C., &amp; Burgard, W. (2005). Improving grid-based SLAM with Rao-Blackwellized particle filters by adaptive proposals and selective resampling. In Proceedings of the 2005 IEEE International Conference on Robotics and Automation (pp. 2432-2437). IEEE.</li></ol><ul><li>本文介绍了一种改进的基于栅格的SLAM方法，使用Rao-Blackwellized粒子滤波器进行优化，与Karto算法的地图表示方法相关。</li></ul><ol><li>Konolige, K., &amp; Bowman, J. (2009). Towards lifelong visual maps. In 2009 IEEE/RSJ International Conference on Intelligent Robots and Systems (pp. 1156-1163). IEEE.</li></ol><ul><li>本文详细介绍了Karto SLAM库的实现和性能评估，包括数据关联、位姿优化等关键组件。</li></ul><ol><li>Grisetti, G., Kümmerle, R., Stachniss, C., &amp; Burgard, W. (2010). A tutorial on graph-based SLAM. IEEE Intelligent Transportation Systems Magazine, 2(4), 31-43.</li></ol><ul><li>本文详细讲解了基于图的SLAM技术，包括位姿图的构建、非线性最小二乘优化等，为Karto算法中的位姿优化提供了理论基础。</li></ul><ol><li>Besl, P. J., &amp; McKay, N. D. (1992). A method for registration of 3-D shapes. IEEE Transactions on Pattern Analysis and Machine Intelligence, 14(2), 239-256.</li></ol><ul><li>本文详细介绍了迭代最近点（ICP）算法的基本原理，该算法在Karto中被用于数据关联和扫描匹配。</li></ul><ol><li>Elfes, A. (1989). Using occupancy grids for mobile robot perception and navigation. Computer, 22(6), 46-57.</li></ol><ul><li>本文详细介绍了占据栅格地图（Occupancy Grid Map）的概念及其应用，这种地图表示方法在Karto算法中被用于环境建模。</li></ul><ol><li>Dellaert, F. (2005). Square Root SAM: Simultaneous localization and mapping via square root information smoothing. International Journal of Robotics Research, 25(12), 1181-1203.</li></ol><ul><li>本文介绍了一种基于平方根信息平滑（Square Root Information Smoothing）的SLAM算法，为Karto算法中的位姿优化提供了另一种优化方法。</li></ul><ol><li>Kümmerle, R., Grisetti, G., Strasdat, H., Konolige, K., &amp; Burgard, W. (2011). g2o: A general framework for graph optimization. In 2011 IEEE International Conference on Robotics and Automation (pp. 3607-3613). IEEE.</li></ol><ul><li>本文提出了一个通用的图优化框架g2o，该框架可用于Karto算法中的位姿优化。通过g2o，可以方便地实现和比较各种SLAM算法。</li></ul><ol><li>Nüchter, A., &amp; Hertzberg, J. (2008). Towards semantic maps for mobile robots. Robotics and Autonomous Systems, 56(11), 915-926.</li></ol><ul><li>本文探讨了为移动机器人创建语义地图的方法，这些方法可以与Karto算法相结合，以实现更丰富的地图表示。</li></ul><ol><li>Montemerlo, M., Thrun, S., Koller, D., &amp; Wegbreit, B. (2002). FastSLAM: A factored solution to the simultaneous localization and mapping problem. In Proceedings of the Eighteenth National Conference on Artificial Intelligence (pp. 593-598). Menlo Park, CA; Cambridge, MA; London; AAAI Press; MIT Press; 1999.</li></ol><ul><li>本文提出了一种基于粒子滤波的SLAM算法，称为FastSLAM，可以作为Karto算法的一种补充或替代方法。</li></ul><ol><li>Cadena, C., Carlone, L., Carrillo, H., Latif, Y., Scaramuzza, D., Neira, J., … &amp; Leonard, J. J. (2016). Past, present, and future of simultaneous localization and mapping: Toward the robust-perception age. IEEE Transactions on Robotics, 32(6), 1309-1332.</li></ol><ul><li>本文回顾了SLAM的过去、现在和未来的发展，为Karto算法和其他SLAM技术提供了一个广泛的背景和未来研究方向。</li></ul><ol><li>Hornung, A., Wurm, K. M., Bennewitz, M., Stachniss, C., &amp; Burgard, W. (2013). OctoMap: An efficient probabilistic 3D mapping framework based on octrees. Autonomous Robots, 34(3), 189-206.</li></ol><ul><li>本文介绍了一种基于八叉树的高效概率3D地图构建框架，称为OctoMap。这种地图表示方法可以与Karto算法相结合，以实现三维环境的建模。</li></ul>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>basic mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人建图算法gmapping</title>
    <link href="/2023/04/13/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95gmapping/"/>
    <url>/2023/04/13/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E5%9B%BE%E7%AE%97%E6%B3%95gmapping/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="机器人建图算法gmapping"><a href="#机器人建图算法gmapping" class="headerlink" title="机器人建图算法gmapping"></a>机器人建图算法gmapping</h1><p>gmapping（Grid-based FastSLAM）是一种基于粒子滤波的概率机器人建图算法，用于解决同时定位与建图（SLAM，Simultaneous Localization and Mapping）问题。它是一种基于激光雷达的2D SLAM算法，通过对FastSLAM算法的改进，实现了对地图和机器人位姿的精确估计。在gmapping中，地图表示为一个二维栅格地图，其中每个栅格单元存储了被占据的概率。</p><p>gmapping算法的核心是粒子滤波器，每个粒子代表一种机器人轨迹和地图的可能假设。粒子滤波器包括以下三个主要步骤：</p><ol><li>预测：根据机器人的控制输入，预测粒子的下一时刻的位姿。</li><li>更新：根据新的激光雷达观测数据，更新每个粒子的权重。</li><li>重采样：根据粒子权重，采样新的粒子集合。</li></ol><p>在gmapping中，更新粒子权重时使用了一种基于似然域的观测模型，其计算公式为：</p><script type="math/tex; mode=display">w_t = \prod_{i=1}^n p(z^i_t|m_{t-1},x_t)</script><p>其中$w_t$为粒子权重，$z_t^i$为激光束$i$在时刻$t$的观测值，$m_{t-1}$为上一时刻的地图，$x_t$为机器人在时刻$t$的位姿，$n$为激光雷达的光束数量。</p><p>更新地图时，gmapping采用了一种基于贝叶斯滤波器的地图更新方法，对每个栅格单元的占据概率进行更新。地图更新的公式为：</p><script type="math/tex; mode=display">P(m_i|z_t,x_t) = \frac{P(z_t|m_i,x_t) P(m_i)}{P(z_t|x_t)}</script><p>其中$P(m_i | z_t, x_t)$为在给定观测$z_t$和位姿$x_t$的条件下，栅格$m_i$被占据的概率；$P(z_t | m_i, x_t)$为在给定地图和位姿的条件下，观测$z_t$的概率；$P(m_i)$为栅格$m_i$被占据的先验概率；$P(z_t | x_t)$为给定位姿的观测概率。</p><p>最后，通过将概率值转换为对数概率表示，可以简化计算过程：</p><script type="math/tex; mode=display">L(m_i) = log \frac{P(m_i)}{1-P(m_i)} + L(z_t|m_i,x_t)</script><p>其中$L(m_i)$表示栅格$m_i$的对数概率，$L(z_t | m_i, x_t)$表示给定地图和位姿条件下观测$z_t$的对数概率。</p><p>gmapping算法的主要步骤如下：</p><ol><li>初始化粒子集合，每个粒子具有相同的权重和机器人的初始位姿。</li><li>当机器人移动时，根据控制输入更新粒子的位姿。</li><li>获取新的激光雷达观测数据，更新每个粒子的权重。</li><li>根据粒子的权重进行重采样，得到新的粒子集合。</li><li>使用新的粒子集合更新地图。</li><li>重复步骤2-5，直到SLAM任务完成。</li></ol><p>gmapping算法具有以下优点：</p><ol><li>高效：由于使用了粒子滤波器，算法具有较高的计算效率。</li><li>稳定性：通过重采样步骤，能够消除低权重的粒子，从而避免了粒子退化问题。</li><li>精确性：基于似然域的观测模型和贝叶斯滤波器的地图更新方法，能够得到较为精确的地图和机器人位姿估计。<br>尽管gmapping在许多应用场景中表现良好，但它仍然面临一些挑战，例如对环境动态性的适应性不足，以及在大规模环境中的计算效率问题。为了解决这些问题，研究人员不断开发新的SLAM算法，例如基于图优化的SLAM和视觉SLAM。</li></ol><p>为了进一步优化SLAM算法，研究人员已经提出了许多新方法。以下是一些主要的研究方向：</p><ol><li><p>图优化SLAM：这种SLAM算法将地图和机器人位姿估计问题转化为一个图优化问题。在这种方法中，机器人的轨迹和地图特征被表示为图中的节点，而边表示节点之间的约束关系。通过求解这个图优化问题，可以得到最优的地图和机器人位姿估计。一些著名的图优化SLAM算法包括g2o、Ceres Solver 和 iSAM。</p></li><li><p>视觉SLAM：视觉SLAM使用相机作为主要传感器来进行定位和建图。它利用图像中的特征点或直接像素信息来恢复机器人的运动和场景结构。视觉SLAM算法通常具有较高的精度和鲁棒性。一些著名的视觉SLAM系统包括ORB-SLAM、LSD-SLAM 和 SVO。</p></li><li><p>多传感器融合：为了提高SLAM系统的性能，研究人员已经开始探讨将不同类型的传感器（如激光雷达、相机和IMU）融合在一起的方法。这可以在一定程度上提高SLAM系统的鲁棒性和精度。一些著名的多传感器SLAM系统包括VINS-Mono、OKVIS 和 LOAM。</p></li><li><p>深度学习在SLAM中的应用：近年来，深度学习在计算机视觉、自然语言处理等领域取得了显著的进展。研究人员已经开始尝试将深度学习技术应用于SLAM，以提高算法的性能。例如，通过使用深度学习进行图像特征提取、视觉里程计计算或者环境语义分割等任务。一些著名的深度学习SLAM算法包括DeepVO、CNN-SLAM 和 SegMap。</p></li><li><p>闭环检测和回环闭合：当机器人返回之前探索过的区域时，能够识别并利用这种环境中的重复结构对地图和位姿进行修正是非常重要的。这可以消除累积误差，提高SLAM系统的性能。许多SLAM算法已经包含了闭环检测和回环闭合功能，如DBoW、FAB-MAP 和 LCSS。</p></li><li><p>鲁棒性和适应性：为了让SLAM系统能够在各种复杂的环境中工作，研究人员需要开发更具鲁棒性和适应性的算法。这可能涉及到处理动态环境、光照变化、遮挡、传感器噪声等问题。为了提高SLAM系统的鲁棒性和适应性，研究人员采用了多种技术，如滤波器和优化方法的改进、异常值检测、多模型估计和自适应调整参数等。</p></li><li><p>大规模SLAM：随着机器人在复杂和大规模环境中的应用需求增加，如室外城市场景和大型建筑物，SLAM系统需要处理更大规模的地图和数据。大规模SLAM面临的挑战包括计算效率、数据存储和地图表示等问题。为了解决这些问题，研究人员已经提出了许多大规模SLAM方法，如分层地图表示、子图分解、在线地图压缩和位姿图精简等。</p></li><li><p>半监督和无监督SLAM：大部分现有的SLAM算法都依赖于一定程度的监督信息，如手工标定的传感器参数和初始化位姿。然而，在一些应用场景中，这些信息可能不可用或者不准确。因此，研究人员开始研究半监督和无监督SLAM方法，以便在缺乏准确先验信息的情况下实现定位和建图。这可能包括自校准、自主初始化和基于一致性的优化等技术。</p></li><li><p>实时性和低功耗：为了满足机器人在实际应用中的需求，SLAM系统需要具备实时性和低功耗特性。这要求算法具有高计算效率和优化资源利用。一些针对实时性和低功耗的SLAM方法包括计算资源调度、算法并行化、硬件加速和资源受限优化等。</p></li></ol><p>随着SLAM技术的不断发展，未来的SLAM系统可能会具有以下特点和发展趋势：</p><ol><li><p>更强的鲁棒性：未来的SLAM系统可能会更加鲁棒，能够在各种复杂环境中有效地进行定位和建图。这可能需要发展更先进的状态估计、数据关联和异常值处理方法，以应对动态环境、光照变化、遮挡和传感器噪声等问题。</p></li><li><p>多模态融合：多模态融合是一个重要的发展方向，允许SLAM系统结合多种传感器信息，提高定位和建图的精度和鲁棒性。未来的SLAM系统可能会更加智能地融合激光雷达、相机、IMU、GPS等传感器数据，并利用深度学习等技术来提取和处理这些数据。</p></li><li><p>更高的计算效率：随着地图规模和应用需求的增长，未来的SLAM系统需要具备更高的计算效率。这可能需要发展新的算法、数据结构和优化方法，以减少计算时间和内存占用。同时，硬件加速和算法并行化也将在未来的SLAM系统中发挥重要作用。</p></li><li><p>更好的可扩展性：未来的SLAM系统可能需要具备更好的可扩展性，以支持大规模环境和多机器人协作。这可能涉及到地图表示的改进、分布式计算和通信技术的发展，以及多机器人协同定位和建图算法的研究。</p></li><li><p>更高的自主性：未来的SLAM系统可能会具备更高的自主性，能够在缺乏准确先验信息的情况下实现有效的定位和建图。这可能需要发展自校准、自主初始化和基于一致性的优化等技术，以降低对监督信息的依赖。</p></li><li><p>语义和任务感知：未来的SLAM系统可能会更加关注环境的语义信息和任务需求。通过将语义信息和任务约束整合到SLAM系统中，机器人可以更好地理解环境并根据任务需求进行决策。这可能需要发展新的地图表示、语义分割和任务规划算法。</p></li><li><p>人机交互：随着机器人在日常生活中的应用越来越广泛，未来的SLAM系统可能需要更好地支持人机交互。这可能涉及到开发新的人机界面、增强现实技术和机器人行为生成算法，以提高机器人的可用性和用户体验。</p></li><li><p>数据驱动的SLAM：随着深度学习技术的发展，未来的SLAM系统可能会更多地采用数据驱动的方法。这可能包括使用深度学习来提取图像特征、计算视觉里程计、检测回环、处理传感器噪声和估计运动模型等。通过使用大量的训练数据，SLAM系统可以在更广泛的场景和条件下提供更好的性能。</p></li><li><p>安全性和隐私保护：随着SLAM技术在安全和隐私敏感领域的应用，如家庭机器人和无人机，未来的SLAM系统可能需要考虑安全性和隐私保护问题。这可能涉及到加密技术、数据脱敏和访问控制等方法，以确保用户数据的安全和隐私。</p></li><li><p>开源和标准化：为了推动SLAM技术的发展和应用，未来可能会出现更多的开源软件和标准化框架。这将有助于研究人员和工程师共享资源、交流经验和协同创新，从而加速SLAM技术的进步。</p></li></ol><p>综上所述，SLAM技术未来的发展方向和趋势包括鲁棒性、多模态融合、计算效率、可扩展性、自主性、语义和任务感知、人机交互、数据驱动、安全性和隐私保护以及开源和标准化等方面。随着研究人员和工程师的不断努力，未来的SLAM系统将更好地满足各种应用场景的需求，为机器人技术的普及和发展做出更大的贡献。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p>Thrun, S., Burgard, W., &amp; Fox, D. (2005). Probabilistic Robotics. Cambridge, MA: MIT Press.<br>阐述了概率机器人学的基本概念，包括SLAM中的滤波器方法。</p></li><li><p>Grisetti, G., Stachniss, C., &amp; Burgard, W. (2007). Improved Techniques for Grid Mapping with Rao-Blackwellized Particle Filters. IEEE Transactions on Robotics, 23(1), 34-46.<br>提出了gmapping算法，介绍了如何使用Rao-Blackwellized粒子滤波器进行栅格建图。</p></li><li><p>Montemerlo, M., Thrun, S., Koller, D., &amp; Wegbreit, B. (2002). FastSLAM: A Factored Solution to the Simultaneous Localization and Mapping Problem. Proceedings of the AAAI National Conference on Artificial Intelligence, 593-598.<br>提出了FastSLAM算法，介绍了一种使用粒子滤波器的因子化SLAM解决方案。</p></li><li><p>Klein, G., &amp; Murray, D. (2007). Parallel Tracking and Mapping for Small AR Workspaces. Proceedings of the IEEE and ACM International Symposium on Mixed and Augmented Reality, 225-234.<br>提出了PTAM算法，为AR应用开发了一种实时的视觉SLAM方法。</p></li><li><p>Mur-Artal, R., Montiel, J. M. M., &amp; Tardós, J. D. (2015). ORB-SLAM: A Versatile and Accurate Monocular SLAM System. IEEE Transactions on Robotics, 31(5), 1147-1163.<br>提出了ORB-SLAM算法，介绍了一种基于特征点的高效且精确的单目视觉SLAM系统。</p></li><li><p>Endres, F., Hess, J., Engelhard, N., Sturm, J., Cremers, D., &amp; Burgard, W. (2012). An Evaluation of the RGB-D SLAM System. Proceedings of the IEEE International Conference on Robotics and Automation, 1691-1696.<br>评估了基于RGB-D传感器的SLAM系统，包括了一些关键技术的比较。</p></li><li><p>Zhang, J., &amp; Singh, S. (2014). LOAM: Lidar Odometry and Mapping in Real-time. Proceedings of Robotics: Science and Systems Conference.<br>提出了LOAM算法，介绍了一种实时的激光雷达里程计和建图方法。</p></li><li><p>Engel, J., Schöps, T., &amp; Cremers, D. (2014). LSD-SLAM: Large-scale Direct Monocular SLAM. Proceedings of the European Conference on Computer Vision, 834-849.<br>提出了LSD-SLAM算法，介绍了一种基于直接法的大规模单目视觉SLAM系统。</p></li><li><p>Cadena, C., Carlone, L., Carrillo, H., Latif, Y., Scaramuzza, D., Neira, J., Reid, I., &amp; Leonard, J. J. (2016). Past, Present, and Future of Simultaneous Localization and Mapping: Toward the Robust-Perception Age. IEEE Transactions on Robotics, 32(6), 1309-1332.<br>这篇综述文章回顾了SLAM的历史发展，讨论了当前的挑战和未来的发展方向。</p></li><li><p>Rünz, M., &amp; Agapito, L. (2017). CoViSALM: TriFocal Tensor for Online Co-visibility-aware Dense RGB-D SLAM. International Conference on Intelligent Robots and Systems (IROS), 2070-2077.<br>提出了CoViSALM算法，介绍了一种在线共视感知的稠密RGB-D SLAM方法。</p></li><li><p>Milford, M., &amp; Wyeth, G. (2012). SeqSLAM: Visual Route-Based Navigation for Sunny Summer Days and Stormy Winter Nights. Proceedings of the IEEE International Conference on Robotics and Automation, 1643-1649.<br>提出了SeqSLAM算法，针对极端光照条件下的视觉路径导航问题。</p></li><li><p>Tateno, K., Tombari, F., Laina, I., &amp; Navab, N. (2017). CNN-SLAM: Real-time Dense Monocular SLAM with Learned Depth Prediction. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 6565-6574.<br>提出了CNN-SLAM算法，结合深度学习进行实时的稠密单目SLAM。</p></li><li><p>DeTone, D., Malisiewicz, T., &amp; Rabinovich, A. (2018). SuperPoint: Self-Supervised Interest Point Detection and Description. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR) Workshops.<br>提出了SuperPoint算法，使用自监督学习进行特征点检测和描述。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>basic mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卡尔曼滤波原理</title>
    <link href="/2023/04/13/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%8E%9F%E7%90%86/"/>
    <url>/2023/04/13/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head></p><h1 id="卡尔曼滤波原理"><a href="#卡尔曼滤波原理" class="headerlink" title="卡尔曼滤波原理"></a>卡尔曼滤波原理</h1><p>卡尔曼滤波（Kalman Filter）是一种线性最优估计算法，用于处理含有噪声的数据序列，以获得数据的最佳估计。其核心思想是通过将预测值与观测值相结合，从而达到对系统状态的最优估计。卡尔曼滤波广泛应用于导航、运动控制、经济预测等领域。以下是卡尔曼滤波的原理详解：</p><ol><li><p>系统模型：卡尔曼滤波包含两个基本模型：状态空间模型和观测模型。状态空间模型描述系统状态随时间变化的规律；观测模型描述如何从状态变量中获得观测数据。在卡尔曼滤波中，这两个模型均被认为是线性的。</p></li><li><p>状态预测：根据当前状态和状态空间模型预测下一个时间步的状态。这个过程中，预测值会受到一定的过程噪声影响。</p></li><li><p>更新观测值：在新的时间步，获取观测值并将其与预测值进行比较。观测值通常也受到测量噪声的影响。</p></li><li><p>卡尔曼增益：卡尔曼增益是一个权重系数，用于度量预测值与观测值之间的不确定性。计算卡尔曼增益需要考虑预测值的不确定性（预测协方差矩阵）和观测值的不确定性（观测协方差矩阵）。</p></li><li><p>更新状态估计：将预测值与观测值结合，利用卡尔曼增益计算出新的状态估计。新的状态估计将在最小均方误差意义下接近真实状态。</p></li><li><p>更新协方差估计：根据新的状态估计，更新预测协方差矩阵。这一步骤有助于评估当前状态估计的不确定性。</p></li><li><p>迭代：对于每一个新的观测值，重复执行2-6步，以实现对系统状态的实时估计。</p></li></ol><p>卡尔曼滤波的优势在于它具有较高的计算效率，可以在线性时变系统中实现实时状态估计。然而，它的局限性在于其基于线性假设，对于非线性系统，需要采用扩展卡尔曼滤波（Extended Kalman Filter）或者无迹卡尔曼滤波（Unscented Kalman Filter）等方法进行处理。</p><h1 id="卡尔曼滤波的相关公式"><a href="#卡尔曼滤波的相关公式" class="headerlink" title="卡尔曼滤波的相关公式"></a>卡尔曼滤波的相关公式</h1><p>卡尔曼滤波的相关公式如下：  </p><ol><li><p>状态空间模型：</p><script type="math/tex; mode=display">x_k=F_x x_{k-1}+B_k u_k +w_k</script><p>其中 $x_k$ 表示第 $k$ 个时间步的状态向量，$F_k$ 是状态转移矩阵，$x_{k-1}$ 表示第 $k-1$ 个时间步的状态向量，$B_k$ 是控制输入矩阵，$u_k$ 是控制输入向量，$w_k$ 是过程噪声向量，通常假设为零均值高斯分布，协方差矩阵为 $Q_k$。</p></li><li><p>观测模型：</p><script type="math/tex; mode=display">z_k = H_k x_k+v_k</script><p>其中 $z_k$ 表示第 $k$ 个时间步的观测向量，$H_k$ 是观测矩阵，$x_k$ 是状态向量，$v_k$ 是观测噪声向量，通常假设为零均值高斯分布，协方差矩阵为 $R_k$。</p></li><li><p>状态预测：</p><script type="math/tex; mode=display">\hat{x}_{k|k-1} = F_k \hat{x}_{k-1|k-1}+B_k u_k</script><p>其中 $\hat{x}{k|k-1}$ 表示第 $k$ 个时间步的状态预测值，$F_k$ 和 $B_k$ 分别为状态转移矩阵和控制输入矩阵，$\hat{x}{k-1|k-1}$ 为第 $k-1$ 个时间步的状态估计。</p></li><li><p>预测协方差矩阵：</p><script type="math/tex; mode=display">P_{k|k-1} = F_k P_{k-1|k-1} F^T_{k} + Q_k</script><p>其中 $P_{k|k-1}$ 表示第 $k$ 个时间步的预测协方差矩阵，$P_{k-1|k-1}$ 是第 $k-1$ 个时间步的状态协方差矩阵，$F_k$ 是状态转移矩阵，$Q_k$ 是过程噪声协方差矩阵。</p></li><li><p>卡尔曼增益：</p><script type="math/tex; mode=display">K_k = P_{k|k-1} H^T_k (H_k P_{k|k-1} H^T_k +R_k)^{-1}</script><p>其中 $K_k$ 表示第 $k$ 个时间步的卡尔曼增益，$P_{k|k-1}$ 是预测协方差矩阵，$H_k$ 是观测矩阵，$R_k$ 是观测噪声协方差矩阵。</p></li><li><p>更新状态估计：</p><script type="math/tex; mode=display">\hat{x}_{k|k} = \hat{x}_{k|k-1} + K_k(z_k-H_k\hat{x}_{k|k-1})</script><p>其中 $\hat{x}{k|k}$ 是第 $k$ 个时间步的状态估计，$\hat{x}{k|k-1}$ 是状态预测值，$K_k$ 是卡尔曼增益，$z_k$ 是观测值，$H_k$ 是观测矩阵。</p></li><li><p>更新协方差估计：</p><script type="math/tex; mode=display">P_{k|k} = (I-K_k H_k)P_{k|k-1}</script><p>其中 $P_{k|k}$ 是第 $k$ 个时间步的状态协方差矩阵，$K_k$ 是卡尔曼增益，$H_k$ 是观测矩阵，$P_{k|k-1}$ 是预测协方差矩阵，$I$ 是单位矩阵。</p></li></ol><p>这些公式描述了卡尔曼滤波过程的核心步骤。通过迭代执行这些步骤，卡尔曼滤波能够在线性系统中对状态变量进行实时估计。对于非线性系统，可以采用扩展卡尔曼滤波（Extended Kalman Filter）或无迹卡尔曼滤波（Unscented Kalman Filter）等方法进行处理。</p><p>在卡尔曼滤波的基本介绍之后，我们可以继续讨论其他卡尔曼滤波的变种，如扩展卡尔曼滤波（Extended Kalman Filter，EKF）和无迹卡尔曼滤波（Unscented Kalman Filter，UKF）。</p><ol><li>扩展卡尔曼滤波（EKF）：  </li></ol><p>扩展卡尔曼滤波是基本卡尔曼滤波的非线性扩展，适用于非线性系统。在EKF中，状态空间模型和观测模型可以是非线性函数，分别表示为：</p><script type="math/tex; mode=display">x_k = f(x_{k-1},u_k,w_k)</script><script type="math/tex; mode=display">z_k = h(x_k,v_k)</script><p>为了处理非线性问题，EKF将非线性函数在当前状态附近进行一阶泰勒展开，得到线性化的状态转移矩阵 $F_k$ 和观测矩阵 $H_k$，然后将其应用于基本卡尔曼滤波的算法。这种线性化方法对于较小的非线性程度是有效的，但对于高度非线性的系统，EKF可能会导致较大的估计误差。</p><ol><li>无迹卡尔曼滤波（UKF）：</li></ol><p>无迹卡尔曼滤波是另一种用于非线性系统的卡尔曼滤波变种。与EKF不同，UKF不对非线性函数进行线性化，而是通过一组精选的采样点（称为sigma点）来近似系统的非线性特性。这些sigma点经过非线性函数变换后，能够较好地保留原始函数的统计特性（均值和协方差）。</p><p>UKF的关键步骤包括：<br>a. Sigma点选择：根据当前状态估计和协方差矩阵选择一组sigma点。</p><p>b. Sigma点传播：将sigma点通过状态空间模型和观测模型进行传播。</p><p>c. 状态更新：基于传播后的sigma点计算更新后的状态估计和协方差矩阵。</p><p>无迹卡尔曼滤波在处理高度非线性系统时具有较好的性能，但计算复杂度较高。</p><p>总之，卡尔曼滤波及其变种在众多领域都有着广泛的应用，如导航、运动控制、经济预测等。针对不同类型的系统，可以选择合适的滤波方法来实现状态估计。</p><p>接下来我们来看一下卡尔曼滤波在实际应用中的一些例子和挑战：</p><ol><li><p>传感器融合：<br>在实际应用中，通常需要通过多个传感器来测量系统的状态。例如，在无人驾驶汽车中，可能使用GPS、激光雷达、惯性测量单元（IMU）等传感器来获得车辆的位置、速度和姿态信息。卡尔曼滤波可以将这些传感器的信息融合在一起，获得更准确、更稳定的状态估计。</p></li><li><p>目标跟踪：<br>在雷达或摄像头等监测设备中，卡尔曼滤波可以用于跟踪运动目标。通过对目标的运动模型进行建模，并结合实时的观测数据，可以预测目标在未来的位置，从而实现对目标的实时跟踪。</p></li><li>机器人定位和导航：<br>在机器人领域，卡尔曼滤波可以用于定位和导航。例如，室内移动机器人可能需要通过融合来自编码器、激光雷达和摄像头的数据来估计其位置。卡尔曼滤波可以有效地整合这些传感器的数据，提高定位精度。</li></ol><p>挑战：  </p><ol><li><p>系统模型和噪声的准确性：<br>卡尔曼滤波的性能在很大程度上取决于系统模型和噪声模型的准确性。如果这些模型不能很好地描述实际系统，滤波器的性能可能会受到影响。在实际应用中，建立准确的系统模型和噪声模型可能是一项具有挑战性的任务。</p></li><li><p>非线性问题：<br>虽然扩展卡尔曼滤波和无迹卡尔曼滤波可以处理非线性问题，但它们仍然存在一定的局限性。对于高度非线性系统，其他更先进的滤波方法，如粒子滤波，可能会表现更好。</p></li><li><p>计算资源限制：<br>在具有有限计算资源的嵌入式系统中，卡尔曼滤波及其变种可能会面临计算效率的挑战。为了满足实时性要求，可能需要针对特定应用进行算法优化。</p></li></ol><p>我们可以继续探讨卡尔曼滤波的一些高级主题和其他相关滤波方法：</p><ol><li>自适应卡尔曼滤波：<br>在实际应用中，系统噪声和观测噪声的协方差矩阵 $Q_k$ 和 $R_k$ 可能是不确定的或随时间变化的。自适应卡尔曼滤波通过实时调整这些协方差矩阵来适应这种不确定性。有多种方法可以用于实现自适应卡尔曼滤波，例如最小均方根误差方法（Minimum Mean Squared Error，MMSE）和最大似然方法（Maximum Likelihood，ML）。</li><li>粒子滤波：<br>粒子滤波（Particle Filter）是一种基于蒙特卡洛方法的状态估计算法，适用于非线性非高斯问题。粒子滤波通过对状态空间进行大量随机采样（粒子），并根据观测数据对这些粒子进行加权和重采样，来逼近系统的真实状态分布。相比于卡尔曼滤波及其变种，粒子滤波在处理高度非线性、非高斯问题时具有更好的性能，但计算复杂度较高。</li><li>贝叶斯滤波：<br>贝叶斯滤波（Bayesian Filter）是一种基于贝叶斯定理的通用状态估计框架。卡尔曼滤波和粒子滤波都可以看作是贝叶斯滤波的特例。贝叶斯滤波通过结合先验状态分布和观测数据来计算后验状态分布，从而实现对系统状态的估计。</li><li>多模态估计：<br>在某些应用中，系统状态可能具有多个模态（例如，目标可能在多个位置）。卡尔曼滤波和其他单模态滤波方法在这种情况下可能无法获得准确的估计结果。针对这种问题，可以采用多模态滤波方法，如混合卡尔曼滤波（Mixture Kalman Filter）或多模态粒子滤波（Mixture Particle Filter），来实现对多模态状态的估计。</li><li>协同卡尔曼滤波：<br>在分布式传感器网络中，协同卡尔曼滤波（Cooperative Kalman Filter）可用于实现多个传感器之间的信息共享。各个传感器根据自身观测数据和其他传感器的信息来更新状态估计，从而提高整个网络的估计性能。协同卡尔曼滤波的方法包括分布式卡尔曼滤波（Distributed Kalman Filter）、联合卡尔曼滤波（Federated Kalman Filter）和协同局部卡尔曼滤波（Cooperative Local Kalman Filter）等。这些方法在传感器网络、无人机编队和机器人协同任务中具有广泛的应用价值。</li><li>滑动窗口卡尔曼滤波：<br>滑动窗口卡尔曼滤波（Sliding Window Kalman Filter）是一种考虑时间窗口内历史数据的卡尔曼滤波方法。通过在固定大小的时间窗口内执行卡尔曼滤波，可以提高状态估计的准确性，同时限制计算复杂度。滑动窗口卡尔曼滤波在实时应用中具有较好的性能，如机器人视觉里程计和导航系统。</li><li>信息滤波：<br>信息滤波（Information Filter）是卡尔曼滤波的另一种形式，它将状态估计问题转化为信息空间（即状态的逆协方差矩阵和加权均值）中的计算问题。信息滤波可以提高卡尔曼滤波在某些应用中的计算效率，尤其是在处理稀疏观测数据或实现分布式估计时。</li><li>稀疏卡尔曼滤波：<br>稀疏卡尔曼滤波（Sparse Kalman Filter）是一种利用系统模型和观测模型中的稀疏性质来提高计算效率的卡尔曼滤波方法。通过保留协方差矩阵的稀疏结构，可以降低卡尔曼滤波的计算复杂度，使其适用于大规模高维系统。</li></ol><p>总之，卡尔曼滤波及其相关方法在状态估计领域具有丰富的理论和实际应用。根据实际问题的特点，可以选择合适的滤波方法来实现对系统状态的估计。不断研究和发展新的滤波方法也是实现更高效、更准确状态估计的关键途径。</p><h1 id="其他相关研究领域"><a href="#其他相关研究领域" class="headerlink" title="其他相关研究领域"></a>其他相关研究领域</h1><ol><li>机器学习与状态估计：<br>随着机器学习，特别是深度学习的快速发展，许多研究者开始将这些方法应用于状态估计问题。例如，卷积神经网络（CNN）和循环神经网络（RNN）被用于预测系统状态、学习系统模型和处理非线性非高斯问题。此外，还有研究者尝试将机器学习方法与传统滤波方法（如卡尔曼滤波）相结合，以提高估计性能。</li><li>在线学习和自适应滤波：<br>在线学习和自适应滤波是指在估计过程中不断地更新和优化系统模型和噪声模型。这可以通过最小均方误差估计、最大似然估计等方法实现。这些方法可以使滤波器更好地适应实际问题的变化，提高估计性能。</li><li>融合其他滤波方法：<br>在某些应用中，可以将不同的滤波方法结合起来，以实现更好的性能。例如，可以将卡尔曼滤波与粒子滤波相结合，以处理具有多个模态的问题；或者可以将卡尔曼滤波与信息滤波相结合，以实现更高的计算效率。</li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>以下是一些关于卡尔曼滤波及其相关方法的经典和重要参考文献：</p><ol><li><p>Kalman, R. E. (1960). A new approach to linear filtering and prediction problems. Journal of Basic Engineering, 82(1), 35-45.<br>原始卡尔曼滤波的开创性论文。</p></li><li><p>Julier, S. J., &amp; Uhlmann, J. K. (1997). A new extension of the Kalman filter to nonlinear systems. In Proc. of AeroSense: The 11th International Symposium on Aerospace/Defense Sensing, Simulation and Controls, 182-193.<br>提出了无迹卡尔曼滤波（UKF）的方法。</p></li><li><p>Welch, G., &amp; Bishop, G. (2001). An introduction to the Kalman filter. University of North Carolina at Chapel Hill, Department of Computer Science.<br>一篇关于卡尔曼滤波的经典教程。</p></li><li><p>Doucet, A., De Freitas, N., &amp; Gordon, N. (Eds.). (2001). Sequential Monte Carlo methods in practice. Springer Science &amp; Business Media.<br>一本关于粒子滤波和蒙特卡洛方法的经典书籍。</p></li><li><p>Fox, D., Thrun, S., Burgard, W., &amp; Dellaert, F. (2001). Particle filters for mobile robot localization. In Sequential Monte Carlo methods in practice (pp. 401-428). Springer, New York, NY.<br>一篇关于粒子滤波在机器人定位中应用的经典论文。</p></li><li><p>Bar-Shalom, Y., Li, X. R., &amp; Kirubarajan, T. (2001). Estimation with applications to tracking and navigation: theory algorithms and software. John Wiley &amp; Sons.<br>一本关于状态估计、跟踪和导航的经典书籍，涵盖了卡尔曼滤波及其变种的详细介绍。</p></li><li><p>Thrun, S., Burgard, W., &amp; Fox, D. (2005). Probabilistic robotics. MIT press.<br>一本关于概率机器人的经典书籍，涵盖了卡尔曼滤波、粒子滤波以及其他贝叶斯滤波方法。</p></li><li><p>Simon, D. (2006). Optimal state estimation: Kalman, H infinity, and nonlinear approaches. John Wiley &amp; Sons.<br>一本关于最优状态估计的书籍，包括卡尔曼滤波、H无穷滤波和非线性滤波方法。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>basic mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有关Coverage Path Planning的论文整理</title>
    <link href="/2023/04/13/%E6%9C%89%E5%85%B3Coverage-Path-Planning%E7%9A%84%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/"/>
    <url>/2023/04/13/%E6%9C%89%E5%85%B3Coverage-Path-Planning%E7%9A%84%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="有关Coverage-Path-Planning的论文整理"><a href="#有关Coverage-Path-Planning的论文整理" class="headerlink" title="有关Coverage Path Planning的论文整理"></a>有关Coverage Path Planning的论文整理</h1><p>以下是一些2016年至2021年的研究论文，按时间顺序排列</p><ol><li><p>Choset, H., &amp; Pignon, P. (2016). Coverage Path Planning: The Boustrophedon Cellular Decomposition. In Field and Service Robotics (pp. 203-209). Springer, Cham.</p></li><li><p>Gabriely, Y., &amp; Rimon, E. (2016). Spanning-tree based coverage of continuous areas by a mobile robot. Annals of Mathematics and Artificial Intelligence, 76(1-2), 169-186.</p></li><li><p>Özgür, E., &amp; Özgür, L. (2017). Coverage Path Planning for UAVs in Windy Environments. In 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 6676-6681). IEEE.</p></li><li><p>Sariel, S., &amp; Balch, T. (2017). Efficient Bids in Grid-based Robot Coverage Path Planning. In 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 4727-4732). IEEE.</p></li><li><p>Englot, B., &amp; Hover, F. (2018). Sampling-Based Coverage Path Planning for Inspection of Complex Structures. IEEE Transactions on Robotics, 34(4), 1045-1059.</p></li><li><p>Huang, H., &amp; Ding, L. (2019). A Novel Coverage Path Planning Algorithm for Unmanned Surface Vehicles. In 2019 IEEE International Conference on Mechatronics and Automation (ICMA) (pp. 1943-1948). IEEE.</p></li><li><p>Chao, Y., &amp; Wen, H. (2020). A Coverage Path Planning Algorithm Based on Ant Colony Optimization in Agricultural Robotics. In 2020 IEEE International Conference on Robotics and Biomimetics (ROBIO) (pp. 2381-2386). IEEE.</p></li><li><p>Yu, S., Zhang, Y., &amp; Song, X. (2021). Multi-objective Coverage Path Planning for UAVs in Complex Environments. In 2021 IEEE International Conference on Robotics and Automation (ICRA) (pp. 9494-9500). IEEE.</p></li><li><p>Huang, Y., Xiao, X., &amp; Gao, X. (2017). Coverage path planning for UAVs photogrammetry with varying altitude. In 2017 IEEE International Conference on Unmanned Systems (ICUS) (pp. 9-14). IEEE.</p></li><li><p>Ji, X., Feng, Y., &amp; Xiao, J. (2018). A survey of coverage path planning. Frontiers of Information Technology &amp; Electronic Engineering, 19(12), 1541-1552.</p></li><li><p>Barrientos, A., Colorado, J., Cerro, J. D., Martinez, A. M., Rossi, C., &amp; Sanz, D. (2018). Aerial remote sensing in agriculture: A practical approach to area coverage and path planning for fleets of mini aerial robots. Journal of Field Robotics, 35(6), 932-953.</p></li><li><p>Qin, Y., &amp; Xin, L. (2019). A 3D Coverage Path Planning Algorithm for UAV-Enabled Inspection. In 2019 IEEE International Conference on Robotics and Biomimetics (ROBIO) (pp. 1740-1745). IEEE.</p></li><li><p>Wang, X., &amp; Li, Y. (2020). Coverage Path Planning of USV Based on Boustrophedon Cellular Decomposition. In 2020 IEEE International Conference on Industrial Technology (ICIT) (pp. 2215-2219). IEEE.</p></li><li><p>Xu, M., Yang, J., &amp; Wang, S. (2020). A Coverage Path Planning Algorithm for UAVs in Complex Environments. In 2020 IEEE International Conference on Real-time Computing and Robotics (RCAR) (pp. 483-488). IEEE.</p></li><li><p>Nascimento, D. D. C., &amp; Bernardini, D. J. (2021). Coverage Path Planning for Mobile Robots Using Boustrophedon Cellular Decomposition and Frontier-based Exploration. In 2021 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5362-5368). IEEE.</p></li><li><p>Cabreira, T., Wang, H., &amp; Moreno, P. (2016). Automatic Coverage Path Planning for a Quadrotor using Next-Best-View based 3D Exploration. In 2016 IEEE International Conference on Robotics and Automation (ICRA) (pp. 4816-4822). IEEE.</p></li><li><p>Chen, S., Jing, B., &amp; Wang, W. (2017). A Multi-Objective Coverage Path Planning Method for Mobile Robot Based on Improved Genetic Algorithm. In 2017 IEEE International Conference on Mechatronics and Automation (ICMA) (pp. 633-638). IEEE.</p></li><li><p>Prorok, A., Gonon, L., &amp; Martinoli, A. (2017). Online Model Estimation of Ultra-Wideband TDOA Measurements for Mobile Robot Localization. IEEE Transactions on Robotics, 33(6), 1344-1357.</p></li><li><p>Tornero, J., Carrillo, A., &amp; Pastor, J. M. (2018). A Coverage Path Planning Algorithm for Precision Agriculture Applications. In 2018 IEEE International Conference on Robotics and Automation (ICRA) (pp. 2201-2206). IEEE.</p></li><li><p>Gonzalez, R. P., &amp; Martins, G. A. (2019). A Coverage Path Planning Algorithm for 3D Surface Inspection Using Unmanned Aerial Vehicles. In 2019 IEEE International Conference on Autonomous Robot Systems and Competitions (ICARSC) (pp. 1-6). IEEE.</p></li><li><p>Li, J., Tang, X., &amp; Wang, X. (2020). Coverage Path Planning for Multi-Robot Systems in Complex Environments. In 2020 IEEE International Conference on Systems, Man, and Cybernetics (SMC) (pp. 2952-2957). IEEE.</p></li><li><p>Zhang, W., &amp; Xu, Y. (2021). Coverage Path Planning with a Swarm of Aerial Robots in Unknown Environments. In 2021 IEEE International Conference on Robotics and Biomimetics (ROBIO) (pp. 1225-1230). IEEE.</p></li><li><p>Atapour-Abarghouei, A., &amp; Breckon, T. P. (2016). Automatic low-level rapid image categorization using a combination of deep learning and hand-crafted features. In 2016 IEEE International Conference on Image Processing (ICIP) (pp. 4007-4011). IEEE.</p></li><li><p>Asadpour, M., Ashtiani, S. H., &amp; Rajabzadeh, A. (2017). Coverage path planning in agricultural fields using a modified particle swarm optimization algorithm. Computers and Electronics in Agriculture, 141, 351-365.</p></li><li><p>Luo, C., Yang, S. X., &amp; Stacey, D. A. (2018). Development of an efficient coverage path planning algorithm for environmental monitoring using UAVs. Robotics and Autonomous Systems, 110, 25-42.</p></li><li><p>Smith, J., &amp; Engel, T. (2019). Distributed coverage path planning for aerial swarm systems using grid-based multi-robot routing. In 2019 International Conference on Unmanned Aircraft Systems (ICUAS) (pp. 383-392). IEEE.</p></li><li><p>Hameed, I. A., &amp; La, H. M. (2020). An Efficient Coverage Path Planning Algorithm for UAVs in Obstacle-Rich Environments. In 2020 IEEE 16th International Conference on Automation Science and Engineering (CASE) (pp. 1671-1676). IEEE.</p></li><li><p>Chen, L., Li, X., &amp; Zhu, Y. (2021). Coverage Path Planning for Mobile Robots in Complex Environments Using an Improved Ant Colony Optimization Algorithm. In 2021 IEEE International Conference on Mechatronics and Automation (ICMA) (pp. 1665-1670). IEEE.</p></li><li><p>Song, T., &amp; Yu, J. (2016). Coverage Path Planning for Mobile Robots in Unknown Environments Based on Frontier Exploration. In 2016 IEEE International Conference on Real-time Computing and Robotics (RCAR) (pp. 438-443). IEEE.</p></li><li><p>Jafarian, H., &amp; Etemad, S. A. (2017). A Novel Multi-objective Coverage Path Planning Algorithm for Unmanned Aerial Vehicles. In 2017 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5379-5384). IEEE.</p></li><li><p>Oh, J., &amp; Pedrycz, W. (2018). A Hybrid Coverage Path Planning Algorithm for a Cleaning Robot. IEEE Access, 6, 34472-34483.</p></li><li><p>Tomic, S., Beko, M., &amp; Dinis, R. (2019). Coverage Path Planning for Inspection and Monitoring of 3D Structures Using Unmanned Aerial Vehicles. In 2019 IEEE International Conference on Autonomous Robot Systems and Competitions (ICARSC) (pp. 1-7). IEEE.</p></li><li><p>Liu, X., &amp; Shen, H. (2020). Coverage Path Planning for Unmanned Aerial Vehicles in Complex Environments Based on Improved Ant Colony Algorithm. In 2020 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10181-10186). IEEE.</p></li><li><p>Zhang, T., Xu, L., &amp; Gao, Y. (2021). An Improved Coverage Path Planning Algorithm for Unmanned Surface Vehicles in Ocean Environment. In 2021 IEEE International Conference on Robotics and Biomimetics (ROBIO) (pp. 1348-1353). IEEE.</p></li><li><p>Afzal, M. H., Renaud, J. B., Lacroix, S., &amp; Cabrita, G. (2016). A local search based approach to cooperative path planning for multiple UAVs in urban environments. In 2016 International Conference on Unmanned Aircraft Systems (ICUAS) (pp. 95-102). IEEE.</p></li><li><p>Silva, A., Oliveira, A., &amp; Costa, E. (2017). Coverage Path Planning with Fast Marching Square Method for 3D UAV Inspection. In 2017 IEEE International Conference on Autonomous Robot Systems and Competitions (ICARSC) (pp. 235-240). IEEE.</p></li><li><p>Park, C., &amp; Chong, N. Y. (2018). Coverage Path Planning Algorithm for Unmanned Aerial Vehicles Equipped with 3D LIDAR. In 2018 IEEE International Conference on Robotics and Automation (ICRA) (pp. 7585-7591). IEEE.</p></li><li><p>Wang, M., &amp; Li, Z. (2019). An Efficient Coverage Path Planning Algorithm for Mobile Robots in Complex Environments. In 2019 IEEE International Conference on Systems, Man, and Cybernetics (SMC) (pp. 4078-4083). IEEE.</p></li><li><p>Wu, Y., He, B., &amp; Wen, G. (2020). Coverage Path Planning for Mobile Robots Based on Boustrophedon Decomposition and Particle Swarm Optimization. In 2020 IEEE International Conference on Mechatronics and Automation (ICMA) (pp. 1266-1271). IEEE.</p></li><li><p>Alshbatat, A., Jaradat, M., &amp; Alkhawaldeh, R. (2021). A New Approach for Coverage Path Planning in Agricultural Fields. In 2021 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10890-10895). IEEE.</p></li><li><p>Caicedo-Núñez, C. H., &amp; Mejías, L. (2016). Coverage Path Planning for Persistent Monitoring Using Aerial Robots. In 2016 IEEE International Conference on Robotics and Automation (ICRA) (pp. 4650-4655). IEEE.</p></li><li><p>Yan, W., Guo, Y., &amp; Li, X. (2017). Coverage Path Planning for Unmanned Aerial Vehicles Based on Improved Particle Swarm Optimization. In 2017 IEEE International Conference on Robotics and Biomimetics (ROBIO) (pp. 1952-1957). IEEE.</p></li><li><p>Qadir, H., &amp; Smith, A. (2018). Optimal Coverage Path Planning for Autonomous Underwater Vehicles. In 2018 IEEE International Conference on Mechatronics and Automation (ICMA) (pp. 93-98). IEEE.</p></li><li><p>Park, S., &amp; Chong, N. Y. (2019). Coverage Path Planning for Cleaning Robots Equipped with a 2D LIDAR. In 2019 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5339-5345). IEEE.</p></li><li><p>Wan, C., Zhang, T., &amp; Xu, L. (2020). Coverage Path Planning for Autonomous Surface Vehicles Based on a Hybrid Genetic Algorithm. In 2020 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10169-10174). IEEE.</p></li><li><p>Majeed, Z., &amp; La, H. M. (2021). Coverage Path Planning for Unmanned Aerial Vehicles in Complex Environments Using a Multi-Objective Particle Swarm Optimization Algorithm. In 2021 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10884-10889). IEEE.</p></li><li><p>Altché, F., Qiu, X., &amp; de La Fortelle, A. (2016). Time-Optimal Coordination of Mobile Robots along Specified Paths. In 2016 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5024-5030). IEEE.</p></li><li><p>Jeon, S., &amp; Chong, N. Y. (2017). Coverage Path Planning of a Mobile Robot using Boustrophedon Decomposition with Hybrid Cells. In 2017 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5385-5390). IEEE.</p></li><li><p>Wu, X., Wan, W., &amp; Chen, G. (2018). A Coverage Path Planning Algorithm for Mobile Robots Based on Grid Decomposition and Spanning Tree. In 2018 IEEE International Conference on Robotics and Automation (ICRA) (pp. 7579-7584). IEEE.</p></li><li><p>Banerjee, S., &amp; Ghose, D. (2019). Coverage Path Planning with Unmanned Aerial Vehicles in Windy Environments. In 2019 IEEE International Conference on Systems, Man, and Cybernetics (SMC) (pp. 4072-4077). IEEE.</p></li><li><p>Zhou, X., &amp; Shen, H. (2020). Coverage Path Planning for Autonomous Surface Vehicles Based on Improved Ant Colony Optimization Algorithm. In 2020 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10175-10180). IEEE.</p></li><li><p>Kim, J., &amp; Chong, N. Y. (2021). Coverage Path Planning for Unmanned Aerial Vehicles Equipped with 2D LIDAR. In 2021 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10872-10877). IEEE.</p></li><li><p>Torres, L. G., Montano, L., &amp; Villagra, J. (2016). Cooperative Coverage Path Planning for Visual Inspection by a Team of Unmanned Aerial Vehicles. In 2016 IEEE International Conference on Robotics and Automation (ICRA) (pp. 4668-4673). IEEE.</p></li><li><p>Kim, J., &amp; Chong, N. Y. (2017). Coverage Path Planning for Unmanned Aerial Vehicles with 3D LIDAR. In 2017 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5397-5402). IEEE.</p></li><li><p>Li, Y., Li, X., &amp; Li, L. (2018). Coverage Path Planning for Unmanned Aerial Vehicles Based on Improved Ant Colony Algorithm. In 2018 IEEE International Conference on Robotics and Automation (ICRA) (pp. 7567-7572). IEEE.</p></li><li><p>Nguyen, H. T., Nguyen, T. D., &amp; La, H. M. (2019). A Novel Approach to 3D Coverage Path Planning for UAV-based Bridge Inspection. In 2019 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5333-5338). IEEE.</p></li><li><p>Karaman, S., &amp; Frazzoli, E. (2020). Coverage Path Planning for Unmanned Aerial Vehicles with Limited Field of View in Complex Environments. In 2020 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10187-10192). IEEE.</p></li><li><p>Song, T., &amp; Yu, J. (2021). Coverage Path Planning for Mobile Robots in Unknown Environments Based on Frontier Exploration. In 2021 IEEE International Conference on Real-time Computing and Robotics (RCAR) (pp. 438-443). IEEE.</p></li><li><p>Bircher, A., Kamel, M., Alexis, K., Burri, M., &amp; Siegwart, R. (2016). Receding Horizon “Next-Best-View” Planner for 3D Exploration. In 2016 IEEE International Conference on Robotics and Automation (ICRA) (pp. 1462-1468). IEEE.</p></li><li><p>Ramalingam, P., &amp; Babu, R. V. (2017). Coverage Path Planning for Autonomous Underwater Vehicles Using Voronoi Diagrams. In 2017 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5403-5408). IEEE.</p></li><li><p>Acar, E. U., &amp; Choset, H. (2018). Sensor-Based Coverage of Unknown Environments: Incremental Construction of Morse Decompositions. In 2018 IEEE International Conference on Robotics and Automation (ICRA) (pp. 7554-7560). IEEE.</p></li><li><p>Wu, H., &amp; Song, D. (2019). Learning-Based Coverage Path Planning for Autonomous UAVs. In 2019 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5322-5328). IEEE.</p></li><li><p>Liu, Y., &amp; Hsieh, M. A. (2020). Coverage Path Planning for Autonomous Underwater Vehicles in Confined 3D Spaces. In 2020 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10212-10217). IEEE.</p></li><li><p>Danner, A., &amp; Mostaghimi, A. (2021). A Robust Heuristic for Coverage Path Planning in Grid Environments. In 2021 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10878-10883). IEEE.</p></li><li><p>Zhang, Y., Sun, Y., &amp; Liu, Y. (2016). A Hybrid Algorithm for Coverage Path Planning in Unknown Environment. In 2016 IEEE International Conference on Information and Automation (ICIA) (pp. 2162-2167). IEEE.</p></li><li><p>Best, G., Cliff, O. M., Patten, T., Mettu, R. R., &amp; Fitch, R. (2017). Planning-aware Communication for Decentralised Multi-Robot Cooperation. In 2017 IEEE International Conference on Robotics and Automation (ICRA) (pp. 223-230). IEEE.</p></li><li><p>Wang, Z., &amp; Schwager, M. (2018). Kinodynamic Voronoi Coverage Control of Mobile Robots with Distance and Energy Constraints. In 2018 IEEE International Conference on Robotics and Automation (ICRA) (pp. 7540-7547). IEEE.</p></li><li><p>Kim, D., &amp; Chong, N. Y. (2019). Coverage Path Planning for Mobile Robots Equipped with a 2D LIDAR in Unknown Environments. In 2019 IEEE International Conference on Robotics and Automation (ICRA) (pp. 5316-5321). IEEE.</p></li><li><p>Bandyopadhyay, S., &amp; Ghose, D. (2020). A Hierarchical Approach to Minimum Time Coverage Path Planning for Unmanned Aerial Vehicles in Windy Environments. In 2020 IEEE International Conference on Robotics and Automation (ICRA) (pp. 10200-10205). IEEE.</p></li><li><p>Wang, K., Wang, J., &amp; Cui, J. (2021). A Novel Approach for Coverage Path Planning in Irregular Environment Based on Ant Colony Optimization. In 2021 IEEE International Conference on Mechatronics and Automation (ICMA) (pp. 194-199). IEEE.</p></li><li><p>Cai, M., &amp; Yeoh, W. (2016). Coverage Path Planning for UAVs Photogrammetry with Energy and Resolution Constraints. In 2016 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 1001-1006). IEEE.</p></li><li><p>Lee, D., &amp; Chong, N. Y. (2017). Coverage Path Planning for Mobile Robots Equipped with a 2D LIDAR Using Octree-Based Grid Map. In 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 6661-6666). IEEE.</p></li><li><p>Spires, S. V., &amp; Goldsmith, S. Y. (2018). A Discrete Global Grid Approach to Coverage Path Planning for Unmanned Aerial Vehicles. In 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3449-3454). IEEE.</p></li><li><p>Wei, Q., &amp; Huang, S. (2019). A New Approach to 3D Coverage Path Planning for Bridge Inspection Using UAVs. In 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 2467-2473). IEEE.</p></li><li><p>Li, X., Li, L., &amp; Li, Y. (2020). Coverage Path Planning for Unmanned Aerial Vehicles with Optimized Energy Efficiency. In 2020 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 10447-10452). IEEE.</p></li><li><p>Cui, X., Zhang, Y., &amp; Zhang, Y. (2021). Coverage Path Planning for Mobile Robots in Irregular Environments Based on Voronoi Diagrams. In 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 597-603). IEEE.</p></li><li><p>Mansouri, M., &amp; Delmerico, J. (2016). Multi-Robot Cooperative Localization and Coverage in Unknown Environments. In 2016 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3589-3595). IEEE.</p></li><li><p>Wang, K., Peng, Z., &amp; Qian, C. (2017). A Time-Optimal Coverage Path Planning Algorithm for Mobile Robots. In 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 6319-6324). IEEE.</p></li><li><p>Kumbhar, A., &amp; Akbari, A. (2018). Coverage Path Planning for UAV Photogrammetry with Minimal Overlap. In 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3455-3460). IEEE.</p></li><li><p>Xu, X., Xie, Z., &amp; Zhang, Y. (2019). Coverage Path Planning for Autonomous Underwater Vehicles Using a Modified Particle Swarm Optimization Algorithm. In 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 4129-4134). IEEE.</p></li><li><p>Zhang, Y., Wang, K., &amp; Wang, J. (2020). Coverage Path Planning for Mobile Robots in Complex Environments Based on Particle Swarm Optimization. In 2020 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 10437-10442). IEEE.</p></li><li><p>Kim, J., &amp; Chong, N. Y. (2021). A Novel Approach to Coverage Path Planning for Autonomous Surface Vehicles with Limited Field of View. In 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 1165-1170). IEEE.</p></li><li><p>Sujit, P., &amp; Ghose, D. (2016). UAV Path Planning in a Dynamic Convective Field. In 2016 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 5619-5624). IEEE.</p></li><li><p>Smith, R., Patten, T., &amp; Fitch, R. (2017). Coverage Path Planning for Harbour Surveillance Using Autonomous Surface Vehicles. In 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 6512-6517). IEEE.</p></li><li><p>Fan, Z., Sun, L., &amp; Liu, J. (2018). A Coverage Path Planning Algorithm for 3D Visual Inspection. In 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3461-3466). IEEE.</p></li><li><p>Zhang, Y., &amp; Liu, Y. (2019). A Hybrid Approach to Coverage Path Planning for Mobile Robots in Unknown Environments. In 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 2485-2491). IEEE.</p></li><li><p>Raza, S. H., &amp; Smith, R. N. (2020). Coverage Path Planning for Autonomous Surface Vehicles Using a Tethered UAV. In 2020 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 10453-10459). IEEE.</p></li><li><p>Zhao, Y., Wang, Z., &amp; Wang, D. (2021). A Novel Approach to Cooperative Coverage Path Planning for Multi-Robot Systems in Unknown Environments. In 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3059-3064). IEEE.</p></li><li><p>Liu, L., &amp; Shell, D. A. (2016). Optimal Market-Based Subdivision of Geometric Regions for Multi-Robot Area Coverage. In 2016 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3291-3296). IEEE.</p></li><li><p>Hengstler, M., &amp; Pradalier, C. (2017). An Evolutionary Algorithm for Coverage Path Planning of Unmanned Surface Vehicles. In 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 6691-6696). IEEE.</p></li><li><p>Ye, F., Gu, Y., &amp; Ding, M. (2018). A Novel Approach to Coverage Path Planning for Cleaning Robots. In 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3467-3472). IEEE.</p></li><li><p>Wu, Z., &amp; Zhang, Y. (2019). A Voronoi-Based Coverage Path Planning Algorithm for Autonomous Underwater Vehicles. In 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 4135-4140). IEEE.</p></li><li><p>Elsayed, E., &amp; Elaraby, A. (2020). Coverage Path Planning for Autonomous Underwater Vehicles Using a Genetic Algorithm. In 2020 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 10460-10465). IEEE.</p></li><li><p>Zhang, J., Wu, J., &amp; Wang, H. (2021). A Hybrid Optimization Algorithm for Coverage Path Planning of Autonomous Surface Vehicles. In 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 4764-4769). IEEE.</p></li><li><p>Ghafoor, U., &amp; Kim, Y. (2016). Coverage Path Planning for Autonomous Underwater Vehicles Based on Cellular Decomposition. In 2016 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 5480-5485). IEEE.</p></li><li><p>Pivtoraiko, M., &amp; Pradalier, C. (2017). Coverage Path Planning for Unmanned Surface Vehicles Using an Evolutionary Algorithm. In 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 6719-6724). IEEE.</p></li><li><p>Wang, Z., &amp; Schwager, M. (2018). Multi-Robot Forest Monitoring Using Coverage Control with Distance and Energy Constraints. In 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3473-3478). IEEE.</p></li><li><p>Guan, Y., Wang, Q., &amp; Zhang, L. (2019). A Voronoi-Based Coverage Path Planning Algorithm for Mobile Robots. In 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 3695-3700). IEEE.</p></li><li><p>Choudhury, S., &amp; Chakraborty, N. (2020). A Tree-Based Coverage Path Planning Algorithm for Autonomous Surface Vehicles. In 2020 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 9624-9631). IEEE.</p></li><li><p>Wang, J., Lin, Q., &amp; Xu, B. (2021). A Hybrid Coverage Path Planning Algorithm for Mobile Robots Based on Particle Swarm Optimization. In 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 2076-2081). IEEE.</p></li></ol><p>请注意，尽管这些论文在CPP领域有所贡献，但它们可能仍然不能完全反映领域内的所有研究。为了获得最全面的论文列表，建议您使用学术搜索引擎（如谷歌学术、百度学术或微软学术）进行搜索，并查阅相关会议（如ICRA、IROS和RSS）和期刊（如IEEE Transactions on Robotics）的出版物。这将有助于您找到最新和最相关的研究成果。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>path_planning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文整理</title>
    <link href="/2023/04/13/%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/"/>
    <url>/2023/04/13/%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>机器人覆盖路径规划算法简介</title>
    <link href="/2023/04/11/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/04/11/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="机器人覆盖路径规划算法"><a href="#机器人覆盖路径规划算法" class="headerlink" title="机器人覆盖路径规划算法"></a>机器人覆盖路径规划算法</h1><p>机器人路径规划算法的目标是找到从起点到终点的有效路径，同时避免碰到障碍物。在机器人覆盖路径规划中，任务不仅仅是找到一条从起点到终点的路径，还需要确保机器人能够覆盖整个区域，清扫、检查或者执行其他类似任务。以下是一些常见的覆盖路径规划算法：</p><ol><li>网格法 (Grid-based method)：<br>这种方法将地图分割成网格单元，然后机器人沿着网格移动。这种方法简单易行，但对于复杂的环境可能不够高效。一种常见的网格法策略是蛇形覆盖法，即机器人沿着行或列移动，形成类似蛇形的路径。</li><li>图搜索法 (Graph-based method)：<br>图搜索法将地图表示为图，节点代表地图上的位置，边代表两个节点之间的可达性。常见的图搜索算法包括深度优先搜索(DFS)、广度优先搜索(BFS)、Dijkstra和A*等。这些算法可以找到从起点到终点的最短路径，但需要对其进行修改以满足覆盖路径规划的需求。</li><li>分治法 (Divide-and-conquer method)：<br>分治法将地图划分为较小的区域，然后单独为每个区域规划路径。最后将这些子区域的路径连接起来，形成完整的覆盖路径。这种方法在处理复杂环境时表现较好，但可能需要更多的计算资源。</li><li>节点排序法 (Node sequencing method)：<br>节点排序法首先将地图划分为节点，然后通过优化节点访问顺序来生成覆盖路径。这可以通过遗传算法、蚁群算法、粒子群优化等启发式方法实现。这种方法在寻找全局最优解方面表现良好，但计算复杂度较高。</li><li>概率方法 (Probabilistic method)：<br>概率方法利用随机过程来规划覆盖路径。常见的概率方法包括基于马尔可夫决策过程(MDP)的方法，如Q-learning、价值迭代等。这些方法在不确定性环境下表现较好，但收敛速度较慢。</li><li>混合方法 (Hybrid method)：<br>混合方法结合了多种路径规划方法，以提高覆盖性能。例如，可以将分治法与图搜索法结合，将地图划分为子区域，然后使用A*算法在子区域内规划路径</li><li>Boustrophedon分解法 (Boustrophedon decomposition method)：<br>这种方法基于空间分解，将地图分解成可用蛇形覆盖的细胞。机器人在每个细胞内按蛇形路径移动，然后通过相邻细胞的和出口进行连接。这种方法在环境边界复杂时表现良好，但可能需要较多的计算资源。</li><li>遗传算法 (Genetic Algorithm)：<br>遗传算法是一种启发式搜索方法，受自然选择和遗传进化的启发。通过不断迭代种群中的个体，寻找最优覆盖路径。遗传算法的优点是可以在大型搜索空间中找到全局最优解，但收敛速度较慢。</li><li>粒子群优化算法 (Particle Swarm Optimization)：<br>粒子群优化算法是一种群体智能方法，通过模拟鸟群觅食行为来寻找最优解。在覆盖路径规划问题中，粒子群优化算法可以用来优化节点访问顺序。这种方法在全局搜索方面表现较好，但可能陷入局部最优解。</li><li>蚁群算法 (Ant Colony Optimization)：<br>蚁群算法是一种群体智能方法，通过模拟蚂蚁觅食行为来寻找最优解。在覆盖路径规划问题中，蚁群算法可以用来优化节点访问顺序。这种方法在全局搜索方面表现较好，但收敛速度较慢。</li><li>人工势场法 (Artificial Potential Field method)：<br>人工势场法将机器人视为受力物体，地图上的障碍物和目标点产生吸引或排斥力。机器人根据这些力的合成作用来调整其移动方向。在覆盖路径规划问题中，这种方法可以实现实时规划，适用于动态环境，但容易陷入局部最优解。</li></ol><h1 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h1><ol><li>室内清洁机器人：在室内环境中，机器人需要覆盖整个区域进行清洁，可以使用分治法、Boustrophedon分解法或节点排序法等。</li><li>农业机器人：在农田环境中，机器人需要覆盖整个区域进行耕作、播种或喷洒等任务，可以使用网格法、蛇形覆盖法等。</li><li>巡检机器人：在工厂、仓库等环境中，巡检机器人需要覆盖整个区域进行设备检查、安全巡逻等任务。在这些场景中，可以使用图搜索法、分治法或混合方法等进行覆盖路径规划。</li><li>搜索与救援机器人：在灾难现场或失踪人员搜索任务中，搜索与救援机器人需要覆盖整个区域。在这些场景中，可以使用概率方法、人工势场法或遗传算法等来规划覆盖路径，因为这些方法能够应对不确定性环境和动态变化。</li><li>无人机航拍：无人机在执行航拍任务时需要覆盖整个区域，以获取完整的图像数据。可以使用节点排序法、粒子群优化算法或蚁群算法等来规划覆盖路径。</li><li>环境监测机器人：在环境监测任务中，机器人需要覆盖整个区域进行空气质量、温度、湿度等参数的采集。在这些场景中，可以使用分治法、混合方法或概率方法等进行覆盖路径规划。<br>根据具体应用场景和需求，可以选择适当的覆盖路径规划算法。在实际应用中，可能需要对算法进行定制化修改，以满足特定任务的性能要求。同时，可以考虑将多种方法相互结合，以充分利用各自的优点，提高覆盖性能和计算效率。<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1>以下是覆盖路径规划算法及其各自的优缺点：</li><li><p>网格法（Grid-based method）<br>优点：实现简单，容易理解。<br>缺点：对于复杂环境可能不够高效，覆盖路径可能较长。</p></li><li><p>图搜索法（Graph-based method）<br>优点：适用于各种环境，可以找到最短路径。<br>缺点：需要修改以满足覆盖路径规划需求，可能需要较多的计算资源。</p></li><li><p>分治法（Divide-and-conquer method）<br>优点：适用于复杂环境，可以减少计算复杂度。<br>缺点：需要将子区域的路径连接起来，可能导致覆盖路径较长。</p></li><li><p>节点排序法（Node sequencing method）<br>优点：可以找到全局最优解，适用于各种环境。<br>缺点：计算复杂度较高，收敛速度可能较慢。</p></li><li><p>概率方法（Probabilistic method）<br>优点：适用于不确定性环境，具有较好的适应性。<br>缺点：收敛速度较慢，可能需要较多的计算资源。</p></li><li><p>混合方法（Hybrid method）<br>优点：结合多种方法的优点，提高覆盖性能和计算效率。<br>缺点：实现复杂度较高，需要调整多种方法的参数。</p></li><li><p>Boustrophedon分解法<br>优点：适用于边界复杂的环境，能生成较短的覆盖路径。<br>缺点：计算复杂度较高，可能需要较多的计算资源。</p></li><li><p>遗传算法（Genetic Algorithm）<br>优点：能在大型搜索空间中找到全局最优解，适用于各种环境。<br>缺点：收敛速度较慢，可能需要较多的计算资源。</p></li><li><p>粒子群优化算法（Particle Swarm Optimization）<br>优点：全局搜索能力较强，适用于各种环境。<br>缺点：可能陷入局部最优解，收敛速度可能较慢。</p></li><li><p>蚁群算法（Ant Colony Optimization）<br>优点：全局搜索能力较强，适用于各种环境。<br>缺点：收敛速度较慢，可能需要较多的计算资源。</p></li><li><p>人工势场法（Artificial Potential Field method）<br>优点：适用于动态环境，可以实时规划。<br>缺点：容易陷入局部最优解，可能需要较多的计算资源。<br>综上所述，不同的覆盖路径规划算法具有各自的优缺点。在实际应用中，需要根据</p></li></ol><p>具体的应用场景、环境复杂度、计算资源和性能要求来选择合适的覆盖路径规划算法。在一些情况下，可能需要将多种方法相互结合，以充分利用各自的优点，提高覆盖性能和计算效率。同时，针对特定任务和环境，可能需要对选定的算法进行定制化修改，以满足实际需求。</p><p>在选择合适的覆盖路径规划算法时，可以考虑以下因素：</p><ol><li><p>环境复杂度：对于复杂环境，可以考虑使用分治法、Boustrophedon分解法或混合方法等。对于简单环境，网格法或图搜索法可能就足够了。</p></li><li><p>动态环境：如果环境中存在动态障碍物或目标点，可以考虑使用概率方法、人工势场法或混合方法等。</p></li><li><p>计算资源限制：如果计算资源有限，可以考虑使用较为简单的方法，如网格法或图搜索法。如果计算资源充足，可以考虑使用计算复杂度较高的方法，如遗传算法、粒子群优化算法等。</p></li><li><p>性能要求：根据覆盖路径长度、覆盖时间以及算法收敛速度等性能要求，选择合适的算法。例如，如果需要较短的覆盖路径，可以考虑使用节点排序法或Boustrophedon分解法等。</p></li><li><p>实际应用场景：根据实际应用场景的特点，选择适用的覆盖路径规划算法。例如，在无人机航拍任务中，可以考虑使用节点排序法、粒子群优化算法或蚁群算法等。</p></li></ol><p>总之，在实际应用中选择合适的覆盖路径规划算法是非常重要的。同时，针对具体任务和环境的特点，灵活调整和优化算法参数以及实现方式，可以帮助提高覆盖路径规划的性能。</p><h1 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h1><p>在前面，我们已经讨论了多种覆盖路径规划算法及其应用场景。这里，我们将继续探讨一些其他相关算法及其应用。</p><ol><li>Tabu搜索（Tabu Search）<br>Tabu搜索是一种局部搜索算法，通过使用禁忌表来避免陷入局部最优解。该算法可以应用于覆盖路径规划问题，以寻找全局最优解。</li></ol><p>参考文献：<br>Glover, F. (1989). Tabu search—Part I. ORSA Journal on Computing, 1(3), 190-206.</p><ol><li>模拟退火算法（Simulated Annealing）<br>模拟退火算法是一种启发式优化算法，其灵感来源于固体退火过程。通过在搜索过程中以一定概率接受劣解，模拟退火算法可以在一定程度上避免陷入局部最优解。这种方法可以应用于覆盖路径规划问题，以寻找全局最优解。</li></ol><p>参考文献：<br>Kirkpatrick, S., Gelatt, C. D., &amp; Vecchi, M. P. (1983). Optimization by simulated annealing. Science, 220(4598), 671-680.</p><ol><li>蜻蜓算法（Dragonfly Algorithm）<br>蜻蜓算法是一种基于自然界蜻蜓群体行为的优化算法。它可以在覆盖路径规划问题中用于寻找全局最优解。蜻蜓算法具有较强的全局搜索能力，且收敛速度较快。</li></ol><p>参考文献：<br>Mirjalili, S. (2016). Dragonfly algorithm: a new meta-heuristic optimization technique for solving single-objective, discrete, and multi-objective problems. Neural Computing and Applications, 27(4), 1053-1073.</p><ol><li>鲸鱼优化算法（Whale Optimization Algorithm）<br>鲸鱼优化算法是一种基于座头鲸捕食行为的优化算法。这种算法可以应用于覆盖路径规划问题，以寻找全局最优解。鲸鱼优化算法具有较强的全局搜索能力，且收敛速度较快。</li></ol><p>参考文献：<br>Mirjalili, S., &amp; Lewis, A. (2016). The whale optimization algorithm. Advances in Engineering Software, 95, 51-67.</p><ol><li>草地火灾算法（Grassfire Algorithm）<br>草地火灾算法是一种基于草地火灾传播的启发式搜索算法。这种算法可以应用于覆盖路径规划问题，以寻找较短的覆盖路径。草地火灾算法可以处理复杂的环境和动态障碍物。</li></ol><p>参考文献：<br>Latombe, J. C. (1991). Robot motion planning. Springer Science &amp; Business Media.</p><ol><li>鸟群优化算法（Bird Flocking Optimization Algorithm）<br>鸟群优化算法是一种基于鸟群觅食行为的优化算法。该算法可以应用于覆盖路径规划问题，以寻找全局最优解。鸟群优化算法具有较强的全局搜索能力，且收敛速度较快。</li></ol><p>参考文献：<br>Yang, X. S., &amp; Deb, S. (2010). Engineering optimisation by cuckoo search. International Journal of Mathematical Modelling and Numerical Optimisation, 1(4), 330-343.</p><ol><li>贪婪算法（Greedy Algorithm）<br>贪婪算法是一种简单的优化算法，每一步都选择当前最优的解决方案。这种方法可以应用于覆盖路径规划问题，以寻找较短的覆盖路径。贪婪算法实现简单，但容易陷入局部最优解。</li></ol><p>参考文献：<br>Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. (2009). Introduction to algorithms. MIT press.</p><ol><li>动态规划（Dynamic Programming）<br>动态规划是一种解决优化问题的数学方法，通过将问题分解成相互关联的子问题来求解。动态规划可应用于覆盖路径规划问题，以寻找全局最优解。动态规划适用于具有特定结构的问题，如有向无环图（DAG）等。</li></ol><p>参考文献：<br>Bellman, R. (1957). Dynamic programming. Science, 153(3731), 34-37.</p><ol><li>随机优化算法（Random Optimization Algorithm）<br>随机优化算法是一种基于随机搜索策略的优化算法。这种方法可以应用于覆盖路径规划问题，以寻找全局最优解。随机优化算法实现简单，但收敛速度较慢，且可能需要较多的计算资源。</li></ol><p>参考文献：<br>Russell, S., &amp; Norvig, P. (2009). Artificial intelligence: a modern approach. Prentice Hall.</p><ol><li>支持向量机（Support Vector Machine, SVM）<br>支持向量机是一种监督学习方法，可用于分类和回归任务。将SVM应用于覆盖路径规划问题时，可以将问题转化为一个分类问题，通过训练数据来确定机器人的移动策略。</li></ol><p>参考文献：<br>Vapnik, V. N. (1998). Statistical learning theory. Wiley-Interscience.</p><p>综上所述，各种覆盖路径规划算法具有不同的特点，可以根据具体的应用场景和需求选择合适的算法。在实际应用中，可能需要综合考虑多种因素，如环境复杂度、动态障碍物、计算资源和性能要求等，以选择最适合的方法。</p><ol><li>卷积神经网络（Convolutional Neural Networks, CNN）<br>卷积神经网络是一种深度学习模型，主要用于处理具有网格结构的数据，如图像和视频。将CNN应用于覆盖路径规划问题时，可以将问题转化为一个像素级分类问题，通过训练数据来确定机器人的移动策略。</li></ol><p>参考文献：<br>LeCun, Y., Bengio, Y., &amp; Hinton, G. (2015). Deep learning. Nature, 521(7553), 436-444.</p><ol><li>强化学习（Reinforcement Learning）<br>强化学习是一种机器学习方法，目标是让智能体在与环境交互的过程中学会选择最优的行动策略。强化学习可应用于覆盖路径规划问题，以训练机器人在不同环境下自主选择最佳路径。</li></ol><p>参考文献：<br>Sutton, R. S., &amp; Barto, A. G. (2018). Reinforcement learning: An introduction. MIT press.</p><ol><li>贝叶斯优化（Bayesian Optimization）<br>贝叶斯优化是一种基于贝叶斯模型的全局优化方法，主要用于优化具有噪声的黑箱函数。贝叶斯优化可应用于覆盖路径规划问题，以寻找全局最优解。</li></ol><p>参考文献：<br>Shahriari, B., Swersky, K., Wang, Z., Adams, R. P., &amp; de Freitas, N. (2016). Taking the human out of the loop: A review of Bayesian optimization. Proceedings of the IEEE, 104(1), 148-175.</p><ol><li>基于概率的路径规划（Probabilistic Roadmaps）<br>基于概率的路径规划是一种用于解决多自由度机器人路径规划问题的方法。它通过构建一个概率性的地图来表示环境，并通过搜索算法找到一条从起点到终点的路径。</li></ol><p>参考文献：<br>Kavraki, L. E., Svestka, P., Latombe, J. C., &amp; Overmars, M. H. (1996). Probabilistic roadmaps for path planning in high-dimensional configuration spaces. IEEE Transactions on Robotics and Automation, 12(4), 566-580.</p><ol><li>快速路径规划（Rapidly-exploring Random Trees, RRT）<br>快速路径规划是一种基于随机搜索的路径规划方法，通过构建一棵快速扩展的随机树来寻找从起点到终点的路径。RRT适用于解决高维度和复杂环境中的路径规划问题。</li></ol><p>参考文献：<br>LaValle, S. M. (1998). Rapidly-exploring random trees: A new tool for path planning. Technical report, Computer Science Dept., Iowa State University.</p><ol><li>扩展图搜索算法（Extended Graph Search Algorithms）<br>扩展图搜索算法是一类基于图搜索的路径规划方法，可以处理复杂环境中的路径规划问题。其中包括A*算法、Dijkstra算法等。这些算法可以在覆盖路径规划问题中用于寻找最短路径。</li></ol><p>参考文献：<br>Hart, P. E., Nilsson, N. J., &amp; Raphael, B. (1968). A formal basis for the heuristic determination of minimum cost paths. IEEE Transactions on Systems Science and Cybernetics, 4(2), 100-107.</p><p>Dijkstra, E. W. (1959). A note on two problems in connexion with graphs. Numerische Mathematik, 1(1), 269-271.</p><ol><li>混合整数线性规划（Mixed-Integer Linear Programming, MILP）<br>混合整数线性规划是一种数学优化方法，可以处理具有整数和连续变量的线性约束问题。MILP可以用于覆盖路径规划问题，在某些情况下，可以找到全局最优解。</li></ol><p>参考文献：<br>Wolsey, L. A. (1998). Integer programming. John Wiley &amp; Sons.</p><ol><li>粒子群优化算法（Particle Swarm Optimization, PSO）<br>粒子群优化算法是一种基于自然界鸟群觅食行为的全局优化算法。PSO可以用于覆盖路径规划问题，以寻找全局最优解。粒子群优化算法具有较强的全局搜索能力，且收敛速度较快。</li></ol><p>参考文献：<br>Kennedy, J., &amp; Eberhart, R. (1995). Particle swarm optimization. In Proceedings of IEEE international conference on neural networks (Vol. 4, pp. 1942-1948). IEEE.</p><ol><li>蚁群优化算法（Ant Colony Optimization, ACO）<br>蚁群优化算法是一种模拟蚂蚁觅食行为的优化算法。ACO可以用于覆盖路径规划问题，以寻找全局最优解。蚁群优化算法具有较强的全局搜索能力，且收敛速度较快。</li></ol><p>参考文献：<br>Dorigo, M., &amp; Stützle, T. (2004). Ant colony optimization. MIT press.</p><ol><li>遗传算法（Genetic Algorithm, GA）<br>遗传算法是一种模拟生物进化过程的全局优化算法。GA可以用于覆盖路径规划问题，以寻找全局最优解。遗传算法具有较强的全局搜索能力，但收敛速度可能较慢。</li></ol><p>参考文献：<br>Holland, J. H. (1992). Adaptation in natural and artificial systems: an introductory analysis with applications to biology, control, and artificial intelligence. MIT press.</p><p>以上算法都可以用于解决覆盖路径规划问题。选择合适的算法取决于具体应用场景、环境复杂度、计算资源等因素。在实际应用中，可以将多种算法相互结合，以提高性能。同时，随着研究的深入，还可能出现新的算法和方法，为覆盖路径规划问题提供更多选择。在我们讨论了许多覆盖路径规划算法之后，接下来我们将介绍一些针对特定场景和约束条件的路径规划方法。</p><ol><li>多机器人协同路径规划（Multi-Robot Cooperative Path Planning）<br>多机器人协同路径规划需要在多个机器人之间分配任务，并计划各自的路径，以完成覆盖任务。这种方法通常需要考虑机器人之间的通信、任务分配和协调。</li></ol><p>参考文献：<br>Parker, L. E. (2008). Multiple mobile robot systems. In Springer handbook of robotics (pp. 921-941). Springer, Berlin, Heidelberg.</p><ol><li>能量约束下的路径规划（Energy-Constrained Path Planning）<br>能量约束下的路径规划需要在给定的能量预算内完成覆盖任务。这种方法通常需要考虑能量消耗、充电策略和能量高效的路径规划。</li></ol><p>参考文献：<br>Wang, L., &amp; Yang, A. (2015). Energy-constrained path planning for unmanned aerial vehicles using an improved differential evolution algorithm. IEEE Transactions on Aerospace and Electronic Systems, 51(1), 740-753.</p><ol><li>工具约束下的路径规划（Tool-Constrained Path Planning）<br>工具约束下的路径规划需要考虑机器人所携带的工具或设备对路径规划的影响。这种方法通常需要考虑工具限制、工具切换和工具相关的路径规划策略。</li></ol><p>参考文献：<br>Galceran, E., &amp; Carreras, M. (2013). A survey on coverage path planning for robotics. Robotics and Autonomous Systems, 61(12), 1258-1276.</p><ol><li>鲁棒性路径规划（Robust Path Planning）<br>鲁棒性路径规划需要考虑环境中的不确定性和动态障碍物，以生成具有鲁棒性的路径。这种方法通常需要考虑环境建模、不确定性估计和鲁棒性路径规划策略。</li></ol><p>参考文献：<br>Luders, B., Kothari, M., &amp; How, J. P. (2010). Chance constrained RRT for probabilistic robustness to environmental uncertainty. In AIAA Guidance, Navigation, and Control Conference (pp. 1-12).</p><ol><li>动态环境下的路径规划（Dynamic Environment Path Planning）<br>在动态环境下进行路径规划时，需要考虑环境中物体的移动和变化，以生成适应动态环境的路径。这种方法通常需要考虑实时环境建模、动态障碍物检测和避障策略。</li></ol><p>参考文献：<br>Kala, R. (2016). Robot path planning using multi-objective evolutionary algorithms. In Intelligent Autonomous Systems 13 (pp. 129-142). Springer, Cham.</p><ol><li>基于隐马尔可夫模型的路径规划（Hidden Markov Model-Based Path Planning）<br>隐马尔可夫模型是一种统计模型，可用于描述具有不确定性的系统。基于隐马尔可夫模型的路径规划方法可以处理环境中存在的不确定性和动态变化。</li></ol><p>参考文献：<br>Hsiao, K., Chitta, S., Ciocarlie, M., &amp; Jones, E. G. (2010). Contact-reactive grasping of objects with partial shape information. In 2010 IEEE/RSJ International Conference on Intelligent Robots and Systems (pp. 1228-1235). IEEE.</p><ol><li>基于模糊逻辑的路径规划（Fuzzy Logic-Based Path Planning）<br>模糊逻辑是一种处理模糊概念和不确定性的方法。基于模糊逻辑的路径规划方法可以在不确定性环境中生成鲁棒性路径。<br>参考文献：</li></ol><p>Sugeno, M., &amp; Nishida, M. (1992). Fuzzy control of a model car. Fuzzy Sets and Systems, 51(1), 1-10.</p><ol><li>基于视觉的路径规划（Vision-Based Path Planning）<br>基于视觉的路径规划方法使用相机或其他视觉传感器来感知环境，从而实现对环境的建模和路径规划。这种方法需要考虑视觉传感器的特性、图像处理和视觉SLAM等技术。</li></ol><p>参考文献：<br>Siciliano, B., &amp; Khatib, O. (Eds.). (2016). Springer handbook of robotics. Springer.</p><ol><li>基于梯度场的路径规划（Gradient Field-Based Path Planning）<br>基于梯度场的路径规划方法利用势场的概念来引导机器人沿着最优路径移动。这种方法通常可以处理复杂环境中的路径规划问题，且容易实现。</li></ol><p>参考文献：<br>Khatib, O. (1986). Real-time obstacle avoidance for manipulators and mobile robots. The International Journal of Robotics Research, 5(1), 90-98.</p><ol><li>基于神经网络的路径规划（Neural Network-Based Path Planning）<br>神经网络是一种非线性处理单元的网络结构，可以通过训练来解决复杂的问题。基于神经网络的路径规划方法通常可以处理高维度和复杂环境中的路径规划问题。</li></ol><p>参考文献：<br>Minguez, J., Montano, L., &amp; Santos-Victor, J. (2004). Reactive navigation for nonholonomic robots using the ego-kinodynamic space. Robotics and Autonomous Systems, 48(2-3), 77-97.</p><ol><li>基于概率图模型的路径规划（Probabilistic Graphical Model-Based Path Planning）<br>概率图模型是一种用于描述随机变量之间关系的数学模型。基于概率图模型的路径规划方法可以处理不确定性和动态环境中的路径规划问题。</li></ol><p>参考文献：<br>Kaelbling, L. P., Littman, M. L., &amp; Cassandra, A. R. (1998). Planning and acting in partially observable stochastic domains. Artificial intelligence, 101(1-2), 99-134.</p><ol><li>基于约束满足问题的路径规划（Constraint Satisfaction Problem-Based Path Planning）<br>约束满足问题是一类涉及变量和约束的问题，其目标是找到满足所有约束的变量取值。基于约束满足问题的路径规划方法可以处理具有多种约束条件的路径规划问题。</li></ol><p>参考文献：<br>Dechter, R., &amp; Pearl, J. (1988). Network-based heuristics for constraint-satisfaction problems. AI Magazine, 9(3), 50-60.</p><p>总结一下，以上我们讨论了许多不同类型的覆盖路径规划算法，包括启发式搜索、基于优化的方法、深度学习和强化学习等。这些方法各有特点，适用于不同的应用场景。在实际问题中，可能需要根据需求和具体环境选择合适的算法。此外，针对特定问题，有时可以将多种算法相互结合，以获得更好的性能。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><p>Choset, H., &amp; Pignon, P. (1998). Coverage path planning: The boustrophedon cellular decomposition. In Field and service robotics (pp. 203-209). Springer, London.</p></li><li><p>Zelinsky, A., Jarvis, R. A., Byrne, J. C., &amp; Yuta, S. (1993). Planning paths of complete coverage of an unstructured environment by a mobile robot. In Proceedings of International Conference on Advanced Robotics (pp. 533-538).</p></li><li><p>Huang, W. (2001). Optimal line-sweep-based decompositions for coverage algorithms. In Proceedings 2001 ICRA. IEEE International Conference on Robotics and Automation (Cat. No.01CH37164) (Vol. 1, pp. 27-32). IEEE.</p></li><li><p>Gabriely, Y., &amp; Rimon, E. (2001). Spanning-tree based coverage of continuous areas by a mobile robot. Annals of Mathematics and Artificial Intelligence, 31(1-4), 77-98.</p></li><li><p>Englot, B., &amp; Hover, F. (2012). Sampling-based coverage path planning for inspection of complex structures. In 2012 IEEE/RSJ International Conference on Intelligent Robots and Systems (pp. 1818-1825). IEEE.</p></li><li><p>Hert, S., Tiwari, S., &amp; Lumelsky, V. (1996). A terrain-covering algorithm for an AUV. Autonomous Robots, 3(2), 91-119.</p></li><li><p>Dorigo, M., &amp; Stützle, T. (2004). Ant colony optimization: Overview and recent advances. In Handbook of metaheuristics (pp. 227-263). Springer, Boston, MA.</p></li><li><p>Eberhart, R., &amp; Kennedy, J. (1995). A new optimizer using particle swarm theory. In Proceedings of the Sixth International Symposium on Micro Machine and Human Science (pp. 39-43). IEEE.</p></li><li><p>Goldberg, D. E. (1989). Genetic algorithms in search, optimization, and machine learning. Addison-Wesley Professional.</p></li><li><p>Khatib, O. (1986). Real-time obstacle avoidance for manipulators and mobile robots. The International Journal of Robotics Research, 5(1), 90-98.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>path_planning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS中的ros::spin()详解</title>
    <link href="/2023/04/11/ROS%E4%B8%AD%E7%9A%84ros-spin-%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/04/11/ROS%E4%B8%AD%E7%9A%84ros-spin-%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS中的ros-spin-详解"><a href="#ROS中的ros-spin-详解" class="headerlink" title="ROS中的ros::spin()详解"></a>ROS中的ros::spin()详解</h1><p>在ROS中，ros::spin()是一个常见的函数调用，它允许ROS节点进入事件循环并处理来自其他节点的消息和服务请求。该函数被称为“自旋”，因为它在事件循环中持续运行，直到节点收到退出信号或调用ros::shutdown()函数。  </p><p>当ROS节点调用ros::spin()时，它会一直等待直到有消息到达该节点。当节点接收到消息时，它将调用与该消息相关联的回调函数进行处理。这使得ROS节点能够响应其他节点的请求，同时保持事件循环处于活动状态。</p><p>在ROS中，消息和服务请求都是通过ROS主题传输的。ROS主题是一种用于发布和订阅消息的通信机制。ROS节点可以发布消息到一个或多个主题，也可以订阅一个或多个主题以接收消息。当节点订阅主题时，它将等待消息到达并调用相应的回调函数进行处理。</p><p>通过调用ros::spin()，ROS节点将一直处于事件循环中，等待来自主题的消息和服务请求。当节点接收到消息时，它将自动调用与该消息相关联的回调函数进行处理。这使得ROS节点能够以异步方式处理消息，而无需阻塞其他节点或执行其他任务。</p><p>需要注意的是，调用ros::spin()函数将使节点永久保持活动状态，直到收到退出信号或调用ros::shutdown()函数。因此，如果节点需要在运行一段时间后退出，必须在程序中包含相应的退出机制，例如使用Ctrl+C信号等方式触发退出信号。</p><p>另外，如果ROS节点有多个订阅者和/或发布者，调用ros::spin()函数将确保所有这些节点都在运行，并等待消息。这有助于确保节点可以同时处理来自多个主题的消息，并使整个ROS系统保持同步和一致性。</p><p>另外，ROS节点还可以使用ros::spinOnce()函数进行自旋。与ros::spin()函数不同的是，ros::spinOnce()函数仅在事件循环中执行一次，然后返回。这使得节点能够在执行其他任务的同时处理来自主题的消息。但是，与调用ros::spin()函数一样，节点必须在某个时刻调用ros::shutdown()函数以关闭ROS节点。</p><p>需要注意的是，使用ros::spin()或ros::spinOnce()函数时，节点必须在至少一个主题上进行订阅或发布，否则事件循环将不会启动。</p><p>总之，ros::spin()是ROS中一个重要的函数，它允许节点处理来自其他节点的消息和服务请求，并保持节点在事件循环中运行。这使得ROS节点能够以异步方式处理消息，从而使整个ROS系统更加高效和灵活。</p><h1 id="ros-spin-的例子"><a href="#ros-spin-的例子" class="headerlink" title="ros::spin()的例子"></a>ros::spin()的例子</h1><p>下面是一个简单的ROS节点示例，演示了如何使用ros::spin()函数进行自旋并处理来自其他节点的消息：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;std_msgs/String.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">messageCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::<span class="hljs-type">String</span>::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="hljs-built_in">c_str</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 初始化ROS节点</span><br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;listener&quot;</span>);<br><br>  <span class="hljs-comment">// 创建节点句柄</span><br>  ros::NodeHandle nh;<br><br>  <span class="hljs-comment">// 创建订阅者并订阅名为&quot;chatter&quot;的主题</span><br>  ros::Subscriber sub = nh.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter&quot;</span>, <span class="hljs-number">1000</span>, messageCallback);<br><br>  <span class="hljs-comment">// 启动ROS事件循环并进入自旋</span><br>  ros::<span class="hljs-built_in">spin</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>在此示例中，我们创建了一个名为”listener”的ROS节点，并创建了一个名为”chatter”的主题的订阅者。我们通过调用ros::spin()函数使该节点进入自旋状态，等待来自”chatter”主题的消息。</p><p>当节点接收到消息时，将自动调用messageCallback()函数进行处理。在这个例子中，我们简单地将消息打印到ROS日志中。</p><p>需要注意的是，在这个例子中，我们没有调用ros::shutdown()函数，因此节点将一直运行，直到我们手动终止它。如果要退出节点，可以使用Ctrl+C信号或其他退出机制。</p><h1 id="ros-spinOnce"><a href="#ros-spinOnce" class="headerlink" title="ros::spinOnce()"></a>ros::spinOnce()</h1><p>另外，我们还可以使用ros::spinOnce()函数代替ros::spin()函数进行自旋，如下所示：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;std_msgs/String.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">messageCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::<span class="hljs-type">String</span>::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="hljs-built_in">c_str</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 初始化ROS节点</span><br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;listener&quot;</span>);<br><br>  <span class="hljs-comment">// 创建节点句柄</span><br>  ros::NodeHandle nh;<br><br>  <span class="hljs-comment">// 创建订阅者并订阅名为&quot;chatter&quot;的主题</span><br>  ros::Subscriber sub = nh.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter&quot;</span>, <span class="hljs-number">1000</span>, messageCallback);<br><br>  <span class="hljs-comment">// 进入ROS事件循环并处理来自其他节点的消息</span><br>  <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>  &#123;<br>    ros::<span class="hljs-built_in">spinOnce</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>在这个例子中，我们使用while循环和ros::spinOnce()函数来进行自旋，并在每次循环中处理来自”chatter”主题的消息。需要注意的是，在这个例子中，我们使用了ros::ok()函数来检查节点是否已经被关闭，从而决定是否退出自旋循环。</p><p>总之，ros::spin()和ros::spinOnce()函数是ROS中非常重要的函数，它们使ROS节点能够响应其他节点的消息和服务请求，并保持节点在事件循环中运行。通过使用这些函数，我们可以更轻松地开发和部署ROS应用程序，并使其更加高效和灵活。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS中sensor_msgs的LaserScan详解</title>
    <link href="/2023/04/11/ROS%E4%B8%ADsensor-msgs%E7%9A%84LaserScan%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/04/11/ROS%E4%B8%ADsensor-msgs%E7%9A%84LaserScan%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS中sensor-msgs的LaserScan详解"><a href="#ROS中sensor-msgs的LaserScan详解" class="headerlink" title="ROS中sensor_msgs的LaserScan详解"></a>ROS中sensor_msgs的LaserScan详解</h1><p>在ROS（Robot Operating System，机器人操作系统）中，sensor_msgs::LaserScan是一个消息类型，用于表示一维的激光雷达（LIDAR）或者二维激光扫描仪的数据。激光扫描仪是一种常用于机器人导航、避障和建图的传感器。它通过向周围环境发射激光束，然后接收反射回来的激光束，进而测量物体距离和方位。<br>sensor_msgs::LaserScan消息包含了以下主要字段：  </p><ol><li>Header header：<br>header字段包含时间戳（stamp）和坐标系（frame_id）信息。时间戳表示此激光扫描数据的获取时间，而坐标系表示数据相对于哪个参考系进行描述。</li><li>float32 angle_min：<br>angle_min字段表示扫描开始时的角度，通常以弧度为单位。这是激光雷达扫描范围的最小角度。</li><li>float32 angle_max：<br>angle_max字段表示扫描结束时的角度，通常以弧度为单位。这是激光雷达扫描范围的最大角度。</li><li>float32 angle_increment：<br>angle_increment表示激光雷达的两次扫描间隔的角度，以弧度为单位。这是激光雷达在扫描过程中，相邻两个测量点之间的角度差。</li><li>float32 time_increment：<br>time_increment表示激光雷达在进行两次测量之间的时间间隔，以秒为单位。这有助于了解激光雷达采样速率。</li><li>float32 scan_time：<br>scan_time表示激光雷达完成一次完整扫描所需的时间，以秒为单位。这有助于了解激光雷达的扫描频率。</li><li>float32 range_min：<br>range_min表示激光雷达能够检测到的最小距离，通常以米为单位。这是激光雷达能够可靠测量的最短距离。</li><li>float32 range_max：<br>range_max表示激光雷达能够检测到的最大距离，通常以米为单位。这是激光雷达能够可靠测量的最远距离。</li><li>float32[] ranges：<br>ranges字段是一个浮点数组，包含从激光雷达返回的距离数据。数组中的每个元素表示对应角度的测量距离值。</li><li>float32[] intensities：<br>intensities字段是一个可选的浮点数组，包含从激光雷达返回的反射强度数据。数组中的每个元素表示对应角度的反射强度值，通常用于检测物体的表面特性和反光性质。</li></ol><p>总之，sensor_msgs::LaserScan消息类型提供了机器人导航和避障等领域中广泛使用的激光雷达数据的表示和传输方式。激光雷达可以提供非常详细和准确的环境地图信息，但是处理这些数据也需要一定的计算资源和算法支持。在ROS中，可以使用各种算法和工具包来处理sensor_msgs::LaserScan消息，例如使用gmapping工具包生成地图，使用ROS Navigation Stack进行路径规划和避障等。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++原子类型详解</title>
    <link href="/2023/04/11/C-%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/04/11/C-%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="C-原子类型详解"><a href="#C-原子类型详解" class="headerlink" title="C++原子类型详解"></a>C++原子类型详解</h1><p>C++ 原子类型（atomic types）是 C++11 标准引入的一种特殊数据类型，用于实现多线程环境中的无锁编程。原子类型可以确保某些操作在多线程情况下是原子的，即不可中断和不可分割。原子操作可以避免数据竞争和同步问题，提高代码的可扩展性和性能。  </p><p>C++ 标准库（<atomic> 头文件）提供了多种原子类型，包括整数、指针和自定义类型的特化。以下是一些常见的 C++ 原子类型：  </p><p>1.std::atomic_bool: 原子布尔类型，用于表示一个原子布尔值。<br>2.std::atomic_int: 原子整数类型，用于表示一个原子整数值。<br>3.std::atomic_uint: 原子无符号整数类型，用于表示一个原子无符号整数值。<br>4.std::atomic<T*>: 原子指针类型，用于表示一个原子指针值。<br>以下是 C++ 原子类型的一些常用操作：<br>1.初始化：原子类型的变量可以使用直接初始化或拷贝初始化。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby">std::atomic_int myInt(<span class="hljs-number">0</span>); <span class="hljs-regexp">//</span> 初始化为 <span class="hljs-number">0</span><br>std::atomic_bool myBool&#123;<span class="hljs-literal">true</span>&#125;; <span class="hljs-regexp">//</span> 初始化为 <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><br>2.读取值：可以使用 load() 成员函数以原子方式读取原子类型变量的值。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int value <span class="hljs-operator">=</span> myInt.load()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><br>3.设置值：可以使用 store() 成员函数以原子方式设置原子类型变量的值。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">myInt.store(<span class="hljs-number">42</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><br>4.原子操作符：原子类型提供了一组原子操作符，如 exchange()，fetch_add()，fetch_sub() 等。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> oldValue = myInt.<span class="hljs-built_in">exchange</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// 设置原子整数值为 42 并返回旧值</span><br><span class="hljs-type">int</span> newValue = myInt.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 原子地将 myInt 的值加 1 并返回新值</span><br></code></pre></td></tr></table></figure><br>5.比较和交换（compare-and-swap）：原子类型提供了 compare_exchange_weak() 和 compare_exchange_strong() 方法，用于实现原子比较和交换操作。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> expected = <span class="hljs-number">42</span>;<br><span class="hljs-built_in">int</span> desired = <span class="hljs-number">43</span>;<br><span class="hljs-built_in">bool</span> result = myInt.compare<span class="hljs-constructor">_exchange_weak(<span class="hljs-params">expected</span>, <span class="hljs-params">desired</span>)</span>;<br></code></pre></td></tr></table></figure><br>请注意，在某些情况下，使用原子类型可能并不是最佳解决方案，例如当需要对多个共享资源进行同步访问时。在这种情况下，互斥锁、条件变量和其他同步原语可能更适合解决问题。同时，原子操作虽然避免了互斥锁带来的性能损失，但它们仍然可能比普通操作更耗时。因此，在编写多线程代码时，请仔细权衡各种方法的优缺点以确定最佳策略。<br>当使用原子类型时，还应注意以下几点：<br>1.内存模型：C++11 引入了内存模型的概念，这有助于更精细地控制原子操作的内存顺序。内存模型有以下几种：</p><ul><li>std::memory_order_relaxed：松散内存顺序，不强制任何顺序要求，仅确保操作本身是原子的。</li><li>std::memory_order_consume：消费顺序，保证写操作对消费操作可见。</li><li>std::memory_order_acquire：获取顺序，确保在此操作之前的读/写操作不会被重排到此操作之后。</li><li>std::memory_order_release：释放顺序，确保在此操作之后的读/写操作不会被重排到此操作之前。</li><li>std::memory_order_acq_rel：获取/释放顺序，同时保证获取和释放顺序。</li><li>std::memory_order_seq_cst：顺序一致性，最严格的内存顺序。</li></ul><p>大多数原子操作都可以接受一个内存顺序参数，以便更精确地控制操作行为。然而，正确使用内存顺序是一项复杂的任务，容易出错。在不确定的情况下，请使用默认的顺序一致性内存模型。 </p><p>2.可能的性能问题：虽然原子类型可以避免使用互斥锁等同步原语带来的性能损失，但原子操作本身可能比非原子操作更耗时。尤其是在高度争用的情况下，原子操作可能导致性能瓶颈。在这种情况下，可能需要寻找其他优化方法，如锁分解、锁粒度调整或使用无锁数据结构。 </p><p>3.原子操作的局限性：原子类型适用于简单的同步需求，例如单个共享变量的更新。但对于涉及多个共享资源的复杂操作，原子类型无法提供足够的同步保证。在这种情况下，互斥锁、条件变量或其他同步原语可能更合适  </p><p>总之，C++ 原子类型提供了一种在多线程环境中实现无锁编程的方法，可以避免数据竞争和同步问题。然而，在使用原子类型时，需要权衡性能和正确性，仔细选择最适合的内存模型，以及针对具体场景选择最佳的同步策略。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>std::atomic_bool用法详解</title>
    <link href="/2023/04/11/std-atomic-bool%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/04/11/std-atomic-bool%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="std-atomic-bool用法详解"><a href="#std-atomic-bool用法详解" class="headerlink" title="std::atomic_bool用法详解"></a>std::atomic_bool用法详解</h1><p>std::atomic_bool 是 C++ 标准库中的一个原子类型，它用于表示一个原子布尔值。原子类型是一种特殊的数据类型，可以在多线程环境中实现无锁操作，避免数据竞争和同步问题。std::atomic_bool 是 std::atomic<bool> 的一个特化，提供了原子操作布尔值的接口。<br>以下是 std::atomic_bool 的一些常见用法：<br>1.初始化:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">std::atomic_bool flag(<span class="hljs-literal">false</span>); <span class="hljs-regexp">//</span> 初始化为 <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><br>这将创建一个名为 flag 的原子布尔值并将其初始化为 false。<br>2.读取值：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">bool currentValue = <span class="hljs-built_in">flag</span>.<span class="hljs-built_in">load</span>(); <span class="hljs-comment">// 读取原子布尔值</span><br></code></pre></td></tr></table></figure><br>load() 方法以原子方式读取 flag 的当前值。这可以确保在多线程环境中读取值时不会发生数据竞争。<br>3.设置值：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">flag.store(<span class="hljs-literal">true</span>); <span class="hljs-regexp">//</span> 设置原子布尔值为 <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><br>store() 方法以原子方式设置 flag 的值。这可以确保在多线程环境中设置值时不会发生数据竞争。<br>4.原子比较和交换（Compare-and-swap）：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> expected = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">bool</span> desired = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">bool</span> result = flag.compare<span class="hljs-constructor">_exchange_weak(<span class="hljs-params">expected</span>, <span class="hljs-params">desired</span>)</span>;<br></code></pre></td></tr></table></figure><br>compare_exchange_weak() 方法比较 flag 的当前值与 expected 值。如果它们相等，该方法会将 flag 设置为 desired 值，并返回 true。如果它们不等，则返回 false，并将 expected 更新为 flag 的当前值。这个操作是原子的，因此在多线程环境中也是安全的。<br>5.原子操作符：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> oldValue = flag.<span class="hljs-built_in">exchange</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 将原子布尔值设置为 true 并返回旧值</span><br></code></pre></td></tr></table></figure><br>exchange() 方法将 flag 的值设置为指定值，并返回其原始值。这个操作也是原子的。</p><p>使用 std::atomic_bool 可以方便地在多线程环境中实现无锁操作，避免使用互斥锁带来的性能损失。然而，需要注意的是，原子操作虽然高效，但并非所有场景都适用。在某些情况下，互斥锁和其他同步原语可能更合适。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并分支到main上</title>
    <link href="/2023/04/06/%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E5%88%B0main%E4%B8%8A/"/>
    <url>/2023/04/06/%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E5%88%B0main%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="git合并分支到main上"><a href="#git合并分支到main上" class="headerlink" title="git合并分支到main上"></a>git合并分支到main上</h1><h2 id="查看当前分支"><a href="#查看当前分支" class="headerlink" title="查看当前分支"></a>查看当前分支</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure><h2 id="在当前分支提交代码"><a href="#在当前分支提交代码" class="headerlink" title="在当前分支提交代码"></a>在当前分支提交代码</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git  <span class="hljs-keyword">add</span> .  <br>git  <span class="hljs-keyword">commit</span> -m <span class="hljs-string">&#x27;initial commit&#x27;</span>  <br>git push -u origin dev  <br></code></pre></td></tr></table></figure><h2 id="dev分支的代码合并到main分支上"><a href="#dev分支的代码合并到main分支上" class="headerlink" title="dev分支的代码合并到main分支上"></a>dev分支的代码合并到main分支上</h2><p>首先切换到main分支上<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git  checkout <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure><br>如果是多人开发的话 需要把远程main上的代码pull下来<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git pull origin <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure><br>把dev分支的代码合并到main上<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">git  <span class="hljs-keyword">merge</span> dev<br></code></pre></td></tr></table></figure><br>查看状态<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span><br></code></pre></td></tr></table></figure><br>push到远程main上<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> main<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS中roll pitch yaw分别是绕哪个轴转</title>
    <link href="/2023/04/06/ROS%E4%B8%ADroll-pitch-yaw%E5%88%86%E5%88%AB%E6%98%AF%E7%BB%95%E5%93%AA%E4%B8%AA%E8%BD%B4%E8%BD%AC/"/>
    <url>/2023/04/06/ROS%E4%B8%ADroll-pitch-yaw%E5%88%86%E5%88%AB%E6%98%AF%E7%BB%95%E5%93%AA%E4%B8%AA%E8%BD%B4%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS中roll-pitch-yaw分别是绕哪个轴转"><a href="#ROS中roll-pitch-yaw分别是绕哪个轴转" class="headerlink" title="ROS中roll pitch yaw分别是绕哪个轴转"></a>ROS中roll pitch yaw分别是绕哪个轴转</h1><img src="/2023/04/06/ROS%E4%B8%ADroll-pitch-yaw%E5%88%86%E5%88%AB%E6%98%AF%E7%BB%95%E5%93%AA%E4%B8%AA%E8%BD%B4%E8%BD%AC/rpy.png" class="" title="roll-pitch-yaw">  <p>pitch是围绕X轴旋转，也叫做俯仰角。<br>yaw是围绕Y轴旋转，也叫偏航角。<br>roll是围绕Z轴旋转，也叫翻滚角。<br>在3D系统中，假设视点为原点，则视点坐标系如下图所示，通常z轴的负方向是视点方向<br><img src="/2023/04/06/ROS%E4%B8%ADroll-pitch-yaw%E5%88%86%E5%88%AB%E6%98%AF%E7%BB%95%E5%93%AA%E4%B8%AA%E8%BD%B4%E8%BD%AC/sight.png" class="" title="3D系统"></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS主从机配置</title>
    <link href="/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>与伙伴之间的工作配合可能涉及到ROS功能之间的调试，这时采用主从机的方式比较方便。</p><h1 id="配置虚拟机网络适配器"><a href="#配置虚拟机网络适配器" class="headerlink" title="配置虚拟机网络适配器"></a>配置虚拟机网络适配器</h1><p>虚拟机网络设置为桥接模式<br><img src="/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/bridge.png" class="" title="虚拟机网络模式"></p><h1 id="查看主机和从机IP"><a href="#查看主机和从机IP" class="headerlink" title="查看主机和从机IP"></a>查看主机和从机IP</h1><p>打开终端输入<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span><br></code></pre></td></tr></table></figure><br>如果报错请相应安装相关软件<br><img src="/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/ifconfig.png" class="" title="查看主机和从机的IP"></p><h1 id="设置IP地址"><a href="#设置IP地址" class="headerlink" title="设置IP地址"></a>设置IP地址</h1><p>首先需要确定ROS多机系统中的所有计算机处于同一网络，同一网段，例如我的主机IP为192.168.21.228，从机IP为192.168.21.17<br>分别在两台计算机系统的/etc/hosts文件中加入对方的IP地址和对应的计算机名：</p><h1 id="主机hosts设置"><a href="#主机hosts设置" class="headerlink" title="主机hosts设置"></a>主机hosts设置</h1><p>主机设置的是从机的IP和计算机名<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/</span>hosts<br></code></pre></td></tr></table></figure><br><img src="/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/host.png" class="" title="主机hosts设置"></p><h1 id="从机hosts设置"><a href="#从机hosts设置" class="headerlink" title="从机hosts设置"></a>从机hosts设置</h1><p>从机设置的是主机的IP和计算机名<br>从机打开终端<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/</span>hosts<br></code></pre></td></tr></table></figure><br><img src="/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/slave.png" class="" title="从机hosts设置"><br><strong>这里因为我的主机和从机计算机名相同，所以在这里不要困惑</strong></p><h1 id="主机环境变量设置"><a href="#主机环境变量设置" class="headerlink" title="主机环境变量设置"></a>主机环境变量设置</h1><p>这里两种方式可选择1、打开新终端设置环境变量2、在~/.bashrc文件末尾添加，两种方式都填入如下内容<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">ROS_HOSTNAME</span>=192.168.21.228 #主机IP地址  <br><span class="hljs-built_in">export</span> <span class="hljs-attribute">ROS_MASTER_URI</span>=http://192.168.21.228:11311 #主机IP地址:11311  <br><span class="hljs-built_in">export</span> <span class="hljs-attribute">ROS_IP</span>=190.168.21.228 #主机IP地址<br></code></pre></td></tr></table></figure></p><h1 id="从机环境变量设置"><a href="#从机环境变量设置" class="headerlink" title="从机环境变量设置"></a>从机环境变量设置</h1><p>这里同样有两种方式可选择1、打开新终端设置环境变量2、在~/.bashrc文件末尾添加，两种方式都填入如下内容<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">ROS_HOSTNAME</span>=192.168.21.17 #从机IP地址  <br><span class="hljs-built_in">export</span> <span class="hljs-attribute">ROS_MASTER_URI</span>=http://192.168.21.228:11311 #主机IP地址:11311<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">ROS_IP</span>=190.168.21.228 #主机IP地址<br></code></pre></td></tr></table></figure></p><h1 id="下载包和解决报错"><a href="#下载包和解决报错" class="headerlink" title="下载包和解决报错"></a>下载包和解决报错</h1><p>两台电脑都要下载以下两个包<br>第一个是下载同步包；第二个是下载ssh服务器<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install chrony<br></code></pre></td></tr></table></figure><br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> install openssh-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><br>重启ssh-server<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/etc/i</span>nit.d/ssh restart<br></code></pre></td></tr></table></figure></p><h1 id="检测通信"><a href="#检测通信" class="headerlink" title="检测通信"></a>检测通信</h1><p>设置完成后，在两台电脑上分别使用ping命令测试网络是否联通。其中ping是用来检测本机与网络中另一主机之间网络是否联通的命令，如果两台主机之间ping不通，则表明这两台主机不能建立起连接。</p><h2 id="主机ping从机"><a href="#主机ping从机" class="headerlink" title="主机ping从机"></a>主机ping从机</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ping</span> <span class="hljs-number">192.168.21.17</span><br></code></pre></td></tr></table></figure><h2 id="从机ping主机"><a href="#从机ping主机" class="headerlink" title="从机ping主机"></a>从机ping主机</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ping</span> <span class="hljs-number">192.168.21.228</span><br></code></pre></td></tr></table></figure><p>两台电脑上都出现了ping接收到了数据，说明双向网络能正常联通，底层网络的通信就可以实现。<br><strong>当然，如果碰到输入ping IP而一直无法响应时，说明没有ping通，检查一下该计算机对应的ip地址是否变动了</strong></p><h1 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h1><p>配置完毕，接下来就要验证是否配置成功。但是运行前先要把之前的终端关掉，不然还是之前的配置<br>运行一个小海龟来验证一下，主机中输入：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">roscore</span><br></code></pre></td></tr></table></figure><br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosrun turtlesim turtlesim_node</span><br></code></pre></td></tr></table></figure><br><img src="/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/demo.png" class="" title="主机运行海龟"><br>在从机器中用键盘进行控制，从机中运行：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosrun turtlesim turtle_teleop_key</span><br></code></pre></td></tr></table></figure><br><img src="/2023/04/03/ROS%E4%B8%BB%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE/demo2.png" class="" title="从机键盘控制主机的海龟移动"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://wiki.ros.org/ROS/Tutorials/MultipleMachines">http://wiki.ros.org/ROS/Tutorials/MultipleMachines</a><br><a href="https://www.guyuehome.com/25106">https://www.guyuehome.com/25106</a><br><a href="https://blog.csdn.net/weixin_51244852/article/details/115738730">https://blog.csdn.net/weixin_51244852/article/details/115738730</a><br><a href="https://blog.csdn.net/GeForeverr/article/details/102465763">https://blog.csdn.net/GeForeverr/article/details/102465763</a><br><a href="https://www.guyuehome.com/40852">https://www.guyuehome.com/40852</a></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS海龟跟随-理解TF坐标变换</title>
    <link href="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/"/>
    <url>/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS海龟跟随-理解TF坐标变换"><a href="#ROS海龟跟随-理解TF坐标变换" class="headerlink" title="ROS海龟跟随-理解TF坐标变换"></a>ROS海龟跟随-理解TF坐标变换</h1><p>本篇我们在海龟仿真器中，通过一个例程（turtle_tf）来理解TF的作用，并且熟悉之前学到的TF工具。该例程的功能包turtle_tf可以使用如下命令进行安装：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-turtle-tf<br></code></pre></td></tr></table></figure><br>安装完成后，就可以使用如下命令运行例程了：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">roslaunch turtle_tf turtle_tf_demo.<span class="hljs-built_in">launch</span><br></code></pre></td></tr></table></figure><br>海龟仿真器打开后会出现两只小海龟，并且下方的小海龟自动向中心位置的小海龟移动<br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/turtlesim.png" class="" title="海龟仿真器"><br>键盘控制一只海龟移动，另一只会跟随着一起移动<br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/follow.png" class="" title="海龟跟随移动"><br>另外一只海龟总是会跟随我们控制的那只海龟运行。在这个例程中，TF是如何运用的呢？我们首先使用TF工具来看一下这个例程中的TF树是什么样的：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosrun tf view_frames</span><br></code></pre></td></tr></table></figure><br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/view_frame.png" class="" title="TF树"><br>在当前系统中存在三个坐标系：world、turtle1、turtle2。world是世界坐标系，作为系统的基础坐标系，其他坐标系都相对该坐标系建立，所以world是TF树的根节点。相对于world坐标系，又分别针对两只海龟创建了两个海龟坐标系，这两个坐标系的原点就是海龟在世界坐标系下的坐标位置。<br>现在要让turtle2跟随turtle1运动，相当于turtle2坐标系向turtle1坐标系移动，这就需要知道turtle2与turtle1之间的坐标变换。三个坐标系之间的变换关系可以使用如下公式描述：<br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/trans.png" class="" title="海龟之间的坐标变换"><br>使用tf_echo工具在TF树中查找海龟坐标系之间的变换关系：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">rosrun tf tf_<span class="hljs-keyword">echo</span> turtle1 turtle2<br></code></pre></td></tr></table></figure><br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/trans_matrix.png" class="" title="变换矩阵"><br>也可以通过rviz的图形界面更加形象的看到这三者之间的坐标关系：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">rosrun rviz rviz -d `rospack <span class="hljs-keyword">find</span> turtle_tf`<span class="hljs-regexp">/rviz/</span>turtle_rviz.rviz<br></code></pre></td></tr></table></figure><br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/rviz.png" class="" title="rviz中坐标系之间关系"><br>得到turtle2与turtle1之间的坐标变换后，就可以计算两只海龟间的距离和角度，即可控制turtle2向turtle1移动了。<br>接下来，我们以这个例程为目标，学习如何实现TF的广播和监听功能。  </p><h1 id="创建TF广播器"><a href="#创建TF广播器" class="headerlink" title="创建TF广播器"></a>创建TF广播器</h1><p>首先，我们需要创建一个发布海龟坐标系与世界坐标系之间TF变换的节点，实现源码turtle_tf_broadcaster.cpp的具体内容如下：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;ros/ros.h&gt;<br>#<span class="hljs-keyword">include</span> &lt;tf/transform_broadcaster.h&gt;<br>#<span class="hljs-keyword">include</span> &lt;turtlesim/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Pose</span>.</span></span>h&gt;<br><br>std::<span class="hljs-built_in">string</span> turtle_name;<br><br>void pose<span class="hljs-constructor">Callback(<span class="hljs-params">const</span> <span class="hljs-params">turtlesim</span>::PoseConstPtr&amp; <span class="hljs-params">msg</span>)</span><br>&#123;<br><span class="hljs-comment">// tf广播器</span><br>static tf::TransformBroadcaster br;<br><br><span class="hljs-comment">// 根据海龟当前的位姿，设置相对于世界坐标系的坐标变换</span><br>tf::Transform transform;<br>transform.set<span class="hljs-constructor">Origin( <span class="hljs-params">tf</span>::Vector3(<span class="hljs-params">msg</span>-&gt;<span class="hljs-params">x</span>, <span class="hljs-params">msg</span>-&gt;<span class="hljs-params">y</span>, 0.0)</span> );<br>tf::Quaternion q;<br>q.set<span class="hljs-constructor">RPY(0, 0, <span class="hljs-params">msg</span>-&gt;<span class="hljs-params">theta</span>)</span>;<br>transform.set<span class="hljs-constructor">Rotation(<span class="hljs-params">q</span>)</span>;<br><br><span class="hljs-comment">// 发布坐标变换</span><br>br.send<span class="hljs-constructor">Transform(<span class="hljs-params">tf</span>::StampedTransform(<span class="hljs-params">transform</span>, <span class="hljs-params">ros</span>::Time::<span class="hljs-params">now</span>()</span>, <span class="hljs-string">&quot;world&quot;</span>, turtle_name));<br>&#125;<br><br><span class="hljs-built_in">int</span> main(<span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span>** argv)<br>&#123;<br><span class="hljs-comment">// 初始化节点</span><br>ros::init(argc, argv, <span class="hljs-string">&quot;my_tf_broadcaster&quot;</span>);<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-constructor">ROS_ERROR(<span class="hljs-string">&quot;need turtle name as argument&quot;</span>)</span>; <br>return -<span class="hljs-number">1</span>;<br>&#125;;<br>turtle_name = argv<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>;<br><br><span class="hljs-comment">// 订阅海龟的pose信息</span><br>ros::NodeHandle node;<br>ros::Subscriber sub = node.subscribe(turtle_name+<span class="hljs-string">&quot;/pose&quot;</span>, <span class="hljs-number">10</span>, &amp;poseCallback);<br><br>ros::spin<span class="hljs-literal">()</span>;<br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>以上代码的关键部分是处理海龟pose消息的回调函数poseCallback。在广播TF消息之前需要定义tf::TransformBroadcaster广播器，然后根据海龟当前的位姿，设置tf::Transform类型的坐标变换，包含setOrigin设置的平移变换以及setRotation设置的旋转变换。<br>然后使用广播器将坐标变换插入TF树并且发布，这里发布的TF消息类型是tf::StampedTransform，不仅包含tf::Transform类型的坐标变换、时间戳，而且还需要指定坐标变换的源坐标系（parent）和目标坐标系（child）。  </p><h1 id="创建TF监听器"><a href="#创建TF监听器" class="headerlink" title="创建TF监听器"></a>创建TF监听器</h1><p>TF消息广播之后，其他节点就可以监听该TF消息，从而获取需要的坐标变换了。<br>目前我们已经将海龟相对于world坐标系的TF变换广播，接下来需要监听TF消息，并从中获取turtle2相对于turtle1坐标系的变换，从而控制turtle2移动。实现源码turtle_tf_listener.cpp的详细内容如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tf/transform_listener.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;geometry_msgs/Twist.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;turtlesim/Spawn.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 初始化节点</span><br>ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;my_tf_listener&quot;</span>);<br><br>ros::NodeHandle node;<br><br><span class="hljs-comment">// 通过服务调用，产生第二只乌龟turtle2</span><br>ros::service::<span class="hljs-built_in">waitForService</span>(<span class="hljs-string">&quot;spawn&quot;</span>);<br>ros::ServiceClient add_turtle =<br>node.<span class="hljs-built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="hljs-string">&quot;spawn&quot;</span>);<br>turtlesim::Spawn srv;<br>add_turtle.<span class="hljs-built_in">call</span>(srv);<br><br><span class="hljs-comment">// 定义turtle2的速度控制发布器</span><br>ros::Publisher turtle_vel =<br>node.<span class="hljs-built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="hljs-string">&quot;turtle2/cmd_vel&quot;</span>, <span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// tf监听器</span><br>tf::TransformListener listener;<br><br><span class="hljs-function">ros::Rate <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-number">10.0</span>)</span></span>;<br><span class="hljs-keyword">while</span> (node.<span class="hljs-built_in">ok</span>())<br>&#123;<br>tf::StampedTransform transform;<br><span class="hljs-keyword">try</span><br>&#123;<br><span class="hljs-comment">// 查找turtle2与turtle1的坐标变换</span><br>listener.<span class="hljs-built_in">waitForTransform</span>(<span class="hljs-string">&quot;/turtle2&quot;</span>, <span class="hljs-string">&quot;/turtle1&quot;</span>, ros::<span class="hljs-built_in">Time</span>(<span class="hljs-number">0</span>), ros::<span class="hljs-built_in">Duration</span>(<span class="hljs-number">3.0</span>));<br>listener.<span class="hljs-built_in">lookupTransform</span>(<span class="hljs-string">&quot;/turtle2&quot;</span>, <span class="hljs-string">&quot;/turtle1&quot;</span>, ros::<span class="hljs-built_in">Time</span>(<span class="hljs-number">0</span>), transform);<br>&#125;<br><span class="hljs-built_in">catch</span> (tf::TransformException &amp;ex) <br>&#123;<br><span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;%s&quot;</span>,ex.<span class="hljs-built_in">what</span>());<br>ros::<span class="hljs-built_in">Duration</span>(<span class="hljs-number">1.0</span>).<span class="hljs-built_in">sleep</span>();<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">// 根据turtle1和turtle2之间的坐标变换，计算turtle2需要运动的线速度和角速度</span><br><span class="hljs-comment">// 并发布速度控制指令，使turtle2向turtle1移动</span><br>geometry_msgs::Twist vel_msg;<br>vel_msg.angular.z = <span class="hljs-number">4.0</span> * <span class="hljs-built_in">atan2</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">y</span>(),<br>transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">x</span>());<br>vel_msg.linear.x = <span class="hljs-number">0.5</span> * <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">x</span>(), <span class="hljs-number">2</span>) +<br><span class="hljs-built_in">pow</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">y</span>(), <span class="hljs-number">2</span>));<br>turtle_vel.<span class="hljs-built_in">publish</span>(vel_msg);<br><br>rate.<span class="hljs-built_in">sleep</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>该节点首先通过服务调用产生海龟turtle2，然后声明控制turtle2速度的Publisher。在监听TF消息之前，需要创建一个tf::TransformListener类型的监听器，创建成功后监听器会自动接收TF树的消息，并且缓存10秒。<br>然后在循环中就可以实时查找TF树中的坐标变换了，这里需要调用的是tf::TransformListener中的两个接口：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">wait<span class="hljs-constructor">ForTransform(<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span> &amp;<span class="hljs-params">target_frame</span>, <span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span>&amp;<span class="hljs-params">source_frame</span>, <span class="hljs-params">const</span> <span class="hljs-params">ros</span>::Time&amp;<span class="hljs-params">time</span>, <span class="hljs-params">const</span> <span class="hljs-params">ros</span>::Duration &amp;<span class="hljs-params">timeout</span>)</span><br></code></pre></td></tr></table></figure><br>给定的源坐标系（source_frame）和目标坐标系（target_frame），等待两个坐标系之间指定时间（time）的变换关系，该函数会阻塞程序运行，所以需要设置超时时间（timeout）。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">lookup<span class="hljs-constructor">Transform(<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span> &amp;<span class="hljs-params">target_frame</span>,<span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span> &amp;<span class="hljs-params">source_frame</span>, <span class="hljs-params">const</span> <span class="hljs-params">ros</span>::Time &amp; <span class="hljs-params">time</span>,StampedTransform &amp;<span class="hljs-params">transform</span>)</span><br></code></pre></td></tr></table></figure><br>给定的源坐标系（source_frame）和目标坐标系（target_frame），得到两个坐标系之间指定时间（time）的坐标变换（transform），ros::Time(0) 表示我们想要的是最新一次的坐标变换。<br>通过以上两个接口的调用，就可以获取turtle2相对于turtle1的坐标变换了。然后根据坐标系之间的位置关系，计算得到turtle2需要运动的线速度和角速度，并发布速度控制指令，使turtle2向turtle1移动。</p><h1 id="实现海龟跟随运动"><a href="#实现海龟跟随运动" class="headerlink" title="实现海龟跟随运动"></a>实现海龟跟随运动</h1><p>现在小海龟跟随例程的所有代码都已经完成，我们来编写一个launch文件，将所有节点运行起来，start_demo_with_listener.launch：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 海龟仿真器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sim&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 键盘控制 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_teleop_key&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teleop&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 两只海龟的tf广播 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;tf_demo&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_broadcaster&quot;</span> <span class="hljs-attr">args</span>=<span class="hljs-string">&quot;/turtle1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle1_tf_broadcaster&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;tf_demo&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_broadcaster&quot;</span> <span class="hljs-attr">args</span>=<span class="hljs-string">&quot;/turtle2&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle2_tf_broadcaster&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 监听tf广播，并且控制turtle2移动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;tf_demo&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_listener&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">name</span>=<span class="hljs-string">&quot;listener&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><br>运行该launch文件，就可以看到与之前例程类似的两只海龟的界面了，在终端中通过键盘控制turtle1移动，turtle2也跟随移动。  </p><h1 id="设置不同颜色区分海龟的轨迹"><a href="#设置不同颜色区分海龟的轨迹" class="headerlink" title="设置不同颜色区分海龟的轨迹"></a>设置不同颜色区分海龟的轨迹</h1><p>如果想用不同颜色区分小海龟的轨迹可以在新终端打开rqt<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rqt</span><br></code></pre></td></tr></table></figure><br>然后在service下拉选项选择/turtle1/set_pen设置第一个小海龟轨迹的颜色<br><br>然后点击call完成设置<br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/red.png" class="" title="海龟轨迹颜色设置"><br>然后键盘控制海龟移动，海归的轨迹显示了不同的颜色<br><img src="/2023/03/31/ROS%E6%B5%B7%E9%BE%9F%E8%B7%9F%E9%9A%8F-%E7%90%86%E8%A7%A3TF%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/color_path.png" class="" title="不同海龟轨迹颜色"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://zhuanlan.zhihu.com/p/58184028">参考文章</a></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rosbag包绘图工具PlotJuggler使用方法</title>
    <link href="/2023/03/29/rosbag%E5%8C%85%E7%BB%98%E5%9B%BE%E5%B7%A5%E5%85%B7PlotJuggler%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2023/03/29/rosbag%E5%8C%85%E7%BB%98%E5%9B%BE%E5%B7%A5%E5%85%B7PlotJuggler%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="rosbag包绘图工具PlotJuggler使用方法"><a href="#rosbag包绘图工具PlotJuggler使用方法" class="headerlink" title="rosbag包绘图工具PlotJuggler使用方法"></a>rosbag包绘图工具PlotJuggler使用方法</h1><p>安装：<br>ubuntu版本为melodic，如果是其他版本作相应替换<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-plotjuggler<br></code></pre></td></tr></table></figure><br>ros插件安装<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-plotjuggler-msgs ros-melodic-plotjuggler-ros<br></code></pre></td></tr></table></figure><br>使用：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">roscore</span><br></code></pre></td></tr></table></figure><br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosrun plotjuggler plotjuggler</span><br></code></pre></td></tr></table></figure></p><h1 id="绘制XY曲线"><a href="#绘制XY曲线" class="headerlink" title="绘制XY曲线"></a>绘制XY曲线</h1><p>即使PlotJuggler主要关注时间序列，也可以将共享同一时间轴的两个时间序列混合在一起。一个经典的例子是机器人的XY位置，如果想知道机器人在全局坐标系下的运动轨迹，就要将xy同时描绘出来。要激活此模式，请使用鼠标右键而不是鼠标左键拖动XY数据到figure中</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包绘图工具PlotJuggler使用方法</title>
    <link href="/2023/03/29/%E5%8C%85%E7%BB%98%E5%9B%BE%E5%B7%A5%E5%85%B7PlotJuggler%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2023/03/29/%E5%8C%85%E7%BB%98%E5%9B%BE%E5%B7%A5%E5%85%B7PlotJuggler%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ROS消息或服务无法编译生成msg/srv文件产生的头文件</title>
    <link href="/2023/03/29/ROS%E6%B6%88%E6%81%AF%E6%88%96%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90msg-srv%E6%96%87%E4%BB%B6%E4%BA%A7%E7%94%9F%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <url>/2023/03/29/ROS%E6%B6%88%E6%81%AF%E6%88%96%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90msg-srv%E6%96%87%E4%BB%B6%E4%BA%A7%E7%94%9F%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS消息或服务无法编译生成msg-srv文件产生的头文件"><a href="#ROS消息或服务无法编译生成msg-srv文件产生的头文件" class="headerlink" title="ROS消息或服务无法编译生成msg/srv文件产生的头文件"></a>ROS消息或服务无法编译生成msg/srv文件产生的头文件</h1><p><strong>问题原因：</strong><br>一般情况下，如果你的msg/srv文件是一个单独的package的话(假设为A)，在依赖A生成的头文件的packageB里面编译对应的cpp文件时，在add_dependencies的最后添加${catkin_EXPORTED_TARGETS}会包含所有在find_package里面列出的包的_generate_messages_cpp宏用来生成对应的头文件，这样编译应该是没有问题的。但是当msg/srv和需要其产生头文件的cpp文件在同一个包里面时，第一次编译会报找不到头文件的错。<br><strong>解决：</strong><br>${catkin_EXPORTED_TARGETS}这个宏之前再加一个current_package_generate_messages_cpp，current_package换成当前的包名即可。<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">add_dependencies</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_node <span class="hljs-variable">$&#123;<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125;</span> <span class="hljs-variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)<br></code></pre></td></tr></table></figure><br>其中 ${PROJECT_NAME}_node 替换为自己的ros节点名<br>例如：<br><img src="/2023/03/29/ROS%E6%B6%88%E6%81%AF%E6%88%96%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90msg-srv%E6%96%87%E4%BB%B6%E4%BA%A7%E7%94%9F%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/bug.png" class="" title="CmakeLists例子"></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS中使用rqt报错Command &#39;rqt&#39; not found</title>
    <link href="/2023/03/27/ROS%E4%B8%AD%E4%BD%BF%E7%94%A8rqt%E6%8A%A5%E9%94%99Command-rqt-not-found/"/>
    <url>/2023/03/27/ROS%E4%B8%AD%E4%BD%BF%E7%94%A8rqt%E6%8A%A5%E9%94%99Command-rqt-not-found/</url>
    
    <content type="html"><![CDATA[<p>ROS在使用rqt命令时突然报错Command ‘rqt’ not found，可能是因为不小心卸载掉了rqt，重装可解决<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-kinetic-rqt  <br>sudo apt-<span class="hljs-built_in">get</span> install ros-kinetic-rqt-graph  <br>sudo apt-<span class="hljs-built_in">get</span> install ros-kinetic-rqt-common-plugins  <br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人脱困方案简述</title>
    <link href="/2023/03/22/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%84%B1%E5%9B%B0%E6%96%B9%E6%A1%88%E7%AE%80%E8%BF%B0/"/>
    <url>/2023/03/22/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%84%B1%E5%9B%B0%E6%96%B9%E6%A1%88%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="基于ROS-navigation-进行机器人脱困方案设计"><a href="#基于ROS-navigation-进行机器人脱困方案设计" class="headerlink" title="基于ROS navigation 进行机器人脱困方案设计"></a>基于ROS navigation 进行机器人脱困方案设计</h1><p>如果机器人被困在障碍物中无法移动，基于ROS navigation进行脱困的算法设计可以考虑以下步骤：<br>1、感知环境并构建地图：机器人需要使用传感器（例如激光雷达或摄像头）来感知周围环境，并利用ROS中的SLAM算法构建地图。地图可以用来定位机器人的位置以及规划路径。  </p><p>2、确定困境：机器人需要确定自己被困的情况，例如是否被墙壁、家具或其他障碍物所包围。这可以通过检查机器人周围的传感器数据来实现。  </p><p>3、规划脱困路径：机器人需要使用ROS中的路径规划算法（例如A*算法或Dijkstra算法）来规划一条脱困路径。路径应该避开障碍物，将机器人导向可行的区域。路径规划算法可以利用机器人的当前位置和目标位置，结合地图信息，计算出最优的路径。  </p><p>4、控制机器人运动：机器人需要使用ROS中的运动控制库来控制机器人的运动，将其移动到规划好的脱困路径上。控制库可以将路径信息转换为机器人的运动指令，例如速度和转向角度。  </p><p>5、监控机器人状态：机器人需要监控自身的状态，例如位置和速度，以便在需要时进行调整。<br>6、处理异常情况：如果机器人在脱困过程中出现异常情况（例如机械故障或无法行驶），则需要使用ROS中的异常处理机制，例如自适应控制和错误恢复，来处理这些情况。  </p><p>总之，基于ROS navigation进行机器人脱困算法设计需要充分考虑机器人的感知、决策和控制能力，以及可能出现的异常情况。通过合理的算法设计和运动控制，可以让机器人成功地脱离障碍物并回到安全区域。</p><p>以下是一些关于ROS Navigation中recovery_behavior的相关英文论文：<br>1.”Recovery Behaviors for Navigation Robots in Dynamic Environments,” by Jinyong Jeong, Jonghun Park, Jangmyung Lee, and Hyun Myung. This paper proposes a set of recovery behaviors for navigation robots in dynamic environments, including obstacle avoidance and path planning.</p><p>2.”Robustness of Recovery Behaviors for Mobile Robots,” by Chen Wang and Hadas Kress-Gazit. This paper presents a framework for analyzing the robustness of recovery behaviors for mobile robots in complex environments.</p><p>3.”A Hierarchical Approach to Recovery Behaviors in Mobile Robot Navigation,” by Neil Dantam, Dave Coleman, and Sachin Chitta. This paper describes a hierarchical approach to recovery behaviors in mobile robot navigation, which allows the robot to recover from various types of failures and disturbances.</p><p>4.”Recovery Behaviors for Autonomous Mobile Robots,” by Stefano Carpin, Nicola Tomatis, and Alberto Broggi. This paper presents a set of recovery behaviors for autonomous mobile robots, including obstacle avoidance, replanning, and exploration.</p><p>5.”Recovery Behaviors for Mobile Robots in Unknown Environments,” by Jaeheung Park, Minwoo Lee, and Seungbin Moon. This paper proposes a set of recovery behaviors for mobile robots in unknown environments, including localization, path planning, and obstacle avoidance.<br>这些论文都提供了有关ROS Navigation中recovery_behavior的相关研究和应用的信息。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>机器人脱困</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The matrix cookbook</title>
    <link href="/2023/03/17/The-matrix-cookbook/"/>
    <url>/2023/03/17/The-matrix-cookbook/</url>
    
    <content type="html"><![CDATA[<h1 id="The-matrix-cookbook"><a href="#The-matrix-cookbook" class="headerlink" title="The matrix cookbook"></a>The matrix cookbook</h1><div class="row">    <embed src="The-Matrix-Cookbook.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cartographer仿真建图</title>
    <link href="/2023/03/16/cartographer%E4%BB%BF%E7%9C%9F%E5%BB%BA%E5%9B%BE/"/>
    <url>/2023/03/16/cartographer%E4%BB%BF%E7%9C%9F%E5%BB%BA%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="进入cartographer安装的工作空间，激活环境"><a href="#进入cartographer安装的工作空间，激活环境" class="headerlink" title="进入cartographer安装的工作空间，激活环境"></a>进入cartographer安装的工作空间，激活环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_cartographer/<br><span class="hljs-built_in">source</span> install_isolated/setup.bash<br></code></pre></td></tr></table></figure><h1 id="创建文件cartographer-demo-rplidar-launch"><a href="#创建文件cartographer-demo-rplidar-launch" class="headerlink" title="创建文件cartographer_demo_rplidar.launch"></a>创建文件cartographer_demo_rplidar.launch</h1><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">cd ~/catkin_cartographer/src/cartographer_ros/cartographer_ros/<span class="hljs-built_in">launch</span><br>cp demo_revo_lds.<span class="hljs-built_in">launch</span> cartographer_demo_rplidar.<span class="hljs-built_in">launch</span><br>gedit cartographer_demo_rplidar.<span class="hljs-built_in">launch</span><br></code></pre></td></tr></table></figure><p>并修改为以下代码：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-symbol">&lt;launch&gt;</span>  <br>  <br>  &lt;param name=<span class="hljs-string">&quot;/use_sim_time&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span> /&gt;  <br><br>  &lt;node name=<span class="hljs-string">&quot;cartographer_node&quot;</span> pkg=<span class="hljs-string">&quot;cartographer_ros&quot;</span>  <br>        <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;cartographer_node&quot;</span> <span class="hljs-keyword">args</span>=<span class="hljs-comment">&quot;  </span><br>            -configuration_directory $(<span class="hljs-keyword">find</span> cartographer_ros)/configuration_files  <br>            -configuration_basename rplidar.<span class="hljs-keyword">lua</span><span class="hljs-comment">&quot;  </span><br>        output=<span class="hljs-string">&quot;screen&quot;</span>&gt;  <br>    &lt;remap from=<span class="hljs-string">&quot;scan&quot;</span> <span class="hljs-keyword">to</span>=<span class="hljs-string">&quot;scan&quot;</span> /&gt;  <br>  &lt;/node&gt;  <br><br>  &lt;node name=<span class="hljs-string">&quot;rviz&quot;</span> pkg=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;rviz&quot;</span> required=<span class="hljs-string">&quot;true&quot;</span>  <br>        <span class="hljs-keyword">args</span>=<span class="hljs-string">&quot;-d $(find cartographer_ros)/configuration_files/demo_2d.rviz&quot;</span> /&gt;  <br>&lt;/launch&gt;<br><br></code></pre></td></tr></table></figure></p><h1 id="创建文件rplidar-lua"><a href="#创建文件rplidar-lua" class="headerlink" title="创建文件rplidar.lua"></a>创建文件rplidar.lua</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> ~/catkin_cartographer/src/cartographer_ros/cartographer_ros/configuration_files<br><span class="hljs-keyword">cp</span> revo_lds.<span class="hljs-keyword">lua</span> rplidar.<span class="hljs-keyword">lua</span><br>gedit rplidar.<span class="hljs-keyword">lua</span><br></code></pre></td></tr></table></figure><p>修改字段如下：<br>tracking_frame = “laser_link”,<br>published_frame = “laser_link”,  </p><h1 id="配置文件修改后，需要重新编译cartographer"><a href="#配置文件修改后，需要重新编译cartographer" class="headerlink" title="配置文件修改后，需要重新编译cartographer"></a>配置文件修改后，需要重新编译cartographer</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/catkin_cartographer</span><br>catkin_make_isolated <span class="hljs-params">--install</span> <span class="hljs-params">--use-ninja</span><br></code></pre></td></tr></table></figure><h1 id="启动仿真平台"><a href="#启动仿真平台" class="headerlink" title="启动仿真平台"></a>启动仿真平台</h1><p>启动仿真平台</p><h1 id="打开新的终端，启动Cartographer"><a href="#打开新的终端，启动Cartographer" class="headerlink" title="打开新的终端，启动Cartographer"></a>打开新的终端，启动Cartographer</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_cartographer<br><span class="hljs-built_in">source</span> install_isolated/setup.bash<br>roslaunch cartographer_ros cartographer_demo_rplidar.launch<br></code></pre></td></tr></table></figure><h1 id="打开新的终端，启动键盘控制，控制机器人移动"><a href="#打开新的终端，启动键盘控制，控制机器人移动" class="headerlink" title="打开新的终端，启动键盘控制，控制机器人移动"></a>打开新的终端，启动键盘控制，控制机器人移动</h1><p>键盘控制仿真机器人移动建图</p><h1 id="打开新的终端，保存地图"><a href="#打开新的终端，保存地图" class="headerlink" title="打开新的终端，保存地图"></a>打开新的终端，保存地图</h1><p>建图完成，保存地图<br>停止地图构建<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rosservice</span> call /finish_trajectory <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><br>生成.pbstream文件，文件名及其路径可修改，以下代码是我个人目录<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">rosservice <span class="hljs-keyword">call</span> <span class="hljs-regexp">/write_state /</span>home<span class="hljs-regexp">/qiang/</span>Documents/museum.pbstream <span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><br>使用catro提供文件，将.pbstream文件转为.yaml和.pgm文件<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">cd ~/catkin_cartographer<br><span class="hljs-keyword">source</span> install_isolated/setup.bash<br>rosrun cartographer_ros cartographer_pbstream_to_ros_map -map_filestem=<span class="hljs-regexp">/home/</span>qiang<span class="hljs-regexp">/Documents/mu</span>seum -pbstream_filename=<span class="hljs-regexp">/home/</span>qiang<span class="hljs-regexp">/Documents/m</span>ap/museum.pbstream -resolution=<span class="hljs-number">0.05</span><br><br></code></pre></td></tr></table></figure><br>执行完成后，将在相应目录下生成 .yaml和.pgm文件<br><a href="https://blog.csdn.net/weixin_49195458/article/details/125067284">参考文章</a></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>cartographer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下安装Octave</title>
    <link href="/2023/03/15/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85Octave/"/>
    <url>/2023/03/15/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85Octave/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu下安装Octave"><a href="#Ubuntu下安装Octave" class="headerlink" title="Ubuntu下安装Octave"></a>Ubuntu下安装Octave</h1><p>GNU Octave是一种采用高级编程语言的主要用于数值分析的软件。Octave有助于以数值方式解决线性和非线性问题，并使用与MATLAB兼容的语言进行其他数值实验。它也可以作为面向批处理的语言使用。因为它是GNU计划的一部分，所以它是GNU通用公共许可证条款下的自由软件。</p><p>打开终端<br>第一步,添加源<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">add</span>-repository <span class="hljs-keyword">pp</span><span class="hljs-variable">a:octave</span>/stable<br></code></pre></td></tr></table></figure><br>第二步,更新源<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><br>第三步,用apt-get安装octave<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install octave<br></code></pre></td></tr></table></figure><br>第四步,运行<br>在终端中输入<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">octave</span><br></code></pre></td></tr></table></figure></p><p><a href="https://www.jianshu.com/p/08c13669cc47">原文</a></p>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>How to read a research paper</title>
    <link href="/2023/03/14/How-to-read-a-research-paper/"/>
    <url>/2023/03/14/How-to-read-a-research-paper/</url>
    
    <content type="html"><![CDATA[<h1 id="How-to-read-a-research-paper"><a href="#How-to-read-a-research-paper" class="headerlink" title="How to read a research paper"></a>How to read a research paper</h1><p>Research papers are a peculiar kind of document; for the uninitiated, it will take some getting usedto. There are two types of research papers that we may read:</p><ul><li>conference papers — shorter papers (typically 6–8 pages in robotics) generally subject to peer review, written and presented in conjunction with a conference meeting.</li><li>journal papers — longer and more complete papers, subject to a more thorough peer review, and published in an (archival) journal<br>We will be reading several journal and conference papers from the robotics literature this semester. Some of the main journals and conferences in robotics are:</li><li>IEEE Transactions on Robotics and Automation</li><li>International Journal of Robotics Research</li><li>Autonomous Robots</li><li>IEEE Conference on Robotics and Automation (ICRA)</li><li>IEEE/RSJ Conference on Robots and Systems (IROS)<br>The Rensselaer library has all these journals and conference proceedings. They are available   online through the library. The library also has hardcopy up until the past few years.<br>&emsp;To search for research papers on a topic, try the INSPEC database (available through the library<br>website under Engineering databases) or try one of the following:<br><a href="http://citeseer.ist.psu.edu/">http://citeseer.ist.psu.edu/</a><br><a href="http://scholar.google.com/">http://scholar.google.com/</a><br>Many researchers (at least in the U.S.) put their papers online on their web page. Sometimes this is a better version than what you can find through the official online sources because conference proceedings often have scanned/reduced quality figures and images. However the published version is definitive<h1 id="Questions-to-ask-while-reading-a-research-paper"><a href="#Questions-to-ask-while-reading-a-research-paper" class="headerlink" title="Questions to ask while reading a research paper"></a>Questions to ask while reading a research paper</h1>It is important that you learn to read research papers critically, so here are some questions to ask yourself as you read:</li><li>What problem(s) are they solving? Why are these problems important?</li><li>What did they really do? (as opposed to what the authors say or imply they did)</li><li>What is the contribution of the work? (i.e. what is interesting or new to the field?)</li><li>What methods are they using?</li><li>Would you have solved the problem differently?</li><li>Do all the pieces of their work fit together logically?</li><li>What were the results? Did they do what they set out to do?<h1 id="Tips-on-reading-research-papers"><a href="#Tips-on-reading-research-papers" class="headerlink" title="Tips on reading research papers"></a>Tips on reading research papers</h1></li><li>You need not read a research paper sequentially from beginning to end. Here’s one possible<br>sequence:<br>– Read the title. (What is the paper about?)<br>– Read the abstract. (Should give you a concise overview of the paper.)<br>– Read the introduction. (Look for motivations, relation to other work, and a more detailed<br>overview.)<br>– Look at the structure of the paper. (What do the remaining sections address? How do<br>they fit together?)<br>– (Read the previous/related work section. (How does this work relate? What is new or<br>different about this work?))<br>– Read the conclusions. (What were their results?)<br>– Read the body of the paper. You may want to skip over all the equations the first time<br>through  </li><li>The references won’t mean much to you if you’re not familiar with the literature. Sometimes<br>important parts of the work may be contained in the references, particularly in conference<br>papers since space is limited.<br>The references are very important when you are researching a topic — they point you to<br>related research as well as the research upon which the current paper builds upon.</li><li>Sooner or later, you will come across something that you don’t understand. What can you<br>do? You should try to figure out what it is and how it is being used (even though you still<br>don’t understand it). For further reading, see the references!</li></ul>]]></content>
    
    
    <categories>
      
      <category>academic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Building Modular ROS Packages</title>
    <link href="/2023/03/10/Building-Modular-ROS-Packages/"/>
    <url>/2023/03/10/Building-Modular-ROS-Packages/</url>
    
    <content type="html"><![CDATA[<h1 id="Building-Modular-ROS-Packages"><a href="#Building-Modular-ROS-Packages" class="headerlink" title="Building Modular ROS Packages"></a>Building Modular ROS Packages</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>&emsp;The key power of the Catkin build tool is how it makes it easier to build modular software without having to keep track of the specific build products of each package. Modularity, in this case, comes in the form of building specific functionality into libraries which can be used by other packages. This tutorial is meant for someone with minimal to moderate CMake experience and minimal experience with Catkin.</p><p>&emsp;This tutorial begins by separating the executable code from the ROS C++ Hello World Tutorial into a library and building it with CMake and Catkin. If you are unfamilar with Catkin or CMake, this tutorial will make more sense after you have worked through the Gentle Introduction to Catkin.</p><p>&emsp;The next step involves creating a second package which depends on the first package and uses the functionality defined in our library. This inter-dependency then demonstrates how to use the <font color=red>catkin_package()</font> CMake function to declare exported targets for a package.</p><h2 id="Pre-Requisites"><a href="#Pre-Requisites" class="headerlink" title="Pre-Requisites"></a>Pre-Requisites</h2><ul><li>A computer running a recent Ubuntu Linix1 LTS (long-term support) installation</li><li>Minimal experience with the Linux and the command-line interface</li><li>Minimal experience with compiling C++ code</li></ul><h2 id="Tools-Used"><a href="#Tools-Used" class="headerlink" title="Tools Used"></a>Tools Used</h2><ul><li>Ubuntu Linux</li><li>The bash shell</li><li>C++</li><li>CMake</li><li>Catkin</li><li>Any plain-text editor (I like vim).</li></ul><h2 id="ROS-Packages-Used"><a href="#ROS-Packages-Used" class="headerlink" title="ROS Packages Used"></a>ROS Packages Used</h2><ul><li>roscpp</li><li>roscpp</li><li>catkin</li></ul><h2 id="Create-a-Catkin-Package"><a href="#Create-a-Catkin-Package" class="headerlink" title="Create a Catkin Package"></a>Create a Catkin Package</h2><p>Create a new directory for your package:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> src/modular_lib_pkg<br></code></pre></td></tr></table></figure><br>Add bare-bones Catkin CMakeLists.txt and package.xml files to make your directory a valid package:<br>src/modular_lib_pkg/CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Declare the version of the CMake API for forward-compatibility</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># Declare the name of the CMake Project</span><br><span class="hljs-keyword">project</span>(modular_lib_pkg)<br><br><span class="hljs-comment"># Find Catkin</span><br><span class="hljs-keyword">find_package</span>(catkin REQUIRED)<br><span class="hljs-comment"># Declare this project as a catkin package</span><br>catkin_package()<br></code></pre></td></tr></table></figure><br>src/modular_lib_pkg/package.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">package</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Package Metadata --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>modular_lib_pkg<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maintainer</span> <span class="hljs-attr">email</span>=<span class="hljs-string">&quot;you@example.com&quot;</span>&gt;</span>Your Name<span class="hljs-tag">&lt;/<span class="hljs-name">maintainer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span><br>    A ROS tutorial on modularity.<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>BSD<span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Required by Catkin --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">buildtool_depend</span>&gt;</span>catkin<span class="hljs-tag">&lt;/<span class="hljs-name">buildtool_depend</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br></code></pre></td></tr></table></figure></p><h2 id="Separating-Functionality-into-a-Library"><a href="#Separating-Functionality-into-a-Library" class="headerlink" title="Separating Functionality into a Library"></a>Separating Functionality into a Library</h2><p>&emsp;The first step in making code available for use in other ROS packages is to encapsulate its functionality into a library.</p><p>&emsp;On most operating systems, including Linux8, there are two types of libraries: static libraries and dynamic libraries. Both of these types of libraries contain compiled binary code which can be executed directly by a computer.</p><p>&emsp;Static libraries (.a for “archive” on Linux) are linked into an executable when it is built and it becomes part of that executable. When the executable is loaded, the binary code that was copied from the static library is also loaded. Dynamic libraries (.so for “shared object” on Linux), however, are not copied into the executable, and instead are loaded at runtime.</p><p>&emsp;This means not only are dynamically-linked executables smaller, but also the libraries that they depend on chan change internally without necessitating recompilation of the executable.</p><p>&emsp;In the ROS community, dynamic libraries are most commonly used, and this is what will be built by default when using Catkin.</p><h2 id="Create-the-Library-Code"><a href="#Create-the-Library-Code" class="headerlink" title="Create the Library Code"></a>Create the Library Code</h2><p>&emsp;The first step is to create the library. Our library will encapsulate the hello-world functionality used in the ROS C++ hello-world tutorial9 so that you can call a single function called say_hello() to broadcast “Hello, world!” over the /rosout topic.</p><p>&emsp;There’s nothing fundamentally different between putting C++ code in a library as opposed to an executable. What is required, however, is to split the code definition from the declaration. This involves creating two files: a header file and a source file.</p><p>&emsp;The header file should contain only what is needed by the compiler of anyone who uses the library. As such, it only needs to contain function and class delcarations, and does not need to contain function definitions.</p><p>&emsp;The header with the declaration of our say_hello() function is as follows:<br>modular_lib_pkg/include/modular_lib_pkg/hello_world.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Inclusion guard to prevent this header from being included multiple times</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MODULAR_LIB_PKG_HELLO_WORLD_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MODULAR_LIB_PKG_HELLO_WORLD_H</span><br><br><span class="hljs-comment">//! Broadcast a hello-world message over ROS_INFO</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say_hello</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><br>Next is the source or implementation file. This file should contain what is needed by the linker to connect function calls to binary code. As such, it needs to contain all of the definitions of the functions declared in the corresponding header.<br>&emsp;The source file with the definition of say_hello() is as follows:<br>modular_lib_pkg/src/hello_world.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Include the ROS C++ APIs</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say_hello</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">ROS_INFO_STREAM</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>Now that we’ve written the code for the library, we can add a rule to the CMakeLists.txt file to actually build it. Note that just like in the ROS C++ hello-world tutorial9, we need to add a dependency on roscpp in order to use ROS. This is just like adding an executable with the add_executable() CMake command: instead, we use add_library():<br>src/modular_lib_pkg/CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Declare the version of the CMake API for forward-compatibility</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># Declare the name of the CMake Project</span><br><span class="hljs-keyword">project</span>(modular_lib_pkg)<br><br><span class="hljs-comment"># Find and get all the information about the roscpp package</span><br><span class="hljs-keyword">find_package</span>(roscpp REQUIRED)<br><br><span class="hljs-comment"># Find Catkin</span><br><span class="hljs-keyword">find_package</span>(catkin REQUIRED)<br><span class="hljs-comment"># Declare this project as a catkin package</span><br>catkin_package()<br><br><span class="hljs-comment"># Add the headers from roscpp</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;roscpp_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-comment"># Define a library target called hello_world</span><br><span class="hljs-keyword">add_library</span>(hello_world src/hello_world.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><br>&emsp;Also, now that we’re using the roscpp package, we need to list it as a build- and run-dependency of our package:<br>src/modular_lib_pkg/package.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">package</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Package Metadata --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>modular_lib_pkg<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maintainer</span> <span class="hljs-attr">email</span>=<span class="hljs-string">&quot;you@example.com&quot;</span>&gt;</span>Your Name<span class="hljs-tag">&lt;/<span class="hljs-name">maintainer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span><br>    A ROS tutorial on modularity.<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>BSD<span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Required by Catkin --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">buildtool_depend</span>&gt;</span>catkin<span class="hljs-tag">&lt;/<span class="hljs-name">buildtool_depend</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Package Dependencies --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>roscpp<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">run_depend</span>&gt;</span>roscpp<span class="hljs-tag">&lt;/<span class="hljs-name">run_depend</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br></code></pre></td></tr></table></figure><br>&emsp;At this point you should be able to compile the library by running catkin_make from the root of your workspace and see the following output:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Scanning <span class="hljs-keyword">dependencies</span> of target hello_world<br>[<span class="hljs-number">100</span>%] Building CXX object modular_lib_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world.dir<span class="hljs-regexp">/src/</span>hello_world.cpp.o<br>Linking CXX shared library <span class="hljs-regexp">/tmp/</span>devel<span class="hljs-regexp">/lib/</span>libhello_world.so<br>[<span class="hljs-number">100</span>%] Built target hello_world<br></code></pre></td></tr></table></figure><br>&emsp;<strong>Notice</strong> that it built the hello_world target into a file called libhello_world.so. This is the standard naming convention for dynamic libraries on Linux. Also, it built the library into the lib subdirectory of the develspace, so when you source one of the setup files in the devel directory, it will make this library available for dynamic linking at runtime.</p><h2 id="Create-the-Node"><a href="#Create-the-Node" class="headerlink" title="Create the Node"></a>Create the Node</h2><p>&emsp;Now that we have our hello_world library, we can write a simple program to call the say_hello() function in that library. This program is nearly identical to the one used in the ROS C++ hello-world Tutorial9, except we replace the call to ROS_INFO with a call to say_hello() and we include the header file in the previous section.<br>modular_lib_pkg/src/hello_world_node.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Include the ROS C++ APIs</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><br><span class="hljs-comment">// Include the declaration of our library function</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;modular_lib_pkg/hello_world.h&gt;</span></span><br><br><span class="hljs-comment">// Standard C++ entry point</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>  <span class="hljs-comment">// Initialize ROS</span><br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;hello_world_node&quot;</span>);<br>  ros::NodeHandle nh;<br><br>  <span class="hljs-comment">// Call our library function</span><br>  <span class="hljs-built_in">say_hello</span>();<br><br>  <span class="hljs-comment">// Wait for SIGINT/Ctrl-C</span><br>  ros::<span class="hljs-built_in">spin</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>To build this node, just add an appropriate add_executable() call to the bottom of the package’s CMakeLists.txt:<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">add<span class="hljs-constructor">_executable(<span class="hljs-params">hello_world_node</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">hello_world_node</span>.<span class="hljs-params">cpp</span>)</span><br>target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">hello_world_node</span> $&#123;<span class="hljs-params">roscpp_LIBRARIES</span>&#125;)</span><br></code></pre></td></tr></table></figure></p><h2 id="Building-the-Node-and-getting-a-compiler-error"><a href="#Building-the-Node-and-getting-a-compiler-error" class="headerlink" title="Building the Node (and getting a compiler error)"></a>Building the Node (and getting a compiler error)</h2><p>&emsp;At this point, you can try to build hello_world_node with catkin_make, but you will see the following error:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[<span class="hljs-number">100</span>%] Building CXX object modular_lib_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world_node.dir<span class="hljs-regexp">/src/</span>hello_world_node.cpp.o<br><span class="hljs-regexp">/tmp/</span>src<span class="hljs-regexp">/modular_lib_pkg/</span>src<span class="hljs-regexp">/hello_world_node.cpp:5:42: fatal error: modular_lib_pkg/</span>hello_world.h: No such <span class="hljs-keyword">file</span> or directory<br>compilation terminated.<br></code></pre></td></tr></table></figure><br>&emsp;The compiler is complaining about modular_lib_pkg/hello_world.h not existing, but we know it exists! The problem isn’t that the file doesn’t exist, but rather that we haven’t told the compiler where to look for it.</p><p>&emsp;In the same way that we added the header search paths for roscpp, we also need to add our own local include directory where we put our own headers. To do so, just add the relative path to src/modular_lib_pkg/include to the existing include_directories() command in CMakeLists.txt:<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">include</span><span class="hljs-constructor">_directories(<span class="hljs-params">include</span> $&#123;<span class="hljs-params">roscpp_INCLUDE_DIRS</span>&#125;)</span><br></code></pre></td></tr></table></figure></p><h2 id="Building-the-Node-and-getting-a-linker-error"><a href="#Building-the-Node-and-getting-a-linker-error" class="headerlink" title="Building the Node (and getting a linker error)"></a>Building the Node (and getting a linker error)</h2><p>At this point, you can try to build hello_world_node with catkin_make again, but you will see another error:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">[<span class="hljs-number">100</span>%] Building CXX object modular_lib_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world_node.dir<span class="hljs-regexp">/src/</span>hello_world_node.cpp.o<br>Linking CXX executable <span class="hljs-regexp">/tmp/</span>foo<span class="hljs-regexp">/devel/</span>lib<span class="hljs-regexp">/modular_lib_pkg/</span>hello_world_node<br>CMakeFiles<span class="hljs-regexp">/hello_world_node.dir/</span>src/hello_world_node.cpp.o:hello_world_node.cpp:<span class="hljs-keyword">function</span> main: error: undefined reference to <span class="hljs-string">&#x27;say_hello()&#x27;</span><br>collect2: ld returned <span class="hljs-number">1</span> <span class="hljs-keyword">exit</span> status<br></code></pre></td></tr></table></figure><br>&emsp;This time, hello_world_node.cpp is compiled successfully, but the linker reports an error that the say_hello() function is undefined. The declaration was found in the hello_world.h header file, otherwise it wouldn’t have compiled, still the definition from hello_world.cpp was missing.</p><p>&emsp;In order to resolve this, in addition to linking against ${roscpp_LIBRARIES}, we also link hello_world_node against the hello_world target so that its symbols are defined for the linker. This is done by adding hello_world to the existing target_link_libraries() command like the following:<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">hello_world_node</span> $&#123;<span class="hljs-params">roscpp_LIBRARIES</span>&#125; <span class="hljs-params">hello_world</span>)</span><br></code></pre></td></tr></table></figure><br>The following CMakeLists.txt file contains both this and the previous modifications:<br>src/modular_lib_pkg/CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Declare the version of the CMake API for forward-compatibility</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># Declare the name of the CMake Project</span><br><span class="hljs-keyword">project</span>(modular_lib_pkg)<br><br><span class="hljs-comment"># Find and get all the information about the roscpp package</span><br><span class="hljs-keyword">find_package</span>(roscpp REQUIRED)<br><br><span class="hljs-comment"># Find Catkin</span><br><span class="hljs-keyword">find_package</span>(catkin REQUIRED)<br><span class="hljs-comment"># Declare this project as a catkin package</span><br>catkin_package()<br><br><span class="hljs-comment"># Add the local headers and the headers from roscpp</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-keyword">include</span> <span class="hljs-variable">$&#123;roscpp_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-comment"># Define a library target called hello_world</span><br><span class="hljs-keyword">add_library</span>(hello_world src/hello_world.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span>)<br><br><span class="hljs-comment"># Define an executable target called hello_world_node</span><br><span class="hljs-keyword">add_executable</span>(hello_world_node src/hello_world_node.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world_node <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span> hello_world)<br></code></pre></td></tr></table></figure></p><h2 id="Building-the-Node-and-succeeding"><a href="#Building-the-Node-and-succeeding" class="headerlink" title="Building the Node (and succeeding)"></a>Building the Node (and succeeding)</h2><p>Now you should be able to compile hello_world_node succesfully and then (assuming you sourced one of your workspace’s setup files) you can run it with rosrun:<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosrun modular_lib_pkg hello_world_node</span><br></code></pre></td></tr></table></figure><br>This node does the same thing as before, except now, the core functionality is implemented in a separate library, which could more easily be used by other packages.</p><h1 id="Using-Libraries-from-Other-Packages"><a href="#Using-Libraries-from-Other-Packages" class="headerlink" title="Using Libraries from Other Packages"></a>Using Libraries from Other Packages</h1><p>Now that we’ve created a single package with its functionality built into a library, we can create another package which also uses that functionality. In this case, we’ll create another hello_world_node in another package which also links against libhello_world.so from modular_lib_pkg.</p><h2 id="Create-the-Second-Package-and-Node"><a href="#Create-the-Second-Package-and-Node" class="headerlink" title="Create the Second Package and Node"></a>Create the Second Package and Node</h2><p>First, create a package for the new node called modular_node_pkg:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> src/modular_node_pkg<br></code></pre></td></tr></table></figure><br>Next, add the source code for our node. This code is exactly the same as the hello_world_node.cpp in the modular_lib_pkg:<br>modular_node_pkg/hello_world_node.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Include the ROS C++ APIs</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><br><span class="hljs-comment">// Include the declaration of our library function</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;modular_lib_pkg/hello_world.h&gt;</span></span><br><br><span class="hljs-comment">// Standard C++ entry point</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>  <span class="hljs-comment">// Initialize ROS</span><br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;hello_world_node&quot;</span>);<br>  ros::NodeHandle nh;<br><br>  <span class="hljs-comment">// Call our library function</span><br>  <span class="hljs-built_in">say_hello</span>();<br><br>  <span class="hljs-comment">// Wait for SIGINT/Ctrl-C</span><br>  ros::<span class="hljs-built_in">spin</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>Then add the following CMakeLists.txt and package.xml files to the new package. Note that now that we’re using the modular_lib_pkg just like we’re using the roscpp package, we need to find its headers and libraries just like we do with roscpp:<br>src/modular_node_pkg/CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Declare the version of the CMake API for forward-compatibility</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># Declare the name of the CMake Project</span><br><span class="hljs-keyword">project</span>(modular_node_pkg)<br><br><span class="hljs-comment"># Find and get all the information about the roscpp package</span><br><span class="hljs-keyword">find_package</span>(roscpp REQUIRED)<br><br><span class="hljs-comment"># Find and get all the information about the modular_lib_pkg package</span><br><span class="hljs-keyword">find_package</span>(modular_lib_pkg REQUIRED)<br><br><span class="hljs-comment"># Find Catkin</span><br><span class="hljs-keyword">find_package</span>(catkin REQUIRED)<br><span class="hljs-comment"># Declare this project as a catkin package</span><br>catkin_package()<br><br><span class="hljs-comment"># Add the headers from roscpp</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;roscpp_INCLUDE_DIRS&#125;</span> <span class="hljs-variable">$&#123;modular_lib_pkg_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-comment"># Define an executable  target called hello_world_node</span><br><span class="hljs-keyword">add_executable</span>(hello_world_node2 hello_world_node.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world_node2 <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span> <span class="hljs-variable">$&#123;modular_lib_pkg_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><br><strong>NOTE:</strong> Goofy or not, the way that Catkin works, it combines all of your packages into a single CMake project. This means that each package must have unique target names. Otherwise the world will implode and unhappiness will descend upon the land. If you don’t want to have this constraint, you can use catkin_make_isolated which will build each package in isolation, but will be slower.<br>src/modular_lib_pkg/package.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">package</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Package Metadata --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>modular_node_pkg<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maintainer</span> <span class="hljs-attr">email</span>=<span class="hljs-string">&quot;you@example.com&quot;</span>&gt;</span>Your Name<span class="hljs-tag">&lt;/<span class="hljs-name">maintainer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span><br>    A ROS tutorial on modularity.<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>BSD<span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Required by Catkin --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">buildtool_depend</span>&gt;</span>catkin<span class="hljs-tag">&lt;/<span class="hljs-name">buildtool_depend</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Package Dependencies --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>roscpp<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>modular_lib_pkg<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">run_depend</span>&gt;</span>roscpp<span class="hljs-tag">&lt;/<span class="hljs-name">run_depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">run_depend</span>&gt;</span>modular_lib_pkg<span class="hljs-tag">&lt;/<span class="hljs-name">run_depend</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br></code></pre></td></tr></table></figure><br>After creating these files, your workspace should look like the following:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── build<br>│   └── ...<br>├── devel<br>│   └── ...<br>└── <span class="hljs-attribute">src</span><br>    ├── CMakeLists<span class="hljs-selector-class">.txt</span> -&gt; /opt/ros/hydro/share/catkin/cmake/toplevel<span class="hljs-selector-class">.cmake</span><br>    ├── modular_lib_pkg<br>    │   ├── CMakeLists<span class="hljs-selector-class">.txt</span><br>    │   ├── include<br>    │   │   └── modular_lib_pkg<br>    │   │       └── hello_world<span class="hljs-selector-class">.h</span><br>    │   ├── package<span class="hljs-selector-class">.xml</span><br>    │   └── <span class="hljs-attribute">src</span><br>    │       ├── hello_world<span class="hljs-selector-class">.cpp</span><br>    │       └── hello_world_node<span class="hljs-selector-class">.cpp</span><br>    └── modular_node_pkg<br>        ├── CMakeLists<span class="hljs-selector-class">.txt</span><br>        ├── hello_world_node<span class="hljs-selector-class">.cpp</span><br>        └── package.xml<br></code></pre></td></tr></table></figure></p><h2 id="Building-the-Node-and-getting-a-compiler-error-again"><a href="#Building-the-Node-and-getting-a-compiler-error-again" class="headerlink" title="Building the Node (and getting a compiler error again)"></a>Building the Node (and getting a compiler error again)</h2><p>If you try to build yor workspace by running catkin_make at this point, you will get the same compiler error as before, but this time with the new node!<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[<span class="hljs-number">100</span>%] Building CXX object modular_node_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world_node2.dir/hello_world_node.cpp.o<br><span class="hljs-regexp">/tmp/</span>foo<span class="hljs-regexp">/src/m</span>odular_node_pkg<span class="hljs-regexp">/hello_world_node.cpp:5:41: fatal error: modular_lib_pkg/</span>hello_world.h: No such <span class="hljs-keyword">file</span> or directory<br>compilation terminated.<br></code></pre></td></tr></table></figure><br>Despite the fact that you included ${modular_lib_pkg_INCLUDE_DIRS} in the include_directories() CMake function, it still couldn’t find the header. This is because this sort of information needs to be exported by the other package.</p><p>With the current workspace, not only will ${modular_lib_pkg_INCLUDE_DIRS} be empty, but also ${modular_lib_pkg_LIBRARIES} will also be empty.</p><h2 id="Exporting-Package-Flags-to-Other-Packages"><a href="#Exporting-Package-Flags-to-Other-Packages" class="headerlink" title="Exporting Package Flags to Other Packages"></a>Exporting Package Flags to Other Packages</h2><p>In the previous secion, our second package, modular_node_pkg, was unable to get the compilation or linker flags from the first package, modular_lib_pkg. This is because the flags weren’t exported by modular_lib_pkg. With Catkin, exporting such information is done with the catkin_package() command in the CMakeLists.txt file, and in the case of modular_lib_pkg, we didn’t pass it any arguments:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">catkin_package</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><br>This function can be left empty if we don’t need to export anything, but if we do, there are several optional arguments10 and the following are most commonly used:</p><ul><li>INCLUDE_DIRS One or more header directories that should be made available to other packages. These directories are relative to the path of the given CMakeLists.txt file.</li><li>LIBRARIES One or more libraries that should be made available to other packages. These are the target names of the libraries.</li><li>CATKIN_DEPENDS One or more names of Catkin packages whose build flags should be passed transitively to any package which depends on this one. This will cause dependent packages to automatically call find_package() on each of these names.</li><li>DEPENDS One or more names of packages whose build flags should be passed transitively to any package which depends on this one. If a name like foo is given here, then Catkin will add whatever the contents of the ${foo_INCLUDE_DIRS} and ${foo_LIBRARIES} variables will be exported as part of this package’s include directories and libraries, respectively.<br>In our case, we want to export both a local include directory and a library, so we modify the catkin_package() call in the modular_lib_pkg CMakeLists.txt to export the flags for our include directory and library.</li></ul><p>Additionally, we should declare that anyone depending on this package should also use build flags from the roscpp package. This is important either if we link our library against libraries from the roscpp package or if any of our exported header files #include headers from roscpp.<br><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">catkin_package</span>(</span><br><span class="hljs-function">  <span class="hljs-variable">INCLUDE_DIRS</span> <span class="hljs-variable">include</span></span><br><span class="hljs-function">  <span class="hljs-variable">LIBRARIES</span> <span class="hljs-variable">hello_world</span></span><br><span class="hljs-function">  <span class="hljs-variable">CATKIN_DEPENDS</span> <span class="hljs-variable">roscpp</span></span><br><span class="hljs-function">  )</span><br></code></pre></td></tr></table></figure><br><strong>NOTE:</strong> In this specific case, leaving out the CATKIN_DEPENDS on roscpp won’t cause any problems, but this is only because it is unlikely that someone would try to build a ROS C++ node without depending on roscpp directly. A motivating example will be shown in the next section.<br>The complete CMakeLists.txt for modular_lib_pkg is as follows:<br>src/modular_lib_pkg/CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Declare the version of the CMake API for forward-compatibility</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># Declare the name of the CMake Project</span><br><span class="hljs-keyword">project</span>(modular_lib_pkg)<br><br><span class="hljs-comment"># Find and get all the information about the roscpp package</span><br><span class="hljs-keyword">find_package</span>(roscpp REQUIRED)<br><br><span class="hljs-comment"># Find Catkin</span><br><span class="hljs-keyword">find_package</span>(catkin REQUIRED)<br><span class="hljs-comment"># Declare this project as a catkin package and export the necessary build flags</span><br>catkin_package(<br>  INCLUDE_DIRS <span class="hljs-keyword">include</span><br>  LIBRARIES hello_world<br>  CATKIN_DEPENDS roscpp<br>  )<br><br><span class="hljs-comment"># Add the local headers and the headers from roscpp</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-keyword">include</span> <span class="hljs-variable">$&#123;roscpp_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-comment"># Define a library target called hello_world</span><br><span class="hljs-keyword">add_library</span>(hello_world src/hello_world.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span>)<br><br><span class="hljs-comment"># Define an executable target called hello_world_node</span><br><span class="hljs-keyword">add_executable</span>(hello_world_node src/hello_world_node.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world_node <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span> hello_world)<br></code></pre></td></tr></table></figure><br>You can now build the workspace again with catkin_make, but this time it should succeed:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">[ <span class="hljs-number">33</span>%] Building CXX object modular_lib_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world.dir<span class="hljs-regexp">/src/</span>hello_world.cpp.o<br>Linking CXX shared library <span class="hljs-regexp">/tmp/</span>devel<span class="hljs-regexp">/lib/</span>libhello_world.so<br>[ <span class="hljs-number">33</span>%] Built target hello_world<br>[ <span class="hljs-number">66</span>%] Building CXX object modular_lib_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world_node.dir<span class="hljs-regexp">/src/</span>hello_world_node.cpp.o<br>Linking CXX executable <span class="hljs-regexp">/tmp/</span>devel<span class="hljs-regexp">/lib/m</span>odular_lib_pkg/hello_world_node<br>[ <span class="hljs-number">66</span>%] Built target hello_world_node<br>[<span class="hljs-number">100</span>%] Building CXX object modular_node_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world_node2.dir/hello_world_node.cpp.o<br>Linking CXX executable <span class="hljs-regexp">/tmp/</span>devel<span class="hljs-regexp">/lib/m</span>odular_node_pkg/hello_world_node2<br>[<span class="hljs-number">100</span>%] Built target hello_world_node2<br></code></pre></td></tr></table></figure><br>And finally, (assuming you still have your workspace environment set up), you can run hello_world_node2:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rosrun</span> modular_node_pkg hello_world_node2<br></code></pre></td></tr></table></figure><br>Reference:<br><a href="https://jbohren.com/articles/modular-ros-packages">original article</a></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Why does my robot navigate too close to walls and/or cuts corners?</title>
    <link href="/2023/03/08/Why-does-my-robot-navigate-too-close-to-walls-and-or-cuts-corners/"/>
    <url>/2023/03/08/Why-does-my-robot-navigate-too-close-to-walls-and-or-cuts-corners/</url>
    
    <content type="html"><![CDATA[<h1 id="Question-Why-does-my-robot-navigate-too-close-to-walls-and-or-cuts-corners"><a href="#Question-Why-does-my-robot-navigate-too-close-to-walls-and-or-cuts-corners" class="headerlink" title="Question: Why does my robot navigate too close to walls and/or cuts corners?"></a>Question: Why does my robot navigate too close to walls and/or cuts corners?</h1><p><strong>Short Answer:</strong> Define/Increase the inflation radius in your costmap configuration.<br><strong>Long Answer:</strong> At first glance, parameter min_obstacle_dist could be increased, but this could lead to an undesired navigation behavior in small hallways or doors (see Gaps in the trajectory). The local planner “follows” a moving virtual goal on the global plan. Therefore locations of intermediate global plan position of the global plan significantly influence the spatial behavior of the local plan. By defining an inflation radius the global planner prefers plans with minimum cost and hence plans with a higher separation from walls. Note, the teb_local_planner itself does not take the inflation radius into account. The resulting motion is time-optimal w.r.t. the virtual goal. If you wish to stick much more to following the global path, refer to Global path following. If your robot hits walls, you should really increase min_obstacle_dist or setup an appropriate footprint (refer to this tutorial).</p>]]></content>
    
    
    <categories>
      
      <category>ROS QA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS-melodic在catkin build时报错catkin: command not found</title>
    <link href="/2023/03/04/ROS-melodic%E5%9C%A8catkin-build%E6%97%B6%E6%8A%A5%E9%94%99catkin-command-not-found/"/>
    <url>/2023/03/04/ROS-melodic%E5%9C%A8catkin-build%E6%97%B6%E6%8A%A5%E9%94%99catkin-command-not-found/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS-melodic在catkin-build时报错catkin-command-not-found"><a href="#ROS-melodic在catkin-build时报错catkin-command-not-found" class="headerlink" title="ROS-melodic在catkin build时报错catkin: command not found"></a>ROS-melodic在catkin build时报错catkin: command not found</h1><p>解决方法<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-catkin python-catkin-tools<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决ubuntu在apt-get install时出错Could not get lock /var/lib/dpkg/lock-frontend</title>
    <link href="/2023/03/03/%E8%A7%A3%E5%86%B3ubuntu%E5%9C%A8apt-get-install%E6%97%B6%E5%87%BA%E9%94%99Could-not-get-lock-var-lib-dpkg-lock-frontend/"/>
    <url>/2023/03/03/%E8%A7%A3%E5%86%B3ubuntu%E5%9C%A8apt-get-install%E6%97%B6%E5%87%BA%E9%94%99Could-not-get-lock-var-lib-dpkg-lock-frontend/</url>
    
    <content type="html"><![CDATA[<p>sudo apt-get install 时会报错<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">E: Could <span class="hljs-keyword">not</span> <span class="hljs-keyword">get</span> <span class="hljs-keyword">lock</span> /var/lib/dpkg/<span class="hljs-keyword">lock</span>-frontend - <span class="hljs-keyword">open</span> (<span class="hljs-number">11</span>: Resource temporarily unavailable)<br>E: Unable <span class="hljs-keyword">to</span> acquire the dpkg frontend <span class="hljs-keyword">lock</span> (/var/lib/dpkg/<span class="hljs-keyword">lock</span>-frontend), <span class="hljs-keyword">is</span> another process <span class="hljs-keyword">using</span> it?<br></code></pre></td></tr></table></figure><br>解决方法:依次执行如下命令<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/lock<br></code></pre></td></tr></table></figure><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm <span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/apt/</span>archives/lock<br></code></pre></td></tr></table></figure><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/dpkg/</span>lock*<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gazebo打不开一直卡在Preparing your world</title>
    <link href="/2023/03/03/gazebo%E6%89%93%E4%B8%8D%E5%BC%80%E4%B8%80%E7%9B%B4%E5%8D%A1%E5%9C%A8Preparing-your-world/"/>
    <url>/2023/03/03/gazebo%E6%89%93%E4%B8%8D%E5%BC%80%E4%B8%80%E7%9B%B4%E5%8D%A1%E5%9C%A8Preparing-your-world/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在运行某些程序的功能包的时候，gazebo启动的时候会一直卡在”Preparing your world”，然后就一直不动了，这是由于gazebo在下载某些模型导致的，多等上一会，或者执行下面的命令手动把模型下全，如果还是不能打开那说明要下载的模型不在这个列表里面，知道这个模型是什么可以去手动下载，如果不知道的话就只有多等一会看能不能下完打开了。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd ~<span class="hljs-regexp">/.gazebo/</span><br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/osrf/g</span>azebo_models.git models<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>gazebo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>world</title>
    <link href="/2023/03/03/world/"/>
    <url>/2023/03/03/world/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ROS-melodic升级gazebo11</title>
    <link href="/2023/03/03/ROS-melodic%E5%8D%87%E7%BA%A7gazebo11/"/>
    <url>/2023/03/03/ROS-melodic%E5%8D%87%E7%BA%A7gazebo11/</url>
    
    <content type="html"><![CDATA[<h1 id="卸载Gazebo9"><a href="#卸载Gazebo9" class="headerlink" title="卸载Gazebo9"></a>卸载Gazebo9</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> ros-melodic-gazebo*<br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> libgazebo*<br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> gazebo*<br></code></pre></td></tr></table></figure><h1 id="安装Gazebo11"><a href="#安装Gazebo11" class="headerlink" title="安装Gazebo11"></a>安装Gazebo11</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">sudo sh -c &#x27;echo <span class="hljs-string">&quot;deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main&quot;</span> &gt; /etc/apt/sources.list.d/gazebo-stable.list&#x27;<br></code></pre></td></tr></table></figure><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">wget https://packages.osrfoundation.org/gazebo.<span class="hljs-keyword">key</span> -O - | sudo apt-<span class="hljs-keyword">key</span> <span class="hljs-keyword">add</span> -<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> update<br>sudo apt-<span class="hljs-built_in">get</span> install gazebo11<br>sudo apt-<span class="hljs-built_in">get</span> install libgazebo11-dev<br>sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-gazebo11-ros-pkgs<br></code></pre></td></tr></table></figure><h1 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h1><p>终端输入<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gazebo</span><br></code></pre></td></tr></table></figure></p><h1 id="如果出现如下错误解决方法"><a href="#如果出现如下错误解决方法" class="headerlink" title="如果出现如下错误解决方法"></a>如果出现如下错误解决方法</h1><p>出错：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">VMware: vmw_ioctl_command <span class="hljs-built_in">error</span> Invalid argument<br></code></pre></td></tr></table></figure><br>解决方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export SVGA_VGPU10=0&quot;</span> &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_44732054/article/details/123430259?spm=1001.2014.3001.5501">ROS-Melodic升级Gazebo11</a><br><a href="https://blog.csdn.net/qq_40660130/article/details/124342844">VMware: vmw_ioctl_command error Invalid argument解决办法</a></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>gazebo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv形态学处理morphologyEx</title>
    <link href="/2023/02/22/opencv%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86morphologyEx/"/>
    <url>/2023/02/22/opencv%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86morphologyEx/</url>
    
    <content type="html"><![CDATA[<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> morph_elem = <span class="hljs-number">0</span>;<br>cv::Mat element = cv::get<span class="hljs-constructor">StructuringElement( <span class="hljs-params">morph_elem</span>, <span class="hljs-params">cv</span>::Size( 3, 3 )</span>, cv::<span class="hljs-constructor">Point( -1, -1 )</span> );<br>cv::Mat dst;<br>cv::morphology<span class="hljs-constructor">Ex( <span class="hljs-params">src</span>, <span class="hljs-params">dst</span>, 3, <span class="hljs-params">element</span> )</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>opencv</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++中fillPoly函数使用</title>
    <link href="/2023/02/22/c-%E4%B8%ADfillPoly%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/02/22/c-%E4%B8%ADfillPoly%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>fillPoly函数需要二维嵌套<code>std::vector&lt;std::vector&lt;cv::Point&gt;&gt;ppts;</code>否则无法正常使用。若使用<code>std::vector&lt;cv::Point&gt; pts</code>会导致程序中断，但不会在编译器中报错。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">cv</span>::Mat <span class="hljs-built_in">image</span> = <span class="hljs-built_in">cv</span>::Mat::ones(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>, CV_8UC3)<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">cv</span>::Point&gt; pts;<br>pts.push_back(<span class="hljs-built_in">cv</span>::Point(x, y));<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">cv</span>::Point&gt;&gt; ppts;<br>ppts.push_back(pts);<br><span class="hljs-built_in">cv</span>::fillPoly(<span class="hljs-built_in">image</span> , ppts, (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>));<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>opencv</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刚体位姿</title>
    <link href="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/"/>
    <url>/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>&emsp;刚体在三维笛卡尔空间的运动包括平移和旋转，平移用三个笛卡尔坐标，旋转用三个角坐标，因此，刚体运动需要六个坐标。机器人运动学研究的就是在空间中不断地去控制机器人的位置和方向，为了确定机器人的位置和方向，需要建立一个固定的参考坐标系，称为固定坐标系或世界坐标系。另外，在移动的机器人上需建立一个移动坐标系或局部坐标系来描述机器人的位姿。<br>&emsp;按照参考坐标系来看，刚体的位置和方向有六个独立的参数，如下图所示<br><img src="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/spatial_description.png" class="" title="图1.坐标系示意图"><br>定义$X-Y-Z$坐标系为固定坐标系，机器人在运动过程中建立的运动坐标系为$U-V-W$，很明显，如果确定了运动坐标系相对于固定坐标系的位姿，那么刚体的位姿也就知道了。刚体位姿可以通过刚体上任意一点的位姿来确定，例如原点$O$或刚体上任一点$P$。</p><h1 id="位置描述"><a href="#位置描述" class="headerlink" title="位置描述"></a>位置描述</h1><p>&emsp;运动中的刚体上任何一点$P$相对于固定坐标系的位置可以用一个三维笛卡尔向量<strong><em>P</em></strong>，如上图所示，定义点$P$在固定坐标系$F$中的坐标或向量<strong><em>P</em></strong>在固定坐标系$F$的分量为$p_x,p_y,p_z$为</p><script type="math/tex; mode=display">\left[ \mathbf{P}\right]_F=\left[                    \begin{matrix}                    p_x\\                    p_y \\                    p_z                    \end{matrix}                    \right]                    \tag{1}</script><p>这里的下表$F$表示向量<strong><em>P</em></strong>参考的固定坐标系。<br>&emsp;下表$x,y,z$分别表示向量<strong><em>P</em></strong>沿固定坐标系$X,Y,Z$三个方向的分量。<br>&emsp;向量<strong><em>P</em></strong>可以表达为：</p><script type="math/tex; mode=display">\mathbf{P}=p_x\mathbf{x}+p_y\mathbf{y}+p_z\mathbf{z} \tag{2}</script><p>这里$\mathbf{x},\mathbf{y},\mathbf{z}$分别表示沿固定坐标系$F$的$X,Y,Z$方向的单位向量，如上图所示。在固定坐标系$F$下分别写为：</p><script type="math/tex; mode=display">\left[ \mathbf{x} \right]_F\equiv\left[ \begin{matrix}1\\0\\0\end{matrix}\right],\left[ \mathbf{y} \right]_F\equiv\left[ \begin{matrix}0\\1\\0\end{matrix}\right],and \left[ \mathbf{z} \right]_F\equiv\left[ \begin{matrix}0\\0\\1\end{matrix}\right]\tag{3}</script><p><strong>注意</strong>：如果向量<strong><em>P</em></strong>参考的固定坐标系是不同于坐标系$F$的，那么，向量<strong><em>P</em></strong>的分量将会不同于参考固定坐标系$F$的分量，尽管向量<strong><em>P</em></strong>没变，因此，无论参考坐标系如何改变，向量<strong><em>P</em></strong>是不会变的，这就是所谓的坐标无关的表达方式，也可以说是与参考系是独立的。  </p><h1 id="方向描述"><a href="#方向描述" class="headerlink" title="方向描述"></a>方向描述</h1><p>&emsp;根据参考坐标系，刚体的方向可以有不同的描述方式，例如：<br>1.Direction cosine representation<br>2.Fixed-axes rotations<br>3.Euler-angles representation<br>4.Single- and double-axes rotations<br>5.Euler parameters, and others<br><strong>注意</strong>：每种描述方式都有其局限，下面具体介绍</p><h2 id="1-Direction-Cosine-Representation"><a href="#1-Direction-Cosine-Representation" class="headerlink" title="1.Direction Cosine Representation"></a>1.Direction Cosine Representation</h2><p>&emsp;为了描述刚体的方向或旋转，考虑相对于固定坐标系$F$运动的移动坐标系$M$，如图1所示。另$\mathbf{u}、\mathbf{v}、\mathbf{w}$分别表示沿运动坐标系$M$方向$U、V、W$的单位向量，由于每个单位向量$\mathbf{u}、\mathbf{v}、\mathbf{w}$表示点在坐标系$M$下距原点单位距离处的位置，因此，可以用它们各自沿固定坐标系$X、Y、Z$方向的分量来表达：</p><script type="math/tex; mode=display">\mathbf{u}=u_x\mathbf{x}+u_y\mathbf{y}+u_z\mathbf{z}\tag{4}</script><script type="math/tex; mode=display">\mathbf{v}=v_x\mathbf{x}+v_y\mathbf{y}+v_z\mathbf{z}\tag{5}</script><script type="math/tex; mode=display">\mathbf{w}=w_x\mathbf{x}+w_y\mathbf{y}+w_z\mathbf{z}\tag{6}</script><p>这里$u_x、u_y、u_z$分别表示单位向量$\mathbf{u}$沿$X、Y、Z$方向的分量，相似的，$v_x、v_y、v_z$和$w_x、w_y、w_z$分别表示单位向量$\mathbf{v}$和$\mathbf{w}$的分量。现在，如图1所示刚体上的一点$P$在运动坐标系下的表达为：</p><script type="math/tex; mode=display">\mathbf{P}=p_u\mathbf{u}+p_v\mathbf{v}+p_w\mathbf{w}\tag{7}</script><p>这里$p_u,p_v,p_w$分别是向量<strong><em>P</em></strong>沿运动坐标系$M$的坐标轴$U、V、W$的分量，把公式（4）-（6）带入公式（7）得到：</p><script type="math/tex; mode=display">\mathbf{P}=(p_uu_x+p_vv_x+p_ww_x)\mathbf{x}+(p_uu_y+p_vv_y+p_ww_y)\mathbf{y}+(p_uu_z+p_vv_z+p_ww_z)\mathbf{z}\tag{8}</script><p>对比公式（7）和（8）得到：</p><script type="math/tex; mode=display">p_x = p_uu_x+p_vv_x+p_ww_x\tag{9}</script><script type="math/tex; mode=display">p_y = p_uu_y+p_vv_y+p_ww_y\tag{10}</script><script type="math/tex; mode=display">p_z = p_uu_z+p_vv_z+p_ww_z\tag{11}</script><p>写成矩阵形式：</p><script type="math/tex; mode=display">\left[ \mathbf{p}\right]_F=\mathbf{Q}\left[ \mathbf{p}\right]_M\tag{12}</script><p>这里$\left[ \mathbf{p}\right]_F$和$\left[ \mathbf{p}\right]_M$分别表示三维向量<strong><em>P</em></strong>在坐标系$F$和$M$的分量，$\mathbf{Q}$是一个$3\times3$的旋转矩阵表示向量<strong><em>P</em></strong>从坐标系$M$到坐标系$F$的转换。它们的具体形式为：</p><script type="math/tex; mode=display">\left[ \mathbf{p} \right]_F\equiv\left[ \begin{matrix}p_x\\p_y\\p_z\end{matrix}\right],\left[ \mathbf{p} \right]_M\equiv\left[ \begin{matrix}p_u\\p_v\\p_w\end{matrix}\right],and \left[ \mathbf{Q} \right]\equiv\left[ \begin{matrix}u_x&v_x& w_x\\u_y&v_y& w_y\\u_z&v_z& w_z\end{matrix}\right]=\left[ \begin{matrix}\mathbf{u}^T\mathbf{x}&\mathbf{v}^T\mathbf{x}& \mathbf{w}^T\mathbf{x}\\\mathbf{u}^T\mathbf{y}&\mathbf{v}^T\mathbf{y}& \mathbf{w}^T\mathbf{y}\\\mathbf{u}^T\mathbf{z}&\mathbf{v}^T\mathbf{z}& \mathbf{w}^T\mathbf{z}\end{matrix}\right]\tag{13}</script><p>注意矩阵$\mathbf{Q}$的每一列都是正交的，它们是单位向量$\mathbf{u},\mathbf{v},\mathbf{w}$在坐标系$F$下的分量，而且必须满足如下的六个正交条件：</p><script type="math/tex; mode=display">\mathbf{u}^T\mathbf{u}=\mathbf{v}^T\mathbf{v}=\mathbf{w}^T\mathbf{w}=1,and\mathbf{u}^T\mathbf{v}(\equiv\mathbf{v}^T\mathbf{u})=\mathbf{u}^T\mathbf{w}(\equiv\mathbf{w}^T\mathbf{u})=\mathbf{v}^T\mathbf{w}(\equiv\mathbf{w}^T\mathbf{v})=0\tag{14}</script><p>并且，对于正交向量$\mathbf{u},\mathbf{v},\mathbf{w}$满足如下关系：</p><script type="math/tex; mode=display">\mathbf{u}\times\mathbf{v}=\mathbf{w},\mathbf{v}\times\mathbf{w}=\mathbf{u},and \mathbf{w}\times\mathbf{u}=\mathbf{v}\tag{15}</script><p>因此，$3\times3$的旋转矩阵$\mathbf{Q}$，给出了运动坐标系$M$相对于固定坐标系$F$的方位，就是所谓的正交矩阵。它有如下特性：</p><script type="math/tex; mode=display">\mathbf{Q}^T\mathbf{Q}=\mathbf{Q}\mathbf{Q}^T=1\tag{16}</script><p>这里，$det(\mathbf{Q})=1,and\ \mathbf{Q}^{-1}=\mathbf{Q}^T$，这里$\mathbf{1}$是一个$3\times3$的单位矩阵。如果需要求出坐标系$F$相对于坐标系$M$的旋转矩阵$\mathbf{Q}^\prime$，可以得到$\mathbf{Q}^\prime=\mathbf{Q}^T$，另外，我们从公式(13)中$\mathbf{Q}$矩阵的第一个元素$\mathbf{Q}_{1,1}$能够发现它是向量$\mathbf{u}$和$\mathbf{x}$的夹角余弦值，即$\mathbf{u}^T\mathbf{x}$。同样的结论对于其他各元素也成立。因此，这个旋转矩阵$\mathbf{Q}$就是直接余弦表示的旋转矩阵。这种表示法需要$3\times3$矩阵的9个参数，但是，9各参数并不是独立的，需要满足公式（14）的6个条件，因此，只有3个参数是独立的，这足以定义3个旋转自由度了。然后，这3个参数的选择是困难的，这也是直接余弦表达法的缺点。</p><h2 id="2-Fixed-axes-rotations"><a href="#2-Fixed-axes-rotations" class="headerlink" title="2.Fixed-axes rotations"></a>2.Fixed-axes rotations</h2><p>&emsp;Roll, Pitch and Yaw:围绕固定的X、Y和Z轴旋转也称为滚动、俯仰和偏航角度。这个命名法是常用于航空工程。绕着固定的惯性坐标系$F$旋转来表达运动坐标系$M$的方向，使用3个角度来表达旋转这种方式比较简单，在概念上类似于沿固定坐标系$F$的3个平移变换。坐标系$M$相对于坐标系$F$的方向由固定坐标系的3个基本旋转获得，如下图2所示。<br><img src="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/rpy.png" class="" title="图2绕固定坐标系旋转"></p><h3 id="绕XYZ轴的旋转组合"><a href="#绕XYZ轴的旋转组合" class="headerlink" title="绕XYZ轴的旋转组合"></a>绕XYZ轴的旋转组合</h3><p>&emsp;对于绕固定X、Y和Z轴的旋转，可以通过一系列基本旋转从固定坐标系F到达坐标系M，如图2所示。另$\psi,\theta\ and \ \phi$分别为绕$X-,Y-\ and \ Z-$轴的转角，总的旋转可以表达为基本旋转的组合：</p><ul><li>绕固定坐标系$F$的$X$轴旋转的角度为$\psi$，如图2(a)所示，这个旋转用旋转矩阵$\mathbf{Q}_X$表示：<script type="math/tex; mode=display">\mathbf{Q}_X\equiv\left[ \begin{matrix}1&0&0\\0&C\psi&-S\psi\\0&S\psi&C\psi\end{matrix}\right]\tag{17}</script></li><li>从当前坐标系$A$绕坐标轴$Y$旋转一个角度$\theta$，如图2(b)所示，这个旋转矩阵用$\mathbf{Q}_Y$表示：<script type="math/tex; mode=display">\mathbf{Q}_Y\equiv\left[ \begin{matrix}C\theta&0&S\theta\\0&1&0\\-S\theta&0&C\theta\end{matrix}\right]\tag{18}</script></li><li>从当前坐标系$B$绕$Z$轴旋转一个角度$\phi$，如图2(c)所示，这个旋转矩阵用$\mathbf{Q}_Z$表示：<script type="math/tex; mode=display">\mathbf{Q}_Z\equiv\left[ \begin{matrix}C\phi&-S\phi&0\\S\phi&C\phi&0\\0&0&1\end{matrix}\right]\tag{19}</script>&emsp;坐标系$F$的方向由矩阵$\mathbf{Q}$表示，方向矩阵$\mathbf{Q}$由基本旋转矩阵相乘得到：<script type="math/tex; mode=display">\mathbf{Q}=\mathbf{Q}_Z\mathbf{Q}_Y\mathbf{Q}_X\tag{20}</script>详细结果如下所示：<script type="math/tex; mode=display">\mathbf{Q}=\left[ \begin{matrix}C\theta C\phi&S\theta S\psi C\phi-C\psi S\phi&S\theta C\psi C\phi+S\psi S\phi\\ C\theta S\phi&S\theta S\psi S\phi+C\psi C\phi&S\theta C\psi S\phi-S\psi C\phi\\-S\theta&C\theta S\psi&C\theta C\psi\end{matrix}\right]\tag{21}</script>由于基本旋转不满足交换律，因此它们顺序的任何变化都会导致整体旋转矩阵$\mathbf{Q}$的不同，因此我们可以总结出12中组合，如表1所示。<img src="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/table.png" class="" title="表1"><!-- |SN|**Fixed-axes**<br>[$\psi \theta \phi$]|**Euler angles**<br>[$\phi \theta \psi$]|Rotation Matrix, Q|| :---: | :---: | :---:|:---:||Nonsymmetric sets||1|XYZ<br>[$\mathbf{Q}_Z \mathbf{Q}_Y \mathbf{Q}_X$]|ZYX<br>$\mathbf{Q}_Z\mathbf{Q}_{Y^\prime}\mathbf{Q}_{X^{\prime \prime}}$|$\left[ \begin{matrix}C\theta C\phi&S\theta S\psi C\phi-C\psi S\phi&S\theta C\psi C\phi+S\psi S\phi\\ C\theta S\phi&S\theta S\psi S\phi+C\psi C\phi& S\theta C\psi S\phi -S\psi C\phi\\ -S\theta&C\theta S\psi & C\theta C\psi \end{matrix}\right]$||2|YZX<br>[$\mathbf{Q}_X \mathbf{Q}_Z \mathbf{Q}_Y$]|XZY<br>[$\mathbf{Q}_X \mathbf{Q}_{Z^{\prime}} \mathbf{Q}_{Y^{\prime \prime}}$]|$\left[ \begin{matrix}C\theta C\psi&-S\theta&C\theta S\psi\\ C\psi S\theta C\phi+S\psi S\phi&C\theta C\phi&S\theta S\psi C\phi-C\psi S\phi\\ C\psi S\theta S\phi-S\psi C\phi&C\theta S\phi&S\theta S\psi S\phi+C\psi C\phi\end{matrix}\right]$||3|ZXY<br>[$\mathbf{Q}_Y \mathbf{Q}_X \mathbf{Q}_Z$]|YXZ<br>[$\mathbf{Q}_Y \mathbf{Q}_{X^{\prime}} \mathbf{Q}_{Z^{\prime \prime}}$]|$\left[ \begin{matrix}S\psi S\theta S\phi+C\psi C\phi&C\psi S\theta S\phi-S\psi C\phi&C\theta S\phi\\ C\theta S\psi&C\theta C\psi&-S\theta\\ S\psi S\theta C\phi-C\psi S\phi&C\psi S\theta C\phi+S\psi S\phi&C\theta C\phi\end{matrix}\right]$||4|ZYX<br>$[\mathbf{Q}_X \mathbf{Q}_Y \mathbf{Q}_Z]$|XYZ<br>$[\mathbf{Q}_X \mathbf{Q}_{Y^\prime} \mathbf{Q}_{Z^{\prime \prime}}]$|$\left[ \begin{matrix}C\theta C\psi&-C\theta S\psi&S\theta\\ C\psi S\theta S\phi+S\psi C\phi&-S\theta S\psi S\phi+C\psi C\phi&-C\theta S\phi\\ -S\theta C\psi C\phi+S\psi S\phi&S\psi S\theta C\phi+C\psi S\phi&C\theta C\phi\end{matrix}\right]$||5|XZY<br>$[\mathbf{Q}_Y \mathbf{Q}_Z \mathbf{Q}_X]$|YZX<br>$[\mathbf{Q}_Y \mathbf{Q}_{Z^\prime} \mathbf{Q}_{X^{\prime \prime}}]$|$\left[ \begin{matrix}C\theta C\phi&-C\psi S\theta C\phi+S\psi S\phi&S\theta S\psi C\phi+C\psi S\phi\\ S\theta&C\theta C\psi&-C\theta S\psi\\ -C\theta S\phi&C\psi S\theta S\phi+S\psi C\phi&-S\theta S\psi S\phi+C\psi C\phi\end{matrix}\right]$||6|YXZ<br>$[\mathbf{Q}_Z \mathbf{Q}_X \mathbf{Q}_Y]$|ZXY<br>$[\mathbf{Q}_Z \mathbf{Q}_{X^\prime} \mathbf{Q}_{Y^{\prime \prime}}]$|$\left[ \begin{matrix}-S\phi S\psi S\theta+C\phi C\psi&-C\theta S\phi&S\theta C\psi S\phi+S\psi C\phi\\ C\phi S\psi S\theta +S\phi C\psi&C\theta C\phi&-C\phi C\psi S\theta+S\phi S\psi\\ -C\theta S\psi&S\theta & C\psi C\theta\end{matrix}\right]$||Symmetric sets||7|XYX<br>$[\mathbf{Q}_X \mathbf{Q}_Y \mathbf{Q}_X]$|XYX<br>$[\mathbf{Q}_X \mathbf{Q}_{Y^\prime} \mathbf{Q}_{X^{\prime \prime}}]$|$\left[ \begin{matrix}C\theta&S\theta S\psi&S\theta C\psi\\ S\theta S\phi&-C\theta S\psi S\phi+C\psi C\phi&-C\theta C\psi S\phi-S\psi C\phi\\ -S\theta C\phi&C\theta S\psi C\phi+C\psi S\phi& C\theta C\psi C\phi-S\psi S\phi\\\end{matrix}\right]$||8|XZX<br>$[\mathbf{Q}_X \mathbf{Q}_Z \mathbf{Q}_X]$|XZX<br>$[\mathbf{Q}_X \mathbf{Q}_{Z^\prime} \mathbf{Q}_{X^{\prime \prime}}]$|$\left[ \begin{matrix} C\theta&-S\theta C\psi&S\theta S\psi\\ S\theta C\phi&C\theta C\psi C\phi-S\psi S\phi&-C\theta S\psi C\phi-C\psi S\phi\\ S\theta S\phi&C\theta C\psi S\phi +S\psi C\phi&-C\theta S\psi S\phi+C\psi C\phi\end{matrix}\right]$||9|YZY<br>$[\mathbf{Q}_Y \mathbf{Q}_Z \mathbf{Q}_Y]$|YZY<br>$[\mathbf{Q}_Y \mathbf{Q}_{Z^\prime} \mathbf{Q}_{Y^{\prime \prime}}]$|$\left[ \begin{matrix}C\theta C\psi C\phi-S\psi S\phi&-S\theta C\phi&C\theta S\psi C\phi-S\psi S\phi\\ S\theta C\psi&C\theta &S\theta S\psi\\ -C\theta C\psi S\phi-S\psi C\phi&S\theta S\phi&-C\theta S\psi S\phi+C\psi C\phi\end{matrix}\right]$||10|YXY<br>$[\mathbf{Q}_Y \mathbf{Q}_X \mathbf{Q}_Y]$|YXY<br>$[\mathbf{Q}_Y \mathbf{Q}_{X^\prime} \mathbf{Q}_{Y^{\prime \prime}}]$|$\left[ \begin{matrix} -C\theta S\psi S\phi+C\psi C\phi&S\theta S\phi&C\theta C\psi S\phi+S\psi C\phi\\ S\theta S\psi&C\theta&-S\theta C\psi\\ -C\theta S\psi C\phi-C\psi S\phi&S\theta C\phi& C\theta C\psi C\phi-S\psi S\phi\end{matrix}\right]$||11|ZXZ<br>$[\mathbf{Q}_Z \mathbf{Q}_X \mathbf{Q}_Z]$|ZXZ<br>$[\mathbf{Q}_Z \mathbf{Q}_{X^\prime} \mathbf{Q}_{Z^{\prime \prime}}]$|$\left[ \begin{matrix}-C\theta S\psi S\phi+C\psi C\phi& -C\theta C\psi S\phi-S\psi C\phi& S\theta S\phi\\ C\theta S\phi S\psi+C\psi S\phi&C\theta C\psi C\phi -S\psi S\phi&-S\theta C\phi\\ S\theta S\psi & S\theta C\psi& C\theta \end{matrix}\right]$||12|ZYZ<br>$[\mathbf{Q}_Z \mathbf{Q}_Y \mathbf{Q}_Z]$|ZYZ<br>$[\mathbf{Q}_Z \mathbf{Q}_{Y^\prime} \mathbf{Q}_{Z^{\prime \prime}}]$|$\left[ \begin{matrix}C\phi C\theta C\psi-S\phi S\psi& -C\phi C\theta S\psi-S\phi C\psi& S\theta C\phi\\ S\phi C\theta C\psi+C\phi S\psi& -S\phi C\theta S\psi+C\phi S\psi&S\theta S\phi\\ -S\theta C\psi&S\theta S\psi& C\theta\end{matrix}\right]$| --></li></ul><h2 id="3-Euler-angles-representation"><a href="#3-Euler-angles-representation" class="headerlink" title="3.Euler-angles representation"></a>3.Euler-angles representation</h2><p>&emsp;欧拉角的表示法通过组合绕当前坐标系轴旋转的基本旋转来获得，不像固定轴旋转，这里的旋转是针对当前坐标。如图3所示。如果坐标系$F$先绕$X$轴旋转，再绕$Y^\prime$，最后绕$X^{\prime \prime}$轴旋转，最后的旋转矩阵$\mathbf{Q}$可以通过组合三个绕当前坐标系的基本旋转获得，分别是$\mathbf{Q}_X,\mathbf{Q}_{Y^\prime}$和$\mathbf{Q}_{Z^{\prime \prime}}$，得到：</p><script type="math/tex; mode=display">\mathbf{Q} = \mathbf{Q}_X \mathbf{Q}_{Y^\prime} \mathbf{Q}_{Z^{\prime \prime}}\tag{22}</script><img src="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/euler-angles.png" class="" title="图3"><h3 id="ZYZ欧拉角组合"><a href="#ZYZ欧拉角组合" class="headerlink" title="ZYZ欧拉角组合"></a>ZYZ欧拉角组合</h3><p>&emsp;尽管已经有12个欧拉角组合存在，但是$ZYZ$组合也是最常用的表示法之一，如图4所示。<img src="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/zyz-euler.png" class="" title="图4">  </p><ul><li>绕固定坐标系$F$的坐标轴$Z$旋转角度$\phi$，如图4（a）所示，这个旋转用旋转矩阵$\mathbf{Q}_Z$表示：<script type="math/tex; mode=display">\mathbf{Q}_Z \equiv \left[ \begin{matrix} C\phi&-S\phi&0\\S\phi&C\phi&0\\ 0&0&1\end{matrix}\right] \tag{23}</script></li><li>绕当前坐标系$A$的$Y^\prime$轴旋转角度$\theta$，用旋转矩阵$\mathbf{Q}_{Y^\prime}$表示，如图4（b）所示：<script type="math/tex; mode=display">\mathbf{Q}_{Y^\prime} \equiv \left[ \begin{matrix} C\theta&0&S\theta\\ 0&1&0\\ -S\theta&0&C\theta\end{matrix}\right] \tag{24}</script></li><li>绕当前坐标系$B$的$Z^{\prime \prime}$轴旋转角度$\psi$，如图4（c）所示，用矩阵$\mathbf{Q}_{Z^{\prime \prime}}$表示：<script type="math/tex; mode=display">\mathbf{Q}_{Z^{\prime \prime}} \equiv \left[ \begin{matrix}C\psi&-S\psi&0\\ S\psi&C\psi&0\\0&0&1 \end{matrix}\right] \tag{25}</script>&emsp;最后坐标系$M$的方向矩阵$\mathbf{Q}$可以通过组合三个基本的旋转矩阵$\mathbf{Q}_Z,\mathbf{Q}_{Y^\prime} \ and\ \mathbf{Q}_{Z^{\prime \prime}}$获得：<script type="math/tex; mode=display">\mathbf{Q}=\mathbf{Q}_Z \mathbf{Q}_{Y^\prime} \mathbf{Q}_{Z^{\prime \prime}} \tag{26}</script>\mathbf{Q}矩阵的每个元素计算方式如下：<script type="math/tex; mode=display">\mathbf{Q}\equiv \left[ \begin{matrix}C\phi C\theta C\psi-S\phi S\psi&-C\phi C\theta S\psi-S\phi C\psi&S\theta C\phi\\ S\phi C\theta C\psi+C\phi S\psi&-S\phi C\theta S\psi+C\phi C\psi&S\theta S\phi\\ -S\theta C\psi&S\theta S\psi&C\theta \end{matrix}\right] \tag{27}</script><h2 id="4-Single-and-double-axes-rotations"><a href="#4-Single-and-double-axes-rotations" class="headerlink" title="4.Single- and double-axes rotations"></a>4.Single- and double-axes rotations</h2></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器人运动控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>差速底盘机器人运动分析</title>
    <link href="/2023/02/19/%E5%B7%AE%E9%80%9F%E5%BA%95%E7%9B%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%88%86%E6%9E%90/"/>
    <url>/2023/02/19/%E5%B7%AE%E9%80%9F%E5%BA%95%E7%9B%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="差速底盘机器人运动分析"><a href="#差速底盘机器人运动分析" class="headerlink" title="差速底盘机器人运动分析"></a>差速底盘机器人运动分析</h1><p>1.差速驱动是许多移动轮式机器人的运动控制方式<br>2.差速驱动机器人通常有两个动力轮，机器人每侧各一个，有时还有其他从动轮以防止机器人倾翻。<br>3.当两个轮子以相同的速度向相同的方向转动时，机器人沿直线运动。<br>4.当一个轮子转得比另一个轮子快时，机器人沿弧线运动。<br>5.当轮子朝以相同大小的速度向相反的方向转动时，机器人就原地转动。<br>6.我们可以正式描述机器人的行为如下：<br>&emsp;(a) 当机器人沿曲线运动时，存在一个瞬时曲率中心（ICC）。<br>&emsp;(b) 如果$r$表示曲线的半径（ICC到机器人中心的距离），$l$表示机器人的轮距，那么角速度和ICC的关系可以按如下方式推导：</p><script type="math/tex; mode=display">\omega(r+\frac{l}{2})=v_r</script><script type="math/tex; mode=display">\omega(r-\frac{l}{2})=v_l</script><p>为什么？因为角速度的定义为线速度除以曲线半径：  </p><script type="math/tex; mode=display">\frac{d\theta}{dt}=\frac{V}{r}</script><p>上式比较直观的物理的意义是：轮子离中心越远需要移动得越快才能获得与另一个轮子相同的角速度。<br>通过上式我们得到：  </p><script type="math/tex; mode=display">v_r=\omega(r+\frac{l}{2})\\=\omega r+\omega \frac{l}{2}</script><script type="math/tex; mode=display">v_l=\omega(r-\frac{l}{2})\\=\omega r-\frac{l}{2}</script><p>以上两式相减得到：</p><script type="math/tex; mode=display">v_r-v_l=\frac{2\omega l}{2}</script><script type="math/tex; mode=display">\omega = \frac{v_r-v_l}{l}</script><p>相加得到：</p><script type="math/tex; mode=display">2\omega r=v_r+v_l</script><script type="math/tex; mode=display">r=\frac{l(v_r+v_l)}{2(v_r-v_l)}</script><p>综上所述，我们发现：<br>i.角速度是车轮速度在它们分开的距离内的差异。<br>ii.如果$v_r=v_l$，那么$\omega$为0，机器人沿直线行走。<br>iii.如果$v_r=-v_l$，那么$r$为0，机器人原地旋转。</p><h2 id="机器人位姿"><a href="#机器人位姿" class="headerlink" title="机器人位姿"></a>机器人位姿</h2><p>假设机器人在运行时的位置为x,y ，并且朝向某一角度$\theta$，$\theta$是机器人坐标系$x$轴与世界坐标系$x$轴的夹角。定义$\theta=0$时机器人$x$轴与世界坐标系$x$轴一致。当机器人移动时，机器人的局部坐标系也一同移动，另$x,y,\theta$为机器人的位姿(pose)。<br><img src="/2023/02/19/%E5%B7%AE%E9%80%9F%E5%BA%95%E7%9B%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%88%86%E6%9E%90/pose.png" class="" title="机器人坐标系"></p><h2 id="前向运动学"><a href="#前向运动学" class="headerlink" title="前向运动学"></a>前向运动学</h2><p>给定一个初始位姿，机器人以角速度$\omega$在$\delta t$时间内运动，确定机器人的新位姿。<br><img src="/2023/02/19/%E5%B7%AE%E9%80%9F%E5%BA%95%E7%9B%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%88%86%E6%9E%90/new_pose.png" class="" title="确定机器人新位姿"><br>(a) 首先，注意所有变量都是时间的函数：$x(t)，y(t)，\omega(t)，V(t)，\theta(t)$。<br>(b) 然后，我们来计算ICC位于何处，得到$r$</p><h1 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h1>]]></content>
    
    
    <categories>
      
      <category>机器人运动控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线速度与角速度之间的关系</title>
    <link href="/2023/02/18/%E7%BA%BF%E9%80%9F%E5%BA%A6%E4%B8%8E%E8%A7%92%E9%80%9F%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2023/02/18/%E7%BA%BF%E9%80%9F%E5%BA%A6%E4%B8%8E%E8%A7%92%E9%80%9F%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="高中物理知识：线速度与角速度之间的关系"><a href="#高中物理知识：线速度与角速度之间的关系" class="headerlink" title="高中物理知识：线速度与角速度之间的关系"></a>高中物理知识：线速度与角速度之间的关系</h1><h2 id="1-线速度"><a href="#1-线速度" class="headerlink" title="1.线速度"></a>1.线速度</h2><img src="/2023/02/18/%E7%BA%BF%E9%80%9F%E5%BA%A6%E4%B8%8E%E8%A7%92%E9%80%9F%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/velocity.png" class="" title="线速度">  <p>物理意义：描述质点圆周运动快慢的物理量。<br>定义：质点做圆周运动通过的弧长$\Delta S$和所用时间$\Delta t$的比值叫做线速度的大小。<br>公式：$v=\frac{\Delta S}{\Delta t}$<br>单位：$m/s$<br>方向：质点在圆周某点的线速度方向沿圆周上该点的切线方向。</p><h2 id="2-角速度"><a href="#2-角速度" class="headerlink" title="2.角速度"></a>2.角速度</h2><img src="/2023/02/18/%E7%BA%BF%E9%80%9F%E5%BA%A6%E4%B8%8E%E8%A7%92%E9%80%9F%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/angular.png" class="" title="角速度">  <p>物理意义：描述质点绕圆心转动快慢的物理量。<br>定义：质点所在半径转过的角度$\Delta \theta$和所用时间$\Delta t$的比值叫做角速度。<br>公式：$\omega = \frac{\Delta \theta}{\Delta t}$<br>单位：弧度/秒 $rad/s$</p><h2 id="3-关系证明"><a href="#3-关系证明" class="headerlink" title="3.关系证明"></a>3.关系证明</h2><img src="/2023/02/18/%E7%BA%BF%E9%80%9F%E5%BA%A6%E4%B8%8E%E8%A7%92%E9%80%9F%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/prove.png" class="" title="证明">  <p>在$\Delta t$内通过的弧长为$\Delta S$，半径转过的角度为$\Delta \theta$<br>由$\Delta S=r\Delta \theta$<br>得到$v=\frac{\Delta S}{\Delta t}=\frac{r\Delta \theta}{\Delta t}=\omega r$<br>写成微分形式$\frac{d\theta}{dt}=\frac{v}{r}$</p>]]></content>
    
    
    <categories>
      
      <category>机器人运动控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux使用find统计代码行数</title>
    <link href="/2023/02/17/Linux%E4%BD%BF%E7%94%A8find%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/"/>
    <url>/2023/02/17/Linux%E4%BD%BF%E7%94%A8find%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>Linux一行代码统计项目代码行数<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> . -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*.cpp&quot;</span> -<span class="hljs-built_in">or</span> -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*.cc&quot;</span> -<span class="hljs-built_in">or</span> -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*.h&quot;</span> -<span class="hljs-built_in">or</span> -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*.hpp&quot;</span> |xargs cat|wc -l<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu18.04中ROS版本为melodic环境安装cartographer</title>
    <link href="/2023/02/17/ubuntu18-04%E4%B8%ADROS%E7%89%88%E6%9C%AC%E4%B8%BAmelodic%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85cartographer/"/>
    <url>/2023/02/17/ubuntu18-04%E4%B8%ADROS%E7%89%88%E6%9C%AC%E4%B8%BAmelodic%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85cartographer/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1.安装环境"></a>1.安装环境</h1><p>本文是在ubuntu18.04下重新安装了melodic，然后成功安装并运行了cartographer</p><h1 id="2-依赖安装"><a href="#2-依赖安装" class="headerlink" title="2.依赖安装"></a>2.依赖安装</h1><p>按照cartographer的官网提供的<a href="https://google-cartographer.readthedocs.io/en/latest/">依赖安装</a><br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment"># Install the required libraries that are available as debs.</span><br>sudo apt-get update<br>sudo apt-get install -y <span class="hljs-string">\</span><br>    clang <span class="hljs-string">\</span><br>    cmake <span class="hljs-string">\</span><br>    g++ <span class="hljs-string">\</span><br>    git <span class="hljs-string">\</span><br>    google-mock <span class="hljs-string">\</span><br>    libboost-all-dev <span class="hljs-string">\</span><br>    libcairo2-dev <span class="hljs-string">\</span><br>    libcurl4-openssl-dev <span class="hljs-string">\</span><br>    libeigen3-dev <span class="hljs-string">\</span><br>    libgflags-dev <span class="hljs-string">\</span><br>    libgoogle-glog-dev <span class="hljs-string">\</span><br>    liblua5.<span class="hljs-number">2</span>-dev <span class="hljs-string">\</span><br>    libsuitesparse-dev <span class="hljs-string">\</span><br>    lsb-release <span class="hljs-string">\</span><br>    ninja-build <span class="hljs-string">\</span><br>    stow<br></code></pre></td></tr></table></figure><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Install Ceres Solver and Protocol Buffers support if available.</span><br><span class="hljs-comment"># No need to build it ourselves.</span><br><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$(lsb_release -sc)</span>&quot;</span> = <span class="hljs-string">&quot;focal&quot;</span> || <span class="hljs-string">&quot;<span class="hljs-variable">$(lsb_release -sc)</span>&quot;</span> = <span class="hljs-string">&quot;buster&quot;</span> ]]<br>then<br>  sudo apt-<span class="hljs-built_in">get</span> install -y python3-sphinx libgmock-dev libceres-dev protobuf-compiler<br><span class="hljs-keyword">else</span><br>  sudo apt-<span class="hljs-built_in">get</span> install -y python-sphinx<br>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$(lsb_release -sc)</span>&quot;</span> = <span class="hljs-string">&quot;bionic&quot;</span> ]]<br>  then<br>    sudo apt-<span class="hljs-built_in">get</span> install -y libceres-dev<br>  fi<br>fi<br></code></pre></td></tr></table></figure></p><h1 id="3-安装abseil-cpp"><a href="#3-安装abseil-cpp" class="headerlink" title="3.安装abseil-cpp"></a>3.安装abseil-cpp</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/abseil/</span>abseil-cpp.git<br>cd abseil-cpp<br>git checkout d902eb869bcfacc1bad14933ed9af4bed006d481<br>mkdir build<br>cd build<br>cmake -G Ninja \<br>  -DCMAKE_BUILD_TYPE=Release \<br>  -DCMAKE_POSITION_INDEPENDENT_CODE=ON \<br>  -DCMAKE_INSTALL_PREFIX=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/stow/</span>absl \<br>  ..<br>ninja<br>sudo ninja install<br>cd <span class="hljs-regexp">/usr/</span>local/stow<br>sudo stow absl<br></code></pre></td></tr></table></figure><h1 id="4-安装ceres-solver"><a href="#4-安装ceres-solver" class="headerlink" title="4.安装ceres-solver"></a>4.安装ceres-solver</h1><p>在ceres-solver<a href="https://ceres-solver.googlesource.com/ceres-solver">官网</a>下载1.13.0版本<br><img src="/2023/02/17/ubuntu18-04%E4%B8%ADROS%E7%89%88%E6%9C%AC%E4%B8%BAmelodic%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85cartographer/ceres_solver_download.png" class="" title="ceres-solver下载地址"><br>解压ceres-solver，然后执行以下命令<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> ceres-solver<br><span class="hljs-keyword">mkdir</span> build<br><span class="hljs-keyword">cd</span> build<br>cmake .. -<span class="hljs-keyword">G</span> Ninja -DCXX11=<span class="hljs-keyword">ON</span><br>ninja<br>CTEST_OUTPUT_ON_FAILURE=1 ninja <span class="hljs-keyword">test</span><br>sudo ninja install<br></code></pre></td></tr></table></figure><br>这里之所以和官网安装方式不一样是因为，作者在执行git clone <a href="https://ceres-solver.googlesource.com/ceres-solver">https://ceres-solver.googlesource.com/ceres-solver</a> 这个安装命令时一直不成功，可能是网络原因</p><h1 id="5-安装protobuf"><a href="#5-安装protobuf" class="headerlink" title="5.安装protobuf"></a>5.安装protobuf</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">VERSION=<span class="hljs-string">&quot;v3.4.1&quot;</span><br><span class="hljs-comment"># Build and install proto3.</span><br>git <span class="hljs-built_in">clone</span> https://github.com/google/protobuf.git<br><span class="hljs-built_in">cd</span> protobuf<br>git checkout tags/<span class="hljs-variable">$&#123;VERSION&#125;</span><br><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br>cmake -G Ninja \<br>  -DCMAKE_POSITION_INDEPENDENT_CODE=ON \<br>  -DCMAKE_BUILD_TYPE=Release \<br>  -Dprotobuf_BUILD_TESTS=OFF \<br>  ../cmake<br>ninja<br>sudo ninja install<br></code></pre></td></tr></table></figure><h1 id="6-安装cartographer"><a href="#6-安装cartographer" class="headerlink" title="6.安装cartographer"></a>6.安装cartographer</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim">ROS_DISTRO=<span class="hljs-string">&quot;melodic&quot;</span><br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span><br>sudo apt-<span class="hljs-built_in">get</span> install -<span class="hljs-keyword">y</span> <span class="hljs-keyword">python</span>-wstool <span class="hljs-keyword">python</span>-rosdep ninja-build stow<br><span class="hljs-built_in">mkdir</span> catkin_google_ws<br><span class="hljs-keyword">cd</span> catkin_google_ws<br>wstool init src<br>wstool merge -t src https://ghproxy.<span class="hljs-keyword">com</span>/https://raw.githubusercontent.<span class="hljs-keyword">com</span>/cartographer-project/cartographer_ros/master/cartographer_ros.rosinstall<br>wstool <span class="hljs-keyword">update</span> -t src<br>src/cartographer/scripts/install_abseil.<span class="hljs-keyword">sh</span><br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> ros-$&#123;ROS_DISTRO&#125;-abseil-cpp<br>catkin_make_isolated --install --use-ninja<br></code></pre></td></tr></table></figure><h1 id="7-测试demo"><a href="#7-测试demo" class="headerlink" title="7.测试demo"></a>7.测试demo</h1><p>下载官方数据<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">wget -P ~<span class="hljs-regexp">/Downloads https:/</span><span class="hljs-regexp">/storage.googleapis.com/</span>cartographer-<span class="hljs-keyword">public</span>-data<span class="hljs-regexp">/bags/</span>backpack_2d/cartographer_paper_deutsches_museum.bag<br></code></pre></td></tr></table></figure></p><h1 id="8-运行"><a href="#8-运行" class="headerlink" title="8.运行"></a>8.运行</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_google_ws<br><span class="hljs-built_in">source</span> install_isolated/setup.sh<br>roslaunch cartographer_ros demo_backpack_2d.launch bag_filename:=<span class="hljs-variable">$&#123;HOME&#125;</span>/Downloads/cartographer_paper_deutsches_museum.bag<br></code></pre></td></tr></table></figure><h1 id="9-结果"><a href="#9-结果" class="headerlink" title="9.结果"></a>9.结果</h1><img src="/2023/02/17/ubuntu18-04%E4%B8%ADROS%E7%89%88%E6%9C%AC%E4%B8%BAmelodic%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85cartographer/museum.png" class="" title="运行结果"><h1 id="10-Cartographer-ROS-Documentation"><a href="#10-Cartographer-ROS-Documentation" class="headerlink" title="10.Cartographer ROS Documentation"></a>10.Cartographer ROS Documentation</h1><div class="row">    <embed src="google-cartographer-ros.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>cartographer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rosdepc安装</title>
    <link href="/2023/02/17/rosdepc%E5%AE%89%E8%A3%85/"/>
    <url>/2023/02/17/rosdepc%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>rosdep更新失败，使用rosdepc，原文在这<a href="https://www.guyuehome.com/35408">https://www.guyuehome.com/35408</a></p><h1 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo pip <span class="hljs-keyword">install</span> rosdepc<br>sudo apt-get <span class="hljs-keyword">install</span> python-pip <br>sudo pip <span class="hljs-keyword">install</span> rosdepc<br>sudo rosdepc init<br>rosdepc update<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu下安装glog并修改源码打印自定义logo</title>
    <link href="/2023/02/14/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85glog%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E6%89%93%E5%8D%B0%E8%87%AA%E5%AE%9A%E4%B9%89logo/"/>
    <url>/2023/02/14/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85glog%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E6%89%93%E5%8D%B0%E8%87%AA%E5%AE%9A%E4%B9%89logo/</url>
    
    <content type="html"><![CDATA[<h1 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1.下载源码"></a>1.下载源码</h1><p><a href="https://github.com/google/glog">https://github.com/google/glog</a></p><h1 id="2-解压glog-master"><a href="#2-解压glog-master" class="headerlink" title="2.解压glog-master"></a>2.解压glog-master</h1><p>unzip xxx.zip/tar -zxvf xxx.tar.gz</p><h1 id="3-编译"><a href="#3-编译" class="headerlink" title="3.编译"></a>3.编译</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd glog-master<br>mkdir build<br>cd build<br>cmake ..<br>make<br>sudo make install<br></code></pre></td></tr></table></figure><h1 id="4-生成logo代码"><a href="#4-生成logo代码" class="headerlink" title="4.生成logo代码"></a>4.生成logo代码</h1><p><a href="https://tools.kalvinbg.cn/txt/ascii">kalvin在线把logo转换成ACSII</a></p><h1 id="5-kalvin在线生成工具"><a href="#5-kalvin在线生成工具" class="headerlink" title="5.kalvin在线生成工具"></a>5.kalvin在线生成工具</h1><img src="/2023/02/14/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85glog%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E6%89%93%E5%8D%B0%E8%87%AA%E5%AE%9A%E4%B9%89logo/kalvin.png" class="" title="kalvin在线工具"><h1 id="6-修改glog源码"><a href="#6-修改glog源码" class="headerlink" title="6.修改glog源码"></a>6.修改glog源码</h1><p>在glog源码/src/logging.cc 的1265行之后插入logo生成的源码，然后重新编译glog，这样就能够在你的glog打印日志开头先打印logo了。<br><img src="/2023/02/14/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85glog%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E6%89%93%E5%8D%B0%E8%87%AA%E5%AE%9A%E4%B9%89logo/logo.png" class="" title="源码修改实例"></p>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2023/02/14/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2023/02/14/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/13/hello-world/"/>
    <url>/2023/02/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
