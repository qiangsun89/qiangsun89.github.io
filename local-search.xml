<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>rosbag包绘图工具PlotJuggler使用方法</title>
    <link href="/2023/03/29/rosbag%E5%8C%85%E7%BB%98%E5%9B%BE%E5%B7%A5%E5%85%B7PlotJuggler%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2023/03/29/rosbag%E5%8C%85%E7%BB%98%E5%9B%BE%E5%B7%A5%E5%85%B7PlotJuggler%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="rosbag包绘图工具PlotJuggler使用方法"><a href="#rosbag包绘图工具PlotJuggler使用方法" class="headerlink" title="rosbag包绘图工具PlotJuggler使用方法"></a>rosbag包绘图工具PlotJuggler使用方法</h1><p>安装：<br>ubuntu版本为melodic，如果是其他版本作相应替换<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-plotjuggler<br></code></pre></td></tr></table></figure><br>ros插件安装<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-plotjuggler-msgs ros-melodic-plotjuggler-ros<br></code></pre></td></tr></table></figure><br>使用：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">roscore</span><br></code></pre></td></tr></table></figure><br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosrun plotjuggler plotjuggler</span><br></code></pre></td></tr></table></figure></p><h1 id="绘制XY曲线"><a href="#绘制XY曲线" class="headerlink" title="绘制XY曲线"></a>绘制XY曲线</h1><p>即使PlotJuggler主要关注时间序列，也可以将共享同一时间轴的两个时间序列混合在一起。一个经典的例子是机器人的XY位置，如果想知道机器人在全局坐标系下的运动轨迹，就要将xy同时描绘出来。要激活此模式，请使用鼠标右键而不是鼠标左键拖动XY数据到figure中</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包绘图工具PlotJuggler使用方法</title>
    <link href="/2023/03/29/%E5%8C%85%E7%BB%98%E5%9B%BE%E5%B7%A5%E5%85%B7PlotJuggler%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2023/03/29/%E5%8C%85%E7%BB%98%E5%9B%BE%E5%B7%A5%E5%85%B7PlotJuggler%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ROS消息或服务无法编译生成msg/srv文件产生的头文件</title>
    <link href="/2023/03/29/ROS%E6%B6%88%E6%81%AF%E6%88%96%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90msg-srv%E6%96%87%E4%BB%B6%E4%BA%A7%E7%94%9F%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <url>/2023/03/29/ROS%E6%B6%88%E6%81%AF%E6%88%96%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90msg-srv%E6%96%87%E4%BB%B6%E4%BA%A7%E7%94%9F%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS消息或服务无法编译生成msg-srv文件产生的头文件"><a href="#ROS消息或服务无法编译生成msg-srv文件产生的头文件" class="headerlink" title="ROS消息或服务无法编译生成msg/srv文件产生的头文件"></a>ROS消息或服务无法编译生成msg/srv文件产生的头文件</h1><p><strong>问题原因：</strong><br>一般情况下，如果你的msg/srv文件是一个单独的package的话(假设为A)，在依赖A生成的头文件的packageB里面编译对应的cpp文件时，在add_dependencies的最后添加${catkin_EXPORTED_TARGETS}会包含所有在find_package里面列出的包的_generate_messages_cpp宏用来生成对应的头文件，这样编译应该是没有问题的。但是当msg/srv和需要其产生头文件的cpp文件在同一个包里面时，第一次编译会报找不到头文件的错。<br><strong>解决：</strong><br>${catkin_EXPORTED_TARGETS}这个宏之前再加一个current_package_generate_messages_cpp，current_package换成当前的包名即可。<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">add_dependencies</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_node <span class="hljs-variable">$&#123;<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125;</span> <span class="hljs-variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)<br></code></pre></td></tr></table></figure><br>其中 ${PROJECT_NAME}_node 替换为自己的ros节点名<br>例如：<br><img src="/2023/03/29/ROS%E6%B6%88%E6%81%AF%E6%88%96%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90msg-srv%E6%96%87%E4%BB%B6%E4%BA%A7%E7%94%9F%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/bug.png" class="" title="CmakeLists例子"></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS中使用rqt报错Command &#39;rqt&#39; not found</title>
    <link href="/2023/03/27/ROS%E4%B8%AD%E4%BD%BF%E7%94%A8rqt%E6%8A%A5%E9%94%99Command-rqt-not-found/"/>
    <url>/2023/03/27/ROS%E4%B8%AD%E4%BD%BF%E7%94%A8rqt%E6%8A%A5%E9%94%99Command-rqt-not-found/</url>
    
    <content type="html"><![CDATA[<p>ROS在使用rqt命令时突然报错Command ‘rqt’ not found，可能是因为不小心卸载掉了rqt，重装可解决<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-kinetic-rqt  <br>sudo apt-<span class="hljs-built_in">get</span> install ros-kinetic-rqt-graph  <br>sudo apt-<span class="hljs-built_in">get</span> install ros-kinetic-rqt-common-plugins  <br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人脱困方案简述</title>
    <link href="/2023/03/22/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%84%B1%E5%9B%B0%E6%96%B9%E6%A1%88%E7%AE%80%E8%BF%B0/"/>
    <url>/2023/03/22/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%84%B1%E5%9B%B0%E6%96%B9%E6%A1%88%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="基于ROS-navigation-进行机器人脱困方案设计"><a href="#基于ROS-navigation-进行机器人脱困方案设计" class="headerlink" title="基于ROS navigation 进行机器人脱困方案设计"></a>基于ROS navigation 进行机器人脱困方案设计</h1><p>如果机器人被困在障碍物中无法移动，基于ROS navigation进行脱困的算法设计可以考虑以下步骤：<br>1、感知环境并构建地图：机器人需要使用传感器（例如激光雷达或摄像头）来感知周围环境，并利用ROS中的SLAM算法构建地图。地图可以用来定位机器人的位置以及规划路径。  </p><p>2、确定困境：机器人需要确定自己被困的情况，例如是否被墙壁、家具或其他障碍物所包围。这可以通过检查机器人周围的传感器数据来实现。  </p><p>3、规划脱困路径：机器人需要使用ROS中的路径规划算法（例如A*算法或Dijkstra算法）来规划一条脱困路径。路径应该避开障碍物，将机器人导向可行的区域。路径规划算法可以利用机器人的当前位置和目标位置，结合地图信息，计算出最优的路径。  </p><p>4、控制机器人运动：机器人需要使用ROS中的运动控制库来控制机器人的运动，将其移动到规划好的脱困路径上。控制库可以将路径信息转换为机器人的运动指令，例如速度和转向角度。  </p><p>5、监控机器人状态：机器人需要监控自身的状态，例如位置和速度，以便在需要时进行调整。<br>6、处理异常情况：如果机器人在脱困过程中出现异常情况（例如机械故障或无法行驶），则需要使用ROS中的异常处理机制，例如自适应控制和错误恢复，来处理这些情况。  </p><p>总之，基于ROS navigation进行机器人脱困算法设计需要充分考虑机器人的感知、决策和控制能力，以及可能出现的异常情况。通过合理的算法设计和运动控制，可以让机器人成功地脱离障碍物并回到安全区域。</p><p>以下是一些关于ROS Navigation中recovery_behavior的相关英文论文：<br>1.”Recovery Behaviors for Navigation Robots in Dynamic Environments,” by Jinyong Jeong, Jonghun Park, Jangmyung Lee, and Hyun Myung. This paper proposes a set of recovery behaviors for navigation robots in dynamic environments, including obstacle avoidance and path planning.</p><p>2.”Robustness of Recovery Behaviors for Mobile Robots,” by Chen Wang and Hadas Kress-Gazit. This paper presents a framework for analyzing the robustness of recovery behaviors for mobile robots in complex environments.</p><p>3.”A Hierarchical Approach to Recovery Behaviors in Mobile Robot Navigation,” by Neil Dantam, Dave Coleman, and Sachin Chitta. This paper describes a hierarchical approach to recovery behaviors in mobile robot navigation, which allows the robot to recover from various types of failures and disturbances.</p><p>4.”Recovery Behaviors for Autonomous Mobile Robots,” by Stefano Carpin, Nicola Tomatis, and Alberto Broggi. This paper presents a set of recovery behaviors for autonomous mobile robots, including obstacle avoidance, replanning, and exploration.</p><p>5.”Recovery Behaviors for Mobile Robots in Unknown Environments,” by Jaeheung Park, Minwoo Lee, and Seungbin Moon. This paper proposes a set of recovery behaviors for mobile robots in unknown environments, including localization, path planning, and obstacle avoidance.<br>这些论文都提供了有关ROS Navigation中recovery_behavior的相关研究和应用的信息。</p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>机器人脱困</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The matrix cookbook</title>
    <link href="/2023/03/17/The-matrix-cookbook/"/>
    <url>/2023/03/17/The-matrix-cookbook/</url>
    
    <content type="html"><![CDATA[<h1 id="The-matrix-cookbook"><a href="#The-matrix-cookbook" class="headerlink" title="The matrix cookbook"></a>The matrix cookbook</h1><div class="row">    <embed src="The-Matrix-Cookbook.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cartographer仿真建图</title>
    <link href="/2023/03/16/cartographer%E4%BB%BF%E7%9C%9F%E5%BB%BA%E5%9B%BE/"/>
    <url>/2023/03/16/cartographer%E4%BB%BF%E7%9C%9F%E5%BB%BA%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="进入cartographer安装的工作空间，激活环境"><a href="#进入cartographer安装的工作空间，激活环境" class="headerlink" title="进入cartographer安装的工作空间，激活环境"></a>进入cartographer安装的工作空间，激活环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_cartographer/<br><span class="hljs-built_in">source</span> install_isolated/setup.bash<br></code></pre></td></tr></table></figure><h1 id="创建文件cartographer-demo-rplidar-launch"><a href="#创建文件cartographer-demo-rplidar-launch" class="headerlink" title="创建文件cartographer_demo_rplidar.launch"></a>创建文件cartographer_demo_rplidar.launch</h1><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">cd ~/catkin_cartographer/src/cartographer_ros/cartographer_ros/<span class="hljs-built_in">launch</span><br>cp demo_revo_lds.<span class="hljs-built_in">launch</span> cartographer_demo_rplidar.<span class="hljs-built_in">launch</span><br>gedit cartographer_demo_rplidar.<span class="hljs-built_in">launch</span><br></code></pre></td></tr></table></figure><p>并修改为以下代码：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-symbol">&lt;launch&gt;</span>  <br>  <br>  &lt;param name=<span class="hljs-string">&quot;/use_sim_time&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span> /&gt;  <br><br>  &lt;node name=<span class="hljs-string">&quot;cartographer_node&quot;</span> pkg=<span class="hljs-string">&quot;cartographer_ros&quot;</span>  <br>        <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;cartographer_node&quot;</span> <span class="hljs-keyword">args</span>=<span class="hljs-comment">&quot;  </span><br>            -configuration_directory $(<span class="hljs-keyword">find</span> cartographer_ros)/configuration_files  <br>            -configuration_basename rplidar.<span class="hljs-keyword">lua</span><span class="hljs-comment">&quot;  </span><br>        output=<span class="hljs-string">&quot;screen&quot;</span>&gt;  <br>    &lt;remap from=<span class="hljs-string">&quot;scan&quot;</span> <span class="hljs-keyword">to</span>=<span class="hljs-string">&quot;scan&quot;</span> /&gt;  <br>  &lt;/node&gt;  <br><br>  &lt;node name=<span class="hljs-string">&quot;rviz&quot;</span> pkg=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;rviz&quot;</span> required=<span class="hljs-string">&quot;true&quot;</span>  <br>        <span class="hljs-keyword">args</span>=<span class="hljs-string">&quot;-d $(find cartographer_ros)/configuration_files/demo_2d.rviz&quot;</span> /&gt;  <br>&lt;/launch&gt;<br><br></code></pre></td></tr></table></figure></p><h1 id="创建文件rplidar-lua"><a href="#创建文件rplidar-lua" class="headerlink" title="创建文件rplidar.lua"></a>创建文件rplidar.lua</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> ~/catkin_cartographer/src/cartographer_ros/cartographer_ros/configuration_files<br><span class="hljs-keyword">cp</span> revo_lds.<span class="hljs-keyword">lua</span> rplidar.<span class="hljs-keyword">lua</span><br>gedit rplidar.<span class="hljs-keyword">lua</span><br></code></pre></td></tr></table></figure><p>修改字段如下：<br>tracking_frame = “laser_link”,<br>published_frame = “laser_link”,  </p><h1 id="配置文件修改后，需要重新编译cartographer"><a href="#配置文件修改后，需要重新编译cartographer" class="headerlink" title="配置文件修改后，需要重新编译cartographer"></a>配置文件修改后，需要重新编译cartographer</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/catkin_cartographer</span><br>catkin_make_isolated <span class="hljs-params">--install</span> <span class="hljs-params">--use-ninja</span><br></code></pre></td></tr></table></figure><h1 id="启动仿真平台"><a href="#启动仿真平台" class="headerlink" title="启动仿真平台"></a>启动仿真平台</h1><p>启动仿真平台</p><h1 id="打开新的终端，启动Cartographer"><a href="#打开新的终端，启动Cartographer" class="headerlink" title="打开新的终端，启动Cartographer"></a>打开新的终端，启动Cartographer</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_cartographer<br><span class="hljs-built_in">source</span> install_isolated/setup.bash<br>roslaunch cartographer_ros cartographer_demo_rplidar.launch<br></code></pre></td></tr></table></figure><h1 id="打开新的终端，启动键盘控制，控制机器人移动"><a href="#打开新的终端，启动键盘控制，控制机器人移动" class="headerlink" title="打开新的终端，启动键盘控制，控制机器人移动"></a>打开新的终端，启动键盘控制，控制机器人移动</h1><p>键盘控制仿真机器人移动建图</p><h1 id="打开新的终端，保存地图"><a href="#打开新的终端，保存地图" class="headerlink" title="打开新的终端，保存地图"></a>打开新的终端，保存地图</h1><p>建图完成，保存地图<br>停止地图构建<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rosservice</span> call /finish_trajectory <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><br>生成.pbstream文件，文件名及其路径可修改，以下代码是我个人目录<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">rosservice <span class="hljs-keyword">call</span> <span class="hljs-regexp">/write_state /</span>home<span class="hljs-regexp">/qiang/</span>Documents/museum.pbstream <span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><br>使用catro提供文件，将.pbstream文件转为.yaml和.pgm文件<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">cd ~/catkin_cartographer<br><span class="hljs-keyword">source</span> install_isolated/setup.bash<br>rosrun cartographer_ros cartographer_pbstream_to_ros_map -map_filestem=<span class="hljs-regexp">/home/</span>qiang<span class="hljs-regexp">/Documents/mu</span>seum -pbstream_filename=<span class="hljs-regexp">/home/</span>qiang<span class="hljs-regexp">/Documents/m</span>ap/museum.pbstream -resolution=<span class="hljs-number">0.05</span><br><br></code></pre></td></tr></table></figure><br>执行完成后，将在相应目录下生成 .yaml和.pgm文件<br><a href="https://blog.csdn.net/weixin_49195458/article/details/125067284">参考文章</a></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>cartographer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下安装Octave</title>
    <link href="/2023/03/15/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85Octave/"/>
    <url>/2023/03/15/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85Octave/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu下安装Octave"><a href="#Ubuntu下安装Octave" class="headerlink" title="Ubuntu下安装Octave"></a>Ubuntu下安装Octave</h1><p>GNU Octave是一种采用高级编程语言的主要用于数值分析的软件。Octave有助于以数值方式解决线性和非线性问题，并使用与MATLAB兼容的语言进行其他数值实验。它也可以作为面向批处理的语言使用。因为它是GNU计划的一部分，所以它是GNU通用公共许可证条款下的自由软件。</p><p>打开终端<br>第一步,添加源<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">add</span>-repository <span class="hljs-keyword">pp</span><span class="hljs-variable">a:octave</span>/stable<br></code></pre></td></tr></table></figure><br>第二步,更新源<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><br>第三步,用apt-get安装octave<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install octave<br></code></pre></td></tr></table></figure><br>第四步,运行<br>在终端中输入<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">octave</span><br></code></pre></td></tr></table></figure></p><p><a href="https://www.jianshu.com/p/08c13669cc47">原文</a></p>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>How to read a research paper</title>
    <link href="/2023/03/14/How-to-read-a-research-paper/"/>
    <url>/2023/03/14/How-to-read-a-research-paper/</url>
    
    <content type="html"><![CDATA[<h1 id="How-to-read-a-research-paper"><a href="#How-to-read-a-research-paper" class="headerlink" title="How to read a research paper"></a>How to read a research paper</h1><p>Research papers are a peculiar kind of document; for the uninitiated, it will take some getting usedto. There are two types of research papers that we may read:</p><ul><li>conference papers — shorter papers (typically 6–8 pages in robotics) generally subject to peer review, written and presented in conjunction with a conference meeting.</li><li>journal papers — longer and more complete papers, subject to a more thorough peer review, and published in an (archival) journal<br>We will be reading several journal and conference papers from the robotics literature this semester. Some of the main journals and conferences in robotics are:</li><li>IEEE Transactions on Robotics and Automation</li><li>International Journal of Robotics Research</li><li>Autonomous Robots</li><li>IEEE Conference on Robotics and Automation (ICRA)</li><li>IEEE/RSJ Conference on Robots and Systems (IROS)<br>The Rensselaer library has all these journals and conference proceedings. They are available   online through the library. The library also has hardcopy up until the past few years.<br>&emsp;To search for research papers on a topic, try the INSPEC database (available through the library<br>website under Engineering databases) or try one of the following:<br><a href="http://citeseer.ist.psu.edu/">http://citeseer.ist.psu.edu/</a><br><a href="http://scholar.google.com/">http://scholar.google.com/</a><br>Many researchers (at least in the U.S.) put their papers online on their web page. Sometimes this is a better version than what you can find through the official online sources because conference proceedings often have scanned/reduced quality figures and images. However the published version is definitive<h1 id="Questions-to-ask-while-reading-a-research-paper"><a href="#Questions-to-ask-while-reading-a-research-paper" class="headerlink" title="Questions to ask while reading a research paper"></a>Questions to ask while reading a research paper</h1>It is important that you learn to read research papers critically, so here are some questions to ask yourself as you read:</li><li>What problem(s) are they solving? Why are these problems important?</li><li>What did they really do? (as opposed to what the authors say or imply they did)</li><li>What is the contribution of the work? (i.e. what is interesting or new to the field?)</li><li>What methods are they using?</li><li>Would you have solved the problem differently?</li><li>Do all the pieces of their work fit together logically?</li><li>What were the results? Did they do what they set out to do?<h1 id="Tips-on-reading-research-papers"><a href="#Tips-on-reading-research-papers" class="headerlink" title="Tips on reading research papers"></a>Tips on reading research papers</h1></li><li>You need not read a research paper sequentially from beginning to end. Here’s one possible<br>sequence:<br>– Read the title. (What is the paper about?)<br>– Read the abstract. (Should give you a concise overview of the paper.)<br>– Read the introduction. (Look for motivations, relation to other work, and a more detailed<br>overview.)<br>– Look at the structure of the paper. (What do the remaining sections address? How do<br>they fit together?)<br>– (Read the previous/related work section. (How does this work relate? What is new or<br>different about this work?))<br>– Read the conclusions. (What were their results?)<br>– Read the body of the paper. You may want to skip over all the equations the first time<br>through  </li><li>The references won’t mean much to you if you’re not familiar with the literature. Sometimes<br>important parts of the work may be contained in the references, particularly in conference<br>papers since space is limited.<br>The references are very important when you are researching a topic — they point you to<br>related research as well as the research upon which the current paper builds upon.</li><li>Sooner or later, you will come across something that you don’t understand. What can you<br>do? You should try to figure out what it is and how it is being used (even though you still<br>don’t understand it). For further reading, see the references!</li></ul>]]></content>
    
    
    <categories>
      
      <category>academic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Building Modular ROS Packages</title>
    <link href="/2023/03/10/Building-Modular-ROS-Packages/"/>
    <url>/2023/03/10/Building-Modular-ROS-Packages/</url>
    
    <content type="html"><![CDATA[<h1 id="Building-Modular-ROS-Packages"><a href="#Building-Modular-ROS-Packages" class="headerlink" title="Building Modular ROS Packages"></a>Building Modular ROS Packages</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>&emsp;The key power of the Catkin build tool is how it makes it easier to build modular software without having to keep track of the specific build products of each package. Modularity, in this case, comes in the form of building specific functionality into libraries which can be used by other packages. This tutorial is meant for someone with minimal to moderate CMake experience and minimal experience with Catkin.</p><p>&emsp;This tutorial begins by separating the executable code from the ROS C++ Hello World Tutorial into a library and building it with CMake and Catkin. If you are unfamilar with Catkin or CMake, this tutorial will make more sense after you have worked through the Gentle Introduction to Catkin.</p><p>&emsp;The next step involves creating a second package which depends on the first package and uses the functionality defined in our library. This inter-dependency then demonstrates how to use the <font color=red>catkin_package()</font> CMake function to declare exported targets for a package.</p><h2 id="Pre-Requisites"><a href="#Pre-Requisites" class="headerlink" title="Pre-Requisites"></a>Pre-Requisites</h2><ul><li>A computer running a recent Ubuntu Linix1 LTS (long-term support) installation</li><li>Minimal experience with the Linux and the command-line interface</li><li>Minimal experience with compiling C++ code</li></ul><h2 id="Tools-Used"><a href="#Tools-Used" class="headerlink" title="Tools Used"></a>Tools Used</h2><ul><li>Ubuntu Linux</li><li>The bash shell</li><li>C++</li><li>CMake</li><li>Catkin</li><li>Any plain-text editor (I like vim).</li></ul><h2 id="ROS-Packages-Used"><a href="#ROS-Packages-Used" class="headerlink" title="ROS Packages Used"></a>ROS Packages Used</h2><ul><li>roscpp</li><li>roscpp</li><li>catkin</li></ul><h2 id="Create-a-Catkin-Package"><a href="#Create-a-Catkin-Package" class="headerlink" title="Create a Catkin Package"></a>Create a Catkin Package</h2><p>Create a new directory for your package:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> src/modular_lib_pkg<br></code></pre></td></tr></table></figure><br>Add bare-bones Catkin CMakeLists.txt and package.xml files to make your directory a valid package:<br>src/modular_lib_pkg/CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Declare the version of the CMake API for forward-compatibility</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># Declare the name of the CMake Project</span><br><span class="hljs-keyword">project</span>(modular_lib_pkg)<br><br><span class="hljs-comment"># Find Catkin</span><br><span class="hljs-keyword">find_package</span>(catkin REQUIRED)<br><span class="hljs-comment"># Declare this project as a catkin package</span><br>catkin_package()<br></code></pre></td></tr></table></figure><br>src/modular_lib_pkg/package.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">package</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Package Metadata --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>modular_lib_pkg<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maintainer</span> <span class="hljs-attr">email</span>=<span class="hljs-string">&quot;you@example.com&quot;</span>&gt;</span>Your Name<span class="hljs-tag">&lt;/<span class="hljs-name">maintainer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span><br>    A ROS tutorial on modularity.<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>BSD<span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Required by Catkin --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">buildtool_depend</span>&gt;</span>catkin<span class="hljs-tag">&lt;/<span class="hljs-name">buildtool_depend</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br></code></pre></td></tr></table></figure></p><h2 id="Separating-Functionality-into-a-Library"><a href="#Separating-Functionality-into-a-Library" class="headerlink" title="Separating Functionality into a Library"></a>Separating Functionality into a Library</h2><p>&emsp;The first step in making code available for use in other ROS packages is to encapsulate its functionality into a library.</p><p>&emsp;On most operating systems, including Linux8, there are two types of libraries: static libraries and dynamic libraries. Both of these types of libraries contain compiled binary code which can be executed directly by a computer.</p><p>&emsp;Static libraries (.a for “archive” on Linux) are linked into an executable when it is built and it becomes part of that executable. When the executable is loaded, the binary code that was copied from the static library is also loaded. Dynamic libraries (.so for “shared object” on Linux), however, are not copied into the executable, and instead are loaded at runtime.</p><p>&emsp;This means not only are dynamically-linked executables smaller, but also the libraries that they depend on chan change internally without necessitating recompilation of the executable.</p><p>&emsp;In the ROS community, dynamic libraries are most commonly used, and this is what will be built by default when using Catkin.</p><h2 id="Create-the-Library-Code"><a href="#Create-the-Library-Code" class="headerlink" title="Create the Library Code"></a>Create the Library Code</h2><p>&emsp;The first step is to create the library. Our library will encapsulate the hello-world functionality used in the ROS C++ hello-world tutorial9 so that you can call a single function called say_hello() to broadcast “Hello, world!” over the /rosout topic.</p><p>&emsp;There’s nothing fundamentally different between putting C++ code in a library as opposed to an executable. What is required, however, is to split the code definition from the declaration. This involves creating two files: a header file and a source file.</p><p>&emsp;The header file should contain only what is needed by the compiler of anyone who uses the library. As such, it only needs to contain function and class delcarations, and does not need to contain function definitions.</p><p>&emsp;The header with the declaration of our say_hello() function is as follows:<br>modular_lib_pkg/include/modular_lib_pkg/hello_world.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Inclusion guard to prevent this header from being included multiple times</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MODULAR_LIB_PKG_HELLO_WORLD_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MODULAR_LIB_PKG_HELLO_WORLD_H</span><br><br><span class="hljs-comment">//! Broadcast a hello-world message over ROS_INFO</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say_hello</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><br>Next is the source or implementation file. This file should contain what is needed by the linker to connect function calls to binary code. As such, it needs to contain all of the definitions of the functions declared in the corresponding header.<br>&emsp;The source file with the definition of say_hello() is as follows:<br>modular_lib_pkg/src/hello_world.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Include the ROS C++ APIs</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say_hello</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">ROS_INFO_STREAM</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>Now that we’ve written the code for the library, we can add a rule to the CMakeLists.txt file to actually build it. Note that just like in the ROS C++ hello-world tutorial9, we need to add a dependency on roscpp in order to use ROS. This is just like adding an executable with the add_executable() CMake command: instead, we use add_library():<br>src/modular_lib_pkg/CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Declare the version of the CMake API for forward-compatibility</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># Declare the name of the CMake Project</span><br><span class="hljs-keyword">project</span>(modular_lib_pkg)<br><br><span class="hljs-comment"># Find and get all the information about the roscpp package</span><br><span class="hljs-keyword">find_package</span>(roscpp REQUIRED)<br><br><span class="hljs-comment"># Find Catkin</span><br><span class="hljs-keyword">find_package</span>(catkin REQUIRED)<br><span class="hljs-comment"># Declare this project as a catkin package</span><br>catkin_package()<br><br><span class="hljs-comment"># Add the headers from roscpp</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;roscpp_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-comment"># Define a library target called hello_world</span><br><span class="hljs-keyword">add_library</span>(hello_world src/hello_world.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><br>&emsp;Also, now that we’re using the roscpp package, we need to list it as a build- and run-dependency of our package:<br>src/modular_lib_pkg/package.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">package</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Package Metadata --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>modular_lib_pkg<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maintainer</span> <span class="hljs-attr">email</span>=<span class="hljs-string">&quot;you@example.com&quot;</span>&gt;</span>Your Name<span class="hljs-tag">&lt;/<span class="hljs-name">maintainer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span><br>    A ROS tutorial on modularity.<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>BSD<span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Required by Catkin --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">buildtool_depend</span>&gt;</span>catkin<span class="hljs-tag">&lt;/<span class="hljs-name">buildtool_depend</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Package Dependencies --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>roscpp<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">run_depend</span>&gt;</span>roscpp<span class="hljs-tag">&lt;/<span class="hljs-name">run_depend</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br></code></pre></td></tr></table></figure><br>&emsp;At this point you should be able to compile the library by running catkin_make from the root of your workspace and see the following output:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Scanning <span class="hljs-keyword">dependencies</span> of target hello_world<br>[<span class="hljs-number">100</span>%] Building CXX object modular_lib_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world.dir<span class="hljs-regexp">/src/</span>hello_world.cpp.o<br>Linking CXX shared library <span class="hljs-regexp">/tmp/</span>devel<span class="hljs-regexp">/lib/</span>libhello_world.so<br>[<span class="hljs-number">100</span>%] Built target hello_world<br></code></pre></td></tr></table></figure><br>&emsp;<strong>Notice</strong> that it built the hello_world target into a file called libhello_world.so. This is the standard naming convention for dynamic libraries on Linux. Also, it built the library into the lib subdirectory of the develspace, so when you source one of the setup files in the devel directory, it will make this library available for dynamic linking at runtime.</p><h2 id="Create-the-Node"><a href="#Create-the-Node" class="headerlink" title="Create the Node"></a>Create the Node</h2><p>&emsp;Now that we have our hello_world library, we can write a simple program to call the say_hello() function in that library. This program is nearly identical to the one used in the ROS C++ hello-world Tutorial9, except we replace the call to ROS_INFO with a call to say_hello() and we include the header file in the previous section.<br>modular_lib_pkg/src/hello_world_node.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Include the ROS C++ APIs</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><br><span class="hljs-comment">// Include the declaration of our library function</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;modular_lib_pkg/hello_world.h&gt;</span></span><br><br><span class="hljs-comment">// Standard C++ entry point</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>  <span class="hljs-comment">// Initialize ROS</span><br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;hello_world_node&quot;</span>);<br>  ros::NodeHandle nh;<br><br>  <span class="hljs-comment">// Call our library function</span><br>  <span class="hljs-built_in">say_hello</span>();<br><br>  <span class="hljs-comment">// Wait for SIGINT/Ctrl-C</span><br>  ros::<span class="hljs-built_in">spin</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>To build this node, just add an appropriate add_executable() call to the bottom of the package’s CMakeLists.txt:<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">add<span class="hljs-constructor">_executable(<span class="hljs-params">hello_world_node</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">hello_world_node</span>.<span class="hljs-params">cpp</span>)</span><br>target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">hello_world_node</span> $&#123;<span class="hljs-params">roscpp_LIBRARIES</span>&#125;)</span><br></code></pre></td></tr></table></figure></p><h2 id="Building-the-Node-and-getting-a-compiler-error"><a href="#Building-the-Node-and-getting-a-compiler-error" class="headerlink" title="Building the Node (and getting a compiler error)"></a>Building the Node (and getting a compiler error)</h2><p>&emsp;At this point, you can try to build hello_world_node with catkin_make, but you will see the following error:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[<span class="hljs-number">100</span>%] Building CXX object modular_lib_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world_node.dir<span class="hljs-regexp">/src/</span>hello_world_node.cpp.o<br><span class="hljs-regexp">/tmp/</span>src<span class="hljs-regexp">/modular_lib_pkg/</span>src<span class="hljs-regexp">/hello_world_node.cpp:5:42: fatal error: modular_lib_pkg/</span>hello_world.h: No such <span class="hljs-keyword">file</span> or directory<br>compilation terminated.<br></code></pre></td></tr></table></figure><br>&emsp;The compiler is complaining about modular_lib_pkg/hello_world.h not existing, but we know it exists! The problem isn’t that the file doesn’t exist, but rather that we haven’t told the compiler where to look for it.</p><p>&emsp;In the same way that we added the header search paths for roscpp, we also need to add our own local include directory where we put our own headers. To do so, just add the relative path to src/modular_lib_pkg/include to the existing include_directories() command in CMakeLists.txt:<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">include</span><span class="hljs-constructor">_directories(<span class="hljs-params">include</span> $&#123;<span class="hljs-params">roscpp_INCLUDE_DIRS</span>&#125;)</span><br></code></pre></td></tr></table></figure></p><h2 id="Building-the-Node-and-getting-a-linker-error"><a href="#Building-the-Node-and-getting-a-linker-error" class="headerlink" title="Building the Node (and getting a linker error)"></a>Building the Node (and getting a linker error)</h2><p>At this point, you can try to build hello_world_node with catkin_make again, but you will see another error:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">[<span class="hljs-number">100</span>%] Building CXX object modular_lib_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world_node.dir<span class="hljs-regexp">/src/</span>hello_world_node.cpp.o<br>Linking CXX executable <span class="hljs-regexp">/tmp/</span>foo<span class="hljs-regexp">/devel/</span>lib<span class="hljs-regexp">/modular_lib_pkg/</span>hello_world_node<br>CMakeFiles<span class="hljs-regexp">/hello_world_node.dir/</span>src/hello_world_node.cpp.o:hello_world_node.cpp:<span class="hljs-keyword">function</span> main: error: undefined reference to <span class="hljs-string">&#x27;say_hello()&#x27;</span><br>collect2: ld returned <span class="hljs-number">1</span> <span class="hljs-keyword">exit</span> status<br></code></pre></td></tr></table></figure><br>&emsp;This time, hello_world_node.cpp is compiled successfully, but the linker reports an error that the say_hello() function is undefined. The declaration was found in the hello_world.h header file, otherwise it wouldn’t have compiled, still the definition from hello_world.cpp was missing.</p><p>&emsp;In order to resolve this, in addition to linking against ${roscpp_LIBRARIES}, we also link hello_world_node against the hello_world target so that its symbols are defined for the linker. This is done by adding hello_world to the existing target_link_libraries() command like the following:<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">hello_world_node</span> $&#123;<span class="hljs-params">roscpp_LIBRARIES</span>&#125; <span class="hljs-params">hello_world</span>)</span><br></code></pre></td></tr></table></figure><br>The following CMakeLists.txt file contains both this and the previous modifications:<br>src/modular_lib_pkg/CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Declare the version of the CMake API for forward-compatibility</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># Declare the name of the CMake Project</span><br><span class="hljs-keyword">project</span>(modular_lib_pkg)<br><br><span class="hljs-comment"># Find and get all the information about the roscpp package</span><br><span class="hljs-keyword">find_package</span>(roscpp REQUIRED)<br><br><span class="hljs-comment"># Find Catkin</span><br><span class="hljs-keyword">find_package</span>(catkin REQUIRED)<br><span class="hljs-comment"># Declare this project as a catkin package</span><br>catkin_package()<br><br><span class="hljs-comment"># Add the local headers and the headers from roscpp</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-keyword">include</span> <span class="hljs-variable">$&#123;roscpp_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-comment"># Define a library target called hello_world</span><br><span class="hljs-keyword">add_library</span>(hello_world src/hello_world.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span>)<br><br><span class="hljs-comment"># Define an executable target called hello_world_node</span><br><span class="hljs-keyword">add_executable</span>(hello_world_node src/hello_world_node.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world_node <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span> hello_world)<br></code></pre></td></tr></table></figure></p><h2 id="Building-the-Node-and-succeeding"><a href="#Building-the-Node-and-succeeding" class="headerlink" title="Building the Node (and succeeding)"></a>Building the Node (and succeeding)</h2><p>Now you should be able to compile hello_world_node succesfully and then (assuming you sourced one of your workspace’s setup files) you can run it with rosrun:<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosrun modular_lib_pkg hello_world_node</span><br></code></pre></td></tr></table></figure><br>This node does the same thing as before, except now, the core functionality is implemented in a separate library, which could more easily be used by other packages.</p><h1 id="Using-Libraries-from-Other-Packages"><a href="#Using-Libraries-from-Other-Packages" class="headerlink" title="Using Libraries from Other Packages"></a>Using Libraries from Other Packages</h1><p>Now that we’ve created a single package with its functionality built into a library, we can create another package which also uses that functionality. In this case, we’ll create another hello_world_node in another package which also links against libhello_world.so from modular_lib_pkg.</p><h2 id="Create-the-Second-Package-and-Node"><a href="#Create-the-Second-Package-and-Node" class="headerlink" title="Create the Second Package and Node"></a>Create the Second Package and Node</h2><p>First, create a package for the new node called modular_node_pkg:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> src/modular_node_pkg<br></code></pre></td></tr></table></figure><br>Next, add the source code for our node. This code is exactly the same as the hello_world_node.cpp in the modular_lib_pkg:<br>modular_node_pkg/hello_world_node.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Include the ROS C++ APIs</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><br><span class="hljs-comment">// Include the declaration of our library function</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;modular_lib_pkg/hello_world.h&gt;</span></span><br><br><span class="hljs-comment">// Standard C++ entry point</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>  <span class="hljs-comment">// Initialize ROS</span><br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;hello_world_node&quot;</span>);<br>  ros::NodeHandle nh;<br><br>  <span class="hljs-comment">// Call our library function</span><br>  <span class="hljs-built_in">say_hello</span>();<br><br>  <span class="hljs-comment">// Wait for SIGINT/Ctrl-C</span><br>  ros::<span class="hljs-built_in">spin</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>Then add the following CMakeLists.txt and package.xml files to the new package. Note that now that we’re using the modular_lib_pkg just like we’re using the roscpp package, we need to find its headers and libraries just like we do with roscpp:<br>src/modular_node_pkg/CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Declare the version of the CMake API for forward-compatibility</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># Declare the name of the CMake Project</span><br><span class="hljs-keyword">project</span>(modular_node_pkg)<br><br><span class="hljs-comment"># Find and get all the information about the roscpp package</span><br><span class="hljs-keyword">find_package</span>(roscpp REQUIRED)<br><br><span class="hljs-comment"># Find and get all the information about the modular_lib_pkg package</span><br><span class="hljs-keyword">find_package</span>(modular_lib_pkg REQUIRED)<br><br><span class="hljs-comment"># Find Catkin</span><br><span class="hljs-keyword">find_package</span>(catkin REQUIRED)<br><span class="hljs-comment"># Declare this project as a catkin package</span><br>catkin_package()<br><br><span class="hljs-comment"># Add the headers from roscpp</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;roscpp_INCLUDE_DIRS&#125;</span> <span class="hljs-variable">$&#123;modular_lib_pkg_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-comment"># Define an executable  target called hello_world_node</span><br><span class="hljs-keyword">add_executable</span>(hello_world_node2 hello_world_node.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world_node2 <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span> <span class="hljs-variable">$&#123;modular_lib_pkg_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><br><strong>NOTE:</strong> Goofy or not, the way that Catkin works, it combines all of your packages into a single CMake project. This means that each package must have unique target names. Otherwise the world will implode and unhappiness will descend upon the land. If you don’t want to have this constraint, you can use catkin_make_isolated which will build each package in isolation, but will be slower.<br>src/modular_lib_pkg/package.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">package</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Package Metadata --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>modular_node_pkg<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maintainer</span> <span class="hljs-attr">email</span>=<span class="hljs-string">&quot;you@example.com&quot;</span>&gt;</span>Your Name<span class="hljs-tag">&lt;/<span class="hljs-name">maintainer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span><br>    A ROS tutorial on modularity.<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>BSD<span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Required by Catkin --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">buildtool_depend</span>&gt;</span>catkin<span class="hljs-tag">&lt;/<span class="hljs-name">buildtool_depend</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Package Dependencies --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>roscpp<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>modular_lib_pkg<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">run_depend</span>&gt;</span>roscpp<span class="hljs-tag">&lt;/<span class="hljs-name">run_depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">run_depend</span>&gt;</span>modular_lib_pkg<span class="hljs-tag">&lt;/<span class="hljs-name">run_depend</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br></code></pre></td></tr></table></figure><br>After creating these files, your workspace should look like the following:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── build<br>│   └── ...<br>├── devel<br>│   └── ...<br>└── <span class="hljs-attribute">src</span><br>    ├── CMakeLists<span class="hljs-selector-class">.txt</span> -&gt; /opt/ros/hydro/share/catkin/cmake/toplevel<span class="hljs-selector-class">.cmake</span><br>    ├── modular_lib_pkg<br>    │   ├── CMakeLists<span class="hljs-selector-class">.txt</span><br>    │   ├── include<br>    │   │   └── modular_lib_pkg<br>    │   │       └── hello_world<span class="hljs-selector-class">.h</span><br>    │   ├── package<span class="hljs-selector-class">.xml</span><br>    │   └── <span class="hljs-attribute">src</span><br>    │       ├── hello_world<span class="hljs-selector-class">.cpp</span><br>    │       └── hello_world_node<span class="hljs-selector-class">.cpp</span><br>    └── modular_node_pkg<br>        ├── CMakeLists<span class="hljs-selector-class">.txt</span><br>        ├── hello_world_node<span class="hljs-selector-class">.cpp</span><br>        └── package.xml<br></code></pre></td></tr></table></figure></p><h2 id="Building-the-Node-and-getting-a-compiler-error-again"><a href="#Building-the-Node-and-getting-a-compiler-error-again" class="headerlink" title="Building the Node (and getting a compiler error again)"></a>Building the Node (and getting a compiler error again)</h2><p>If you try to build yor workspace by running catkin_make at this point, you will get the same compiler error as before, but this time with the new node!<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[<span class="hljs-number">100</span>%] Building CXX object modular_node_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world_node2.dir/hello_world_node.cpp.o<br><span class="hljs-regexp">/tmp/</span>foo<span class="hljs-regexp">/src/m</span>odular_node_pkg<span class="hljs-regexp">/hello_world_node.cpp:5:41: fatal error: modular_lib_pkg/</span>hello_world.h: No such <span class="hljs-keyword">file</span> or directory<br>compilation terminated.<br></code></pre></td></tr></table></figure><br>Despite the fact that you included ${modular_lib_pkg_INCLUDE_DIRS} in the include_directories() CMake function, it still couldn’t find the header. This is because this sort of information needs to be exported by the other package.</p><p>With the current workspace, not only will ${modular_lib_pkg_INCLUDE_DIRS} be empty, but also ${modular_lib_pkg_LIBRARIES} will also be empty.</p><h2 id="Exporting-Package-Flags-to-Other-Packages"><a href="#Exporting-Package-Flags-to-Other-Packages" class="headerlink" title="Exporting Package Flags to Other Packages"></a>Exporting Package Flags to Other Packages</h2><p>In the previous secion, our second package, modular_node_pkg, was unable to get the compilation or linker flags from the first package, modular_lib_pkg. This is because the flags weren’t exported by modular_lib_pkg. With Catkin, exporting such information is done with the catkin_package() command in the CMakeLists.txt file, and in the case of modular_lib_pkg, we didn’t pass it any arguments:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">catkin_package</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><br>This function can be left empty if we don’t need to export anything, but if we do, there are several optional arguments10 and the following are most commonly used:</p><ul><li>INCLUDE_DIRS One or more header directories that should be made available to other packages. These directories are relative to the path of the given CMakeLists.txt file.</li><li>LIBRARIES One or more libraries that should be made available to other packages. These are the target names of the libraries.</li><li>CATKIN_DEPENDS One or more names of Catkin packages whose build flags should be passed transitively to any package which depends on this one. This will cause dependent packages to automatically call find_package() on each of these names.</li><li>DEPENDS One or more names of packages whose build flags should be passed transitively to any package which depends on this one. If a name like foo is given here, then Catkin will add whatever the contents of the ${foo_INCLUDE_DIRS} and ${foo_LIBRARIES} variables will be exported as part of this package’s include directories and libraries, respectively.<br>In our case, we want to export both a local include directory and a library, so we modify the catkin_package() call in the modular_lib_pkg CMakeLists.txt to export the flags for our include directory and library.</li></ul><p>Additionally, we should declare that anyone depending on this package should also use build flags from the roscpp package. This is important either if we link our library against libraries from the roscpp package or if any of our exported header files #include headers from roscpp.<br><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">catkin_package</span>(</span><br><span class="hljs-function">  <span class="hljs-variable">INCLUDE_DIRS</span> <span class="hljs-variable">include</span></span><br><span class="hljs-function">  <span class="hljs-variable">LIBRARIES</span> <span class="hljs-variable">hello_world</span></span><br><span class="hljs-function">  <span class="hljs-variable">CATKIN_DEPENDS</span> <span class="hljs-variable">roscpp</span></span><br><span class="hljs-function">  )</span><br></code></pre></td></tr></table></figure><br><strong>NOTE:</strong> In this specific case, leaving out the CATKIN_DEPENDS on roscpp won’t cause any problems, but this is only because it is unlikely that someone would try to build a ROS C++ node without depending on roscpp directly. A motivating example will be shown in the next section.<br>The complete CMakeLists.txt for modular_lib_pkg is as follows:<br>src/modular_lib_pkg/CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Declare the version of the CMake API for forward-compatibility</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment"># Declare the name of the CMake Project</span><br><span class="hljs-keyword">project</span>(modular_lib_pkg)<br><br><span class="hljs-comment"># Find and get all the information about the roscpp package</span><br><span class="hljs-keyword">find_package</span>(roscpp REQUIRED)<br><br><span class="hljs-comment"># Find Catkin</span><br><span class="hljs-keyword">find_package</span>(catkin REQUIRED)<br><span class="hljs-comment"># Declare this project as a catkin package and export the necessary build flags</span><br>catkin_package(<br>  INCLUDE_DIRS <span class="hljs-keyword">include</span><br>  LIBRARIES hello_world<br>  CATKIN_DEPENDS roscpp<br>  )<br><br><span class="hljs-comment"># Add the local headers and the headers from roscpp</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-keyword">include</span> <span class="hljs-variable">$&#123;roscpp_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-comment"># Define a library target called hello_world</span><br><span class="hljs-keyword">add_library</span>(hello_world src/hello_world.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span>)<br><br><span class="hljs-comment"># Define an executable target called hello_world_node</span><br><span class="hljs-keyword">add_executable</span>(hello_world_node src/hello_world_node.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(hello_world_node <span class="hljs-variable">$&#123;roscpp_LIBRARIES&#125;</span> hello_world)<br></code></pre></td></tr></table></figure><br>You can now build the workspace again with catkin_make, but this time it should succeed:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">[ <span class="hljs-number">33</span>%] Building CXX object modular_lib_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world.dir<span class="hljs-regexp">/src/</span>hello_world.cpp.o<br>Linking CXX shared library <span class="hljs-regexp">/tmp/</span>devel<span class="hljs-regexp">/lib/</span>libhello_world.so<br>[ <span class="hljs-number">33</span>%] Built target hello_world<br>[ <span class="hljs-number">66</span>%] Building CXX object modular_lib_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world_node.dir<span class="hljs-regexp">/src/</span>hello_world_node.cpp.o<br>Linking CXX executable <span class="hljs-regexp">/tmp/</span>devel<span class="hljs-regexp">/lib/m</span>odular_lib_pkg/hello_world_node<br>[ <span class="hljs-number">66</span>%] Built target hello_world_node<br>[<span class="hljs-number">100</span>%] Building CXX object modular_node_pkg<span class="hljs-regexp">/CMakeFiles/</span>hello_world_node2.dir/hello_world_node.cpp.o<br>Linking CXX executable <span class="hljs-regexp">/tmp/</span>devel<span class="hljs-regexp">/lib/m</span>odular_node_pkg/hello_world_node2<br>[<span class="hljs-number">100</span>%] Built target hello_world_node2<br></code></pre></td></tr></table></figure><br>And finally, (assuming you still have your workspace environment set up), you can run hello_world_node2:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rosrun</span> modular_node_pkg hello_world_node2<br></code></pre></td></tr></table></figure><br>Reference:<br><a href="https://jbohren.com/articles/modular-ros-packages">original article</a></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Why does my robot navigate too close to walls and/or cuts corners?</title>
    <link href="/2023/03/08/Why-does-my-robot-navigate-too-close-to-walls-and-or-cuts-corners/"/>
    <url>/2023/03/08/Why-does-my-robot-navigate-too-close-to-walls-and-or-cuts-corners/</url>
    
    <content type="html"><![CDATA[<h1 id="Question-Why-does-my-robot-navigate-too-close-to-walls-and-or-cuts-corners"><a href="#Question-Why-does-my-robot-navigate-too-close-to-walls-and-or-cuts-corners" class="headerlink" title="Question: Why does my robot navigate too close to walls and/or cuts corners?"></a>Question: Why does my robot navigate too close to walls and/or cuts corners?</h1><p><strong>Short Answer:</strong> Define/Increase the inflation radius in your costmap configuration.<br><strong>Long Answer:</strong> At first glance, parameter min_obstacle_dist could be increased, but this could lead to an undesired navigation behavior in small hallways or doors (see Gaps in the trajectory). The local planner “follows” a moving virtual goal on the global plan. Therefore locations of intermediate global plan position of the global plan significantly influence the spatial behavior of the local plan. By defining an inflation radius the global planner prefers plans with minimum cost and hence plans with a higher separation from walls. Note, the teb_local_planner itself does not take the inflation radius into account. The resulting motion is time-optimal w.r.t. the virtual goal. If you wish to stick much more to following the global path, refer to Global path following. If your robot hits walls, you should really increase min_obstacle_dist or setup an appropriate footprint (refer to this tutorial).</p>]]></content>
    
    
    <categories>
      
      <category>ROS QA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS-melodic在catkin build时报错catkin: command not found</title>
    <link href="/2023/03/04/ROS-melodic%E5%9C%A8catkin-build%E6%97%B6%E6%8A%A5%E9%94%99catkin-command-not-found/"/>
    <url>/2023/03/04/ROS-melodic%E5%9C%A8catkin-build%E6%97%B6%E6%8A%A5%E9%94%99catkin-command-not-found/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS-melodic在catkin-build时报错catkin-command-not-found"><a href="#ROS-melodic在catkin-build时报错catkin-command-not-found" class="headerlink" title="ROS-melodic在catkin build时报错catkin: command not found"></a>ROS-melodic在catkin build时报错catkin: command not found</h1><p>解决方法<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-catkin python-catkin-tools<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决ubuntu在apt-get install时出错Could not get lock /var/lib/dpkg/lock-frontend</title>
    <link href="/2023/03/03/%E8%A7%A3%E5%86%B3ubuntu%E5%9C%A8apt-get-install%E6%97%B6%E5%87%BA%E9%94%99Could-not-get-lock-var-lib-dpkg-lock-frontend/"/>
    <url>/2023/03/03/%E8%A7%A3%E5%86%B3ubuntu%E5%9C%A8apt-get-install%E6%97%B6%E5%87%BA%E9%94%99Could-not-get-lock-var-lib-dpkg-lock-frontend/</url>
    
    <content type="html"><![CDATA[<p>sudo apt-get install 时会报错<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">E: Could <span class="hljs-keyword">not</span> <span class="hljs-keyword">get</span> <span class="hljs-keyword">lock</span> /var/lib/dpkg/<span class="hljs-keyword">lock</span>-frontend - <span class="hljs-keyword">open</span> (<span class="hljs-number">11</span>: Resource temporarily unavailable)<br>E: Unable <span class="hljs-keyword">to</span> acquire the dpkg frontend <span class="hljs-keyword">lock</span> (/var/lib/dpkg/<span class="hljs-keyword">lock</span>-frontend), <span class="hljs-keyword">is</span> another process <span class="hljs-keyword">using</span> it?<br></code></pre></td></tr></table></figure><br>解决方法:依次执行如下命令<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/lock<br></code></pre></td></tr></table></figure><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm <span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/apt/</span>archives/lock<br></code></pre></td></tr></table></figure><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/dpkg/</span>lock*<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gazebo打不开一直卡在Preparing your world</title>
    <link href="/2023/03/03/gazebo%E6%89%93%E4%B8%8D%E5%BC%80%E4%B8%80%E7%9B%B4%E5%8D%A1%E5%9C%A8Preparing-your-world/"/>
    <url>/2023/03/03/gazebo%E6%89%93%E4%B8%8D%E5%BC%80%E4%B8%80%E7%9B%B4%E5%8D%A1%E5%9C%A8Preparing-your-world/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在运行某些程序的功能包的时候，gazebo启动的时候会一直卡在”Preparing your world”，然后就一直不动了，这是由于gazebo在下载某些模型导致的，多等上一会，或者执行下面的命令手动把模型下全，如果还是不能打开那说明要下载的模型不在这个列表里面，知道这个模型是什么可以去手动下载，如果不知道的话就只有多等一会看能不能下完打开了。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd ~<span class="hljs-regexp">/.gazebo/</span><br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/osrf/g</span>azebo_models.git models<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>gazebo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>world</title>
    <link href="/2023/03/03/world/"/>
    <url>/2023/03/03/world/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ROS-melodic升级gazebo11</title>
    <link href="/2023/03/03/ROS-melodic%E5%8D%87%E7%BA%A7gazebo11/"/>
    <url>/2023/03/03/ROS-melodic%E5%8D%87%E7%BA%A7gazebo11/</url>
    
    <content type="html"><![CDATA[<h1 id="卸载Gazebo9"><a href="#卸载Gazebo9" class="headerlink" title="卸载Gazebo9"></a>卸载Gazebo9</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> ros-melodic-gazebo*<br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> libgazebo*<br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> gazebo*<br></code></pre></td></tr></table></figure><h1 id="安装Gazebo11"><a href="#安装Gazebo11" class="headerlink" title="安装Gazebo11"></a>安装Gazebo11</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">sudo sh -c &#x27;echo <span class="hljs-string">&quot;deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main&quot;</span> &gt; /etc/apt/sources.list.d/gazebo-stable.list&#x27;<br></code></pre></td></tr></table></figure><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">wget https://packages.osrfoundation.org/gazebo.<span class="hljs-keyword">key</span> -O - | sudo apt-<span class="hljs-keyword">key</span> <span class="hljs-keyword">add</span> -<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> update<br>sudo apt-<span class="hljs-built_in">get</span> install gazebo11<br>sudo apt-<span class="hljs-built_in">get</span> install libgazebo11-dev<br>sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-gazebo11-ros-pkgs<br></code></pre></td></tr></table></figure><h1 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h1><p>终端输入<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gazebo</span><br></code></pre></td></tr></table></figure></p><h1 id="如果出现如下错误解决方法"><a href="#如果出现如下错误解决方法" class="headerlink" title="如果出现如下错误解决方法"></a>如果出现如下错误解决方法</h1><p>出错：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">VMware: vmw_ioctl_command <span class="hljs-built_in">error</span> Invalid argument<br></code></pre></td></tr></table></figure><br>解决方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export SVGA_VGPU10=0&quot;</span> &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_44732054/article/details/123430259?spm=1001.2014.3001.5501">ROS-Melodic升级Gazebo11</a><br><a href="https://blog.csdn.net/qq_40660130/article/details/124342844">VMware: vmw_ioctl_command error Invalid argument解决办法</a></p>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>gazebo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv形态学处理morphologyEx</title>
    <link href="/2023/02/22/opencv%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86morphologyEx/"/>
    <url>/2023/02/22/opencv%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86morphologyEx/</url>
    
    <content type="html"><![CDATA[<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> morph_elem = <span class="hljs-number">0</span>;<br>cv::Mat element = cv::get<span class="hljs-constructor">StructuringElement( <span class="hljs-params">morph_elem</span>, <span class="hljs-params">cv</span>::Size( 3, 3 )</span>, cv::<span class="hljs-constructor">Point( -1, -1 )</span> );<br>cv::Mat dst;<br>cv::morphology<span class="hljs-constructor">Ex( <span class="hljs-params">src</span>, <span class="hljs-params">dst</span>, 3, <span class="hljs-params">element</span> )</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>opencv</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++中fillPoly函数使用</title>
    <link href="/2023/02/22/c-%E4%B8%ADfillPoly%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/02/22/c-%E4%B8%ADfillPoly%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>fillPoly函数需要二维嵌套<code>std::vector&lt;std::vector&lt;cv::Point&gt;&gt;ppts;</code>否则无法正常使用。若使用<code>std::vector&lt;cv::Point&gt; pts</code>会导致程序中断，但不会在编译器中报错。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">cv</span>::Mat <span class="hljs-built_in">image</span> = <span class="hljs-built_in">cv</span>::Mat::ones(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>, CV_8UC3)<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">cv</span>::Point&gt; pts;<br>pts.push_back(<span class="hljs-built_in">cv</span>::Point(x, y));<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">cv</span>::Point&gt;&gt; ppts;<br>ppts.push_back(pts);<br><span class="hljs-built_in">cv</span>::fillPoly(<span class="hljs-built_in">image</span> , ppts, (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>));<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>opencv</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刚体位姿</title>
    <link href="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/"/>
    <url>/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>&emsp;刚体在三维笛卡尔空间的运动包括平移和旋转，平移用三个笛卡尔坐标，旋转用三个角坐标，因此，刚体运动需要六个坐标。机器人运动学研究的就是在空间中不断地去控制机器人的位置和方向，为了确定机器人的位置和方向，需要建立一个固定的参考坐标系，称为固定坐标系或世界坐标系。另外，在移动的机器人上需建立一个移动坐标系或局部坐标系来描述机器人的位姿。<br>&emsp;按照参考坐标系来看，刚体的位置和方向有六个独立的参数，如下图所示<br><img src="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/spatial_description.png" class="" title="图1.坐标系示意图"><br>定义$X-Y-Z$坐标系为固定坐标系，机器人在运动过程中建立的运动坐标系为$U-V-W$，很明显，如果确定了运动坐标系相对于固定坐标系的位姿，那么刚体的位姿也就知道了。刚体位姿可以通过刚体上任意一点的位姿来确定，例如原点$O$或刚体上任一点$P$。</p><h1 id="位置描述"><a href="#位置描述" class="headerlink" title="位置描述"></a>位置描述</h1><p>&emsp;运动中的刚体上任何一点$P$相对于固定坐标系的位置可以用一个三维笛卡尔向量<strong><em>P</em></strong>，如上图所示，定义点$P$在固定坐标系$F$中的坐标或向量<strong><em>P</em></strong>在固定坐标系$F$的分量为$p_x,p_y,p_z$为</p><script type="math/tex; mode=display">\left[ \mathbf{P}\right]_F=\left[                    \begin{matrix}                    p_x\\                    p_y \\                    p_z                    \end{matrix}                    \right]                    \tag{1}</script><p>这里的下表$F$表示向量<strong><em>P</em></strong>参考的固定坐标系。<br>&emsp;下表$x,y,z$分别表示向量<strong><em>P</em></strong>沿固定坐标系$X,Y,Z$三个方向的分量。<br>&emsp;向量<strong><em>P</em></strong>可以表达为：</p><script type="math/tex; mode=display">\mathbf{P}=p_x\mathbf{x}+p_y\mathbf{y}+p_z\mathbf{z} \tag{2}</script><p>这里$\mathbf{x},\mathbf{y},\mathbf{z}$分别表示沿固定坐标系$F$的$X,Y,Z$方向的单位向量，如上图所示。在固定坐标系$F$下分别写为：</p><script type="math/tex; mode=display">\left[ \mathbf{x} \right]_F\equiv\left[ \begin{matrix}1\\0\\0\end{matrix}\right],\left[ \mathbf{y} \right]_F\equiv\left[ \begin{matrix}0\\1\\0\end{matrix}\right],and \left[ \mathbf{z} \right]_F\equiv\left[ \begin{matrix}0\\0\\1\end{matrix}\right]\tag{3}</script><p><strong>注意</strong>：如果向量<strong><em>P</em></strong>参考的固定坐标系是不同于坐标系$F$的，那么，向量<strong><em>P</em></strong>的分量将会不同于参考固定坐标系$F$的分量，尽管向量<strong><em>P</em></strong>没变，因此，无论参考坐标系如何改变，向量<strong><em>P</em></strong>是不会变的，这就是所谓的坐标无关的表达方式，也可以说是与参考系是独立的。  </p><h1 id="方向描述"><a href="#方向描述" class="headerlink" title="方向描述"></a>方向描述</h1><p>&emsp;根据参考坐标系，刚体的方向可以有不同的描述方式，例如：<br>1.Direction cosine representation<br>2.Fixed-axes rotations<br>3.Euler-angles representation<br>4.Single- and double-axes rotations<br>5.Euler parameters, and others<br><strong>注意</strong>：每种描述方式都有其局限，下面具体介绍</p><h2 id="1-Direction-Cosine-Representation"><a href="#1-Direction-Cosine-Representation" class="headerlink" title="1.Direction Cosine Representation"></a>1.Direction Cosine Representation</h2><p>&emsp;为了描述刚体的方向或旋转，考虑相对于固定坐标系$F$运动的移动坐标系$M$，如图1所示。另$\mathbf{u}、\mathbf{v}、\mathbf{w}$分别表示沿运动坐标系$M$方向$U、V、W$的单位向量，由于每个单位向量$\mathbf{u}、\mathbf{v}、\mathbf{w}$表示点在坐标系$M$下距原点单位距离处的位置，因此，可以用它们各自沿固定坐标系$X、Y、Z$方向的分量来表达：</p><script type="math/tex; mode=display">\mathbf{u}=u_x\mathbf{x}+u_y\mathbf{y}+u_z\mathbf{z}\tag{4}</script><script type="math/tex; mode=display">\mathbf{v}=v_x\mathbf{x}+v_y\mathbf{y}+v_z\mathbf{z}\tag{5}</script><script type="math/tex; mode=display">\mathbf{w}=w_x\mathbf{x}+w_y\mathbf{y}+w_z\mathbf{z}\tag{6}</script><p>这里$u_x、u_y、u_z$分别表示单位向量$\mathbf{u}$沿$X、Y、Z$方向的分量，相似的，$v_x、v_y、v_z$和$w_x、w_y、w_z$分别表示单位向量$\mathbf{v}$和$\mathbf{w}$的分量。现在，如图1所示刚体上的一点$P$在运动坐标系下的表达为：</p><script type="math/tex; mode=display">\mathbf{P}=p_u\mathbf{u}+p_v\mathbf{v}+p_w\mathbf{w}\tag{7}</script><p>这里$p_u,p_v,p_w$分别是向量<strong><em>P</em></strong>沿运动坐标系$M$的坐标轴$U、V、W$的分量，把公式（4）-（6）带入公式（7）得到：</p><script type="math/tex; mode=display">\mathbf{P}=(p_uu_x+p_vv_x+p_ww_x)\mathbf{x}+(p_uu_y+p_vv_y+p_ww_y)\mathbf{y}+(p_uu_z+p_vv_z+p_ww_z)\mathbf{z}\tag{8}</script><p>对比公式（7）和（8）得到：</p><script type="math/tex; mode=display">p_x = p_uu_x+p_vv_x+p_ww_x\tag{9}</script><script type="math/tex; mode=display">p_y = p_uu_y+p_vv_y+p_ww_y\tag{10}</script><script type="math/tex; mode=display">p_z = p_uu_z+p_vv_z+p_ww_z\tag{11}</script><p>写成矩阵形式：</p><script type="math/tex; mode=display">\left[ \mathbf{p}\right]_F=\mathbf{Q}\left[ \mathbf{p}\right]_M\tag{12}</script><p>这里$\left[ \mathbf{p}\right]_F$和$\left[ \mathbf{p}\right]_M$分别表示三维向量<strong><em>P</em></strong>在坐标系$F$和$M$的分量，$\mathbf{Q}$是一个$3\times3$的旋转矩阵表示向量<strong><em>P</em></strong>从坐标系$M$到坐标系$F$的转换。它们的具体形式为：</p><script type="math/tex; mode=display">\left[ \mathbf{p} \right]_F\equiv\left[ \begin{matrix}p_x\\p_y\\p_z\end{matrix}\right],\left[ \mathbf{p} \right]_M\equiv\left[ \begin{matrix}p_u\\p_v\\p_w\end{matrix}\right],and \left[ \mathbf{Q} \right]\equiv\left[ \begin{matrix}u_x&v_x& w_x\\u_y&v_y& w_y\\u_z&v_z& w_z\end{matrix}\right]=\left[ \begin{matrix}\mathbf{u}^T\mathbf{x}&\mathbf{v}^T\mathbf{x}& \mathbf{w}^T\mathbf{x}\\\mathbf{u}^T\mathbf{y}&\mathbf{v}^T\mathbf{y}& \mathbf{w}^T\mathbf{y}\\\mathbf{u}^T\mathbf{z}&\mathbf{v}^T\mathbf{z}& \mathbf{w}^T\mathbf{z}\end{matrix}\right]\tag{13}</script><p>注意矩阵$\mathbf{Q}$的每一列都是正交的，它们是单位向量$\mathbf{u},\mathbf{v},\mathbf{w}$在坐标系$F$下的分量，而且必须满足如下的六个正交条件：</p><script type="math/tex; mode=display">\mathbf{u}^T\mathbf{u}=\mathbf{v}^T\mathbf{v}=\mathbf{w}^T\mathbf{w}=1,and\mathbf{u}^T\mathbf{v}(\equiv\mathbf{v}^T\mathbf{u})=\mathbf{u}^T\mathbf{w}(\equiv\mathbf{w}^T\mathbf{u})=\mathbf{v}^T\mathbf{w}(\equiv\mathbf{w}^T\mathbf{v})=0\tag{14}</script><p>并且，对于正交向量$\mathbf{u},\mathbf{v},\mathbf{w}$满足如下关系：</p><script type="math/tex; mode=display">\mathbf{u}\times\mathbf{v}=\mathbf{w},\mathbf{v}\times\mathbf{w}=\mathbf{u},and \mathbf{w}\times\mathbf{u}=\mathbf{v}\tag{15}</script><p>因此，$3\times3$的旋转矩阵$\mathbf{Q}$，给出了运动坐标系$M$相对于固定坐标系$F$的方位，就是所谓的正交矩阵。它有如下特性：</p><script type="math/tex; mode=display">\mathbf{Q}^T\mathbf{Q}=\mathbf{Q}\mathbf{Q}^T=1\tag{16}</script><p>这里，$det(\mathbf{Q})=1,and\ \mathbf{Q}^{-1}=\mathbf{Q}^T$，这里$\mathbf{1}$是一个$3\times3$的单位矩阵。如果需要求出坐标系$F$相对于坐标系$M$的旋转矩阵$\mathbf{Q}^\prime$，可以得到$\mathbf{Q}^\prime=\mathbf{Q}^T$，另外，我们从公式(13)中$\mathbf{Q}$矩阵的第一个元素$\mathbf{Q}_{1,1}$能够发现它是向量$\mathbf{u}$和$\mathbf{x}$的夹角余弦值，即$\mathbf{u}^T\mathbf{x}$。同样的结论对于其他各元素也成立。因此，这个旋转矩阵$\mathbf{Q}$就是直接余弦表示的旋转矩阵。这种表示法需要$3\times3$矩阵的9个参数，但是，9各参数并不是独立的，需要满足公式（14）的6个条件，因此，只有3个参数是独立的，这足以定义3个旋转自由度了。然后，这3个参数的选择是困难的，这也是直接余弦表达法的缺点。</p><h2 id="2-Fixed-axes-rotations"><a href="#2-Fixed-axes-rotations" class="headerlink" title="2.Fixed-axes rotations"></a>2.Fixed-axes rotations</h2><p>&emsp;Roll, Pitch and Yaw:围绕固定的X、Y和Z轴旋转也称为滚动、俯仰和偏航角度。这个命名法是常用于航空工程。绕着固定的惯性坐标系$F$旋转来表达运动坐标系$M$的方向，使用3个角度来表达旋转这种方式比较简单，在概念上类似于沿固定坐标系$F$的3个平移变换。坐标系$M$相对于坐标系$F$的方向由固定坐标系的3个基本旋转获得，如下图2所示。<br><img src="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/rpy.png" class="" title="图2绕固定坐标系旋转"></p><h3 id="绕XYZ轴的旋转组合"><a href="#绕XYZ轴的旋转组合" class="headerlink" title="绕XYZ轴的旋转组合"></a>绕XYZ轴的旋转组合</h3><p>&emsp;对于绕固定X、Y和Z轴的旋转，可以通过一系列基本旋转从固定坐标系F到达坐标系M，如图2所示。另$\psi,\theta\ and \ \phi$分别为绕$X-,Y-\ and \ Z-$轴的转角，总的旋转可以表达为基本旋转的组合：</p><ul><li>绕固定坐标系$F$的$X$轴旋转的角度为$\psi$，如图2(a)所示，这个旋转用旋转矩阵$\mathbf{Q}_X$表示：<script type="math/tex; mode=display">\mathbf{Q}_X\equiv\left[ \begin{matrix}1&0&0\\0&C\psi&-S\psi\\0&S\psi&C\psi\end{matrix}\right]\tag{17}</script></li><li>从当前坐标系$A$绕坐标轴$Y$旋转一个角度$\theta$，如图2(b)所示，这个旋转矩阵用$\mathbf{Q}_Y$表示：<script type="math/tex; mode=display">\mathbf{Q}_Y\equiv\left[ \begin{matrix}C\theta&0&S\theta\\0&1&0\\-S\theta&0&C\theta\end{matrix}\right]\tag{18}</script></li><li>从当前坐标系$B$绕$Z$轴旋转一个角度$\phi$，如图2(c)所示，这个旋转矩阵用$\mathbf{Q}_Z$表示：<script type="math/tex; mode=display">\mathbf{Q}_Z\equiv\left[ \begin{matrix}C\phi&-S\phi&0\\S\phi&C\phi&0\\0&0&1\end{matrix}\right]\tag{19}</script>&emsp;坐标系$F$的方向由矩阵$\mathbf{Q}$表示，方向矩阵$\mathbf{Q}$由基本旋转矩阵相乘得到：<script type="math/tex; mode=display">\mathbf{Q}=\mathbf{Q}_Z\mathbf{Q}_Y\mathbf{Q}_X\tag{20}</script>详细结果如下所示：<script type="math/tex; mode=display">\mathbf{Q}=\left[ \begin{matrix}C\theta C\phi&S\theta S\psi C\phi-C\psi S\phi&S\theta C\psi C\phi+S\psi S\phi\\ C\theta S\phi&S\theta S\psi S\phi+C\psi C\phi&S\theta C\psi S\phi-S\psi C\phi\\-S\theta&C\theta S\psi&C\theta C\psi\end{matrix}\right]\tag{21}</script>由于基本旋转不满足交换律，因此它们顺序的任何变化都会导致整体旋转矩阵$\mathbf{Q}$的不同，因此我们可以总结出12中组合，如表1所示。<img src="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/table.png" class="" title="表1"><!-- |SN|**Fixed-axes**<br>[$\psi \theta \phi$]|**Euler angles**<br>[$\phi \theta \psi$]|Rotation Matrix, Q|| :---: | :---: | :---:|:---:||Nonsymmetric sets||1|XYZ<br>[$\mathbf{Q}_Z \mathbf{Q}_Y \mathbf{Q}_X$]|ZYX<br>$\mathbf{Q}_Z\mathbf{Q}_{Y^\prime}\mathbf{Q}_{X^{\prime \prime}}$|$\left[ \begin{matrix}C\theta C\phi&S\theta S\psi C\phi-C\psi S\phi&S\theta C\psi C\phi+S\psi S\phi\\ C\theta S\phi&S\theta S\psi S\phi+C\psi C\phi& S\theta C\psi S\phi -S\psi C\phi\\ -S\theta&C\theta S\psi & C\theta C\psi \end{matrix}\right]$||2|YZX<br>[$\mathbf{Q}_X \mathbf{Q}_Z \mathbf{Q}_Y$]|XZY<br>[$\mathbf{Q}_X \mathbf{Q}_{Z^{\prime}} \mathbf{Q}_{Y^{\prime \prime}}$]|$\left[ \begin{matrix}C\theta C\psi&-S\theta&C\theta S\psi\\ C\psi S\theta C\phi+S\psi S\phi&C\theta C\phi&S\theta S\psi C\phi-C\psi S\phi\\ C\psi S\theta S\phi-S\psi C\phi&C\theta S\phi&S\theta S\psi S\phi+C\psi C\phi\end{matrix}\right]$||3|ZXY<br>[$\mathbf{Q}_Y \mathbf{Q}_X \mathbf{Q}_Z$]|YXZ<br>[$\mathbf{Q}_Y \mathbf{Q}_{X^{\prime}} \mathbf{Q}_{Z^{\prime \prime}}$]|$\left[ \begin{matrix}S\psi S\theta S\phi+C\psi C\phi&C\psi S\theta S\phi-S\psi C\phi&C\theta S\phi\\ C\theta S\psi&C\theta C\psi&-S\theta\\ S\psi S\theta C\phi-C\psi S\phi&C\psi S\theta C\phi+S\psi S\phi&C\theta C\phi\end{matrix}\right]$||4|ZYX<br>$[\mathbf{Q}_X \mathbf{Q}_Y \mathbf{Q}_Z]$|XYZ<br>$[\mathbf{Q}_X \mathbf{Q}_{Y^\prime} \mathbf{Q}_{Z^{\prime \prime}}]$|$\left[ \begin{matrix}C\theta C\psi&-C\theta S\psi&S\theta\\ C\psi S\theta S\phi+S\psi C\phi&-S\theta S\psi S\phi+C\psi C\phi&-C\theta S\phi\\ -S\theta C\psi C\phi+S\psi S\phi&S\psi S\theta C\phi+C\psi S\phi&C\theta C\phi\end{matrix}\right]$||5|XZY<br>$[\mathbf{Q}_Y \mathbf{Q}_Z \mathbf{Q}_X]$|YZX<br>$[\mathbf{Q}_Y \mathbf{Q}_{Z^\prime} \mathbf{Q}_{X^{\prime \prime}}]$|$\left[ \begin{matrix}C\theta C\phi&-C\psi S\theta C\phi+S\psi S\phi&S\theta S\psi C\phi+C\psi S\phi\\ S\theta&C\theta C\psi&-C\theta S\psi\\ -C\theta S\phi&C\psi S\theta S\phi+S\psi C\phi&-S\theta S\psi S\phi+C\psi C\phi\end{matrix}\right]$||6|YXZ<br>$[\mathbf{Q}_Z \mathbf{Q}_X \mathbf{Q}_Y]$|ZXY<br>$[\mathbf{Q}_Z \mathbf{Q}_{X^\prime} \mathbf{Q}_{Y^{\prime \prime}}]$|$\left[ \begin{matrix}-S\phi S\psi S\theta+C\phi C\psi&-C\theta S\phi&S\theta C\psi S\phi+S\psi C\phi\\ C\phi S\psi S\theta +S\phi C\psi&C\theta C\phi&-C\phi C\psi S\theta+S\phi S\psi\\ -C\theta S\psi&S\theta & C\psi C\theta\end{matrix}\right]$||Symmetric sets||7|XYX<br>$[\mathbf{Q}_X \mathbf{Q}_Y \mathbf{Q}_X]$|XYX<br>$[\mathbf{Q}_X \mathbf{Q}_{Y^\prime} \mathbf{Q}_{X^{\prime \prime}}]$|$\left[ \begin{matrix}C\theta&S\theta S\psi&S\theta C\psi\\ S\theta S\phi&-C\theta S\psi S\phi+C\psi C\phi&-C\theta C\psi S\phi-S\psi C\phi\\ -S\theta C\phi&C\theta S\psi C\phi+C\psi S\phi& C\theta C\psi C\phi-S\psi S\phi\\\end{matrix}\right]$||8|XZX<br>$[\mathbf{Q}_X \mathbf{Q}_Z \mathbf{Q}_X]$|XZX<br>$[\mathbf{Q}_X \mathbf{Q}_{Z^\prime} \mathbf{Q}_{X^{\prime \prime}}]$|$\left[ \begin{matrix} C\theta&-S\theta C\psi&S\theta S\psi\\ S\theta C\phi&C\theta C\psi C\phi-S\psi S\phi&-C\theta S\psi C\phi-C\psi S\phi\\ S\theta S\phi&C\theta C\psi S\phi +S\psi C\phi&-C\theta S\psi S\phi+C\psi C\phi\end{matrix}\right]$||9|YZY<br>$[\mathbf{Q}_Y \mathbf{Q}_Z \mathbf{Q}_Y]$|YZY<br>$[\mathbf{Q}_Y \mathbf{Q}_{Z^\prime} \mathbf{Q}_{Y^{\prime \prime}}]$|$\left[ \begin{matrix}C\theta C\psi C\phi-S\psi S\phi&-S\theta C\phi&C\theta S\psi C\phi-S\psi S\phi\\ S\theta C\psi&C\theta &S\theta S\psi\\ -C\theta C\psi S\phi-S\psi C\phi&S\theta S\phi&-C\theta S\psi S\phi+C\psi C\phi\end{matrix}\right]$||10|YXY<br>$[\mathbf{Q}_Y \mathbf{Q}_X \mathbf{Q}_Y]$|YXY<br>$[\mathbf{Q}_Y \mathbf{Q}_{X^\prime} \mathbf{Q}_{Y^{\prime \prime}}]$|$\left[ \begin{matrix} -C\theta S\psi S\phi+C\psi C\phi&S\theta S\phi&C\theta C\psi S\phi+S\psi C\phi\\ S\theta S\psi&C\theta&-S\theta C\psi\\ -C\theta S\psi C\phi-C\psi S\phi&S\theta C\phi& C\theta C\psi C\phi-S\psi S\phi\end{matrix}\right]$||11|ZXZ<br>$[\mathbf{Q}_Z \mathbf{Q}_X \mathbf{Q}_Z]$|ZXZ<br>$[\mathbf{Q}_Z \mathbf{Q}_{X^\prime} \mathbf{Q}_{Z^{\prime \prime}}]$|$\left[ \begin{matrix}-C\theta S\psi S\phi+C\psi C\phi& -C\theta C\psi S\phi-S\psi C\phi& S\theta S\phi\\ C\theta S\phi S\psi+C\psi S\phi&C\theta C\psi C\phi -S\psi S\phi&-S\theta C\phi\\ S\theta S\psi & S\theta C\psi& C\theta \end{matrix}\right]$||12|ZYZ<br>$[\mathbf{Q}_Z \mathbf{Q}_Y \mathbf{Q}_Z]$|ZYZ<br>$[\mathbf{Q}_Z \mathbf{Q}_{Y^\prime} \mathbf{Q}_{Z^{\prime \prime}}]$|$\left[ \begin{matrix}C\phi C\theta C\psi-S\phi S\psi& -C\phi C\theta S\psi-S\phi C\psi& S\theta C\phi\\ S\phi C\theta C\psi+C\phi S\psi& -S\phi C\theta S\psi+C\phi S\psi&S\theta S\phi\\ -S\theta C\psi&S\theta S\psi& C\theta\end{matrix}\right]$| --></li></ul><h2 id="3-Euler-angles-representation"><a href="#3-Euler-angles-representation" class="headerlink" title="3.Euler-angles representation"></a>3.Euler-angles representation</h2><p>&emsp;欧拉角的表示法通过组合绕当前坐标系轴旋转的基本旋转来获得，不像固定轴旋转，这里的旋转是针对当前坐标。如图3所示。如果坐标系$F$先绕$X$轴旋转，再绕$Y^\prime$，最后绕$X^{\prime \prime}$轴旋转，最后的旋转矩阵$\mathbf{Q}$可以通过组合三个绕当前坐标系的基本旋转获得，分别是$\mathbf{Q}_X,\mathbf{Q}_{Y^\prime}$和$\mathbf{Q}_{Z^{\prime \prime}}$，得到：</p><script type="math/tex; mode=display">\mathbf{Q} = \mathbf{Q}_X \mathbf{Q}_{Y^\prime} \mathbf{Q}_{Z^{\prime \prime}}\tag{22}</script><img src="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/euler-angles.png" class="" title="图3"><h3 id="ZYZ欧拉角组合"><a href="#ZYZ欧拉角组合" class="headerlink" title="ZYZ欧拉角组合"></a>ZYZ欧拉角组合</h3><p>&emsp;尽管已经有12个欧拉角组合存在，但是$ZYZ$组合也是最常用的表示法之一，如图4所示。<img src="/2023/02/21/%E5%88%9A%E4%BD%93%E4%BD%8D%E5%A7%BF/zyz-euler.png" class="" title="图4">  </p><ul><li>绕固定坐标系$F$的坐标轴$Z$旋转角度$\phi$，如图4（a）所示，这个旋转用旋转矩阵$\mathbf{Q}_Z$表示：<script type="math/tex; mode=display">\mathbf{Q}_Z \equiv \left[ \begin{matrix} C\phi&-S\phi&0\\S\phi&C\phi&0\\ 0&0&1\end{matrix}\right] \tag{23}</script></li><li>绕当前坐标系$A$的$Y^\prime$轴旋转角度$\theta$，用旋转矩阵$\mathbf{Q}_{Y^\prime}$表示，如图4（b）所示：<script type="math/tex; mode=display">\mathbf{Q}_{Y^\prime} \equiv \left[ \begin{matrix} C\theta&0&S\theta\\ 0&1&0\\ -S\theta&0&C\theta\end{matrix}\right] \tag{24}</script></li><li>绕当前坐标系$B$的$Z^{\prime \prime}$轴旋转角度$\psi$，如图4（c）所示，用矩阵$\mathbf{Q}_{Z^{\prime \prime}}$表示：<script type="math/tex; mode=display">\mathbf{Q}_{Z^{\prime \prime}} \equiv \left[ \begin{matrix}C\psi&-S\psi&0\\ S\psi&C\psi&0\\0&0&1 \end{matrix}\right] \tag{25}</script>&emsp;最后坐标系$M$的方向矩阵$\mathbf{Q}$可以通过组合三个基本的旋转矩阵$\mathbf{Q}_Z,\mathbf{Q}_{Y^\prime} \ and\ \mathbf{Q}_{Z^{\prime \prime}}$获得：<script type="math/tex; mode=display">\mathbf{Q}=\mathbf{Q}_Z \mathbf{Q}_{Y^\prime} \mathbf{Q}_{Z^{\prime \prime}} \tag{26}</script>\mathbf{Q}矩阵的每个元素计算方式如下：<script type="math/tex; mode=display">\mathbf{Q}\equiv \left[ \begin{matrix}C\phi C\theta C\psi-S\phi S\psi&-C\phi C\theta S\psi-S\phi C\psi&S\theta C\phi\\ S\phi C\theta C\psi+C\phi S\psi&-S\phi C\theta S\psi+C\phi C\psi&S\theta S\phi\\ -S\theta C\psi&S\theta S\psi&C\theta \end{matrix}\right] \tag{27}</script><h2 id="4-Single-and-double-axes-rotations"><a href="#4-Single-and-double-axes-rotations" class="headerlink" title="4.Single- and double-axes rotations"></a>4.Single- and double-axes rotations</h2></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器人运动控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2023/02/19/test/"/>
    <url>/2023/02/19/test/</url>
    
    <content type="html"><![CDATA[<h1 id="测试文章"><a href="#测试文章" class="headerlink" title="测试文章"></a>测试文章</h1><p>这是一篇测试公式是否渲染的文章  </p><script type="math/tex; mode=display">\frac{V}{r}=\omega</script>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>差速底盘机器人运动分析</title>
    <link href="/2023/02/19/%E5%B7%AE%E9%80%9F%E5%BA%95%E7%9B%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%88%86%E6%9E%90/"/>
    <url>/2023/02/19/%E5%B7%AE%E9%80%9F%E5%BA%95%E7%9B%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="差速底盘机器人运动分析"><a href="#差速底盘机器人运动分析" class="headerlink" title="差速底盘机器人运动分析"></a>差速底盘机器人运动分析</h1><p>1.差速驱动是许多移动轮式机器人的运动控制方式<br>2.差速驱动机器人通常有两个动力轮，机器人每侧各一个，有时还有其他从动轮以防止机器人倾翻。<br>3.当两个轮子以相同的速度向相同的方向转动时，机器人沿直线运动。<br>4.当一个轮子转得比另一个轮子快时，机器人沿弧线运动。<br>5.当轮子朝以相同大小的速度向相反的方向转动时，机器人就原地转动。<br>6.我们可以正式描述机器人的行为如下：<br>&emsp;(a) 当机器人沿曲线运动时，存在一个瞬时曲率中心（ICC）。<br>&emsp;(b) 如果$r$表示曲线的半径（ICC到机器人中心的距离），$l$表示机器人的轮距，那么角速度和ICC的关系可以按如下方式推导：</p><script type="math/tex; mode=display">\omega(r+\frac{l}{2})=v_r</script><script type="math/tex; mode=display">\omega(r-\frac{l}{2})=v_l</script><p>为什么？因为角速度的定义为线速度除以曲线半径：  </p><script type="math/tex; mode=display">\frac{d\theta}{dt}=\frac{V}{r}</script><p>上式比较直观的物理的意义是：轮子离中心越远需要移动得越快才能获得与另一个轮子相同的角速度。<br>通过上式我们得到：  </p><script type="math/tex; mode=display">v_r=\omega(r+\frac{l}{2})\\=\omega r+\omega \frac{l}{2}</script><script type="math/tex; mode=display">v_l=\omega(r-\frac{l}{2})\\=\omega r-\frac{l}{2}</script><p>以上两式相减得到：</p><script type="math/tex; mode=display">v_r-v_l=\frac{2\omega l}{2}</script><script type="math/tex; mode=display">\omega = \frac{v_r-v_l}{l}</script><p>相加得到：</p><script type="math/tex; mode=display">2\omega r=v_r+v_l</script><script type="math/tex; mode=display">r=\frac{l(v_r+v_l)}{2(v_r-v_l)}</script><p>综上所述，我们发现：<br>i.角速度是车轮速度在它们分开的距离内的差异。<br>ii.如果$v_r=v_l$，那么$\omega$为0，机器人沿直线行走。<br>iii.如果$v_r=-v_l$，那么$r$为0，机器人原地旋转。</p><h2 id="机器人位姿"><a href="#机器人位姿" class="headerlink" title="机器人位姿"></a>机器人位姿</h2><p>假设机器人在运行时的位置为x,y ，并且朝向某一角度$\theta$，$\theta$是机器人坐标系$x$轴与世界坐标系$x$轴的夹角。定义$\theta=0$时机器人$x$轴与世界坐标系$x$轴一致。当机器人移动时，机器人的局部坐标系也一同移动，另$x,y,\theta$为机器人的位姿(pose)。<br><img src="/2023/02/19/%E5%B7%AE%E9%80%9F%E5%BA%95%E7%9B%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%88%86%E6%9E%90/pose.png" class="" title="机器人坐标系"></p><h2 id="前向运动学"><a href="#前向运动学" class="headerlink" title="前向运动学"></a>前向运动学</h2><p>给定一个初始位姿，机器人以角速度$\omega$在$\delta t$时间内运动，确定机器人的新位姿。<br><img src="/2023/02/19/%E5%B7%AE%E9%80%9F%E5%BA%95%E7%9B%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%88%86%E6%9E%90/new_pose.png" class="" title="确定机器人新位姿"><br>(a) 首先，注意所有变量都是时间的函数：$x(t)，y(t)，\omega(t)，V(t)，\theta(t)$。<br>(b) 然后，我们来计算ICC位于何处，得到$r$</p><h1 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h1>]]></content>
    
    
    <categories>
      
      <category>机器人运动控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线速度与角速度之间的关系</title>
    <link href="/2023/02/18/%E7%BA%BF%E9%80%9F%E5%BA%A6%E4%B8%8E%E8%A7%92%E9%80%9F%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2023/02/18/%E7%BA%BF%E9%80%9F%E5%BA%A6%E4%B8%8E%E8%A7%92%E9%80%9F%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="高中物理知识：线速度与角速度之间的关系"><a href="#高中物理知识：线速度与角速度之间的关系" class="headerlink" title="高中物理知识：线速度与角速度之间的关系"></a>高中物理知识：线速度与角速度之间的关系</h1><h2 id="1-线速度"><a href="#1-线速度" class="headerlink" title="1.线速度"></a>1.线速度</h2><img src="/2023/02/18/%E7%BA%BF%E9%80%9F%E5%BA%A6%E4%B8%8E%E8%A7%92%E9%80%9F%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/velocity.png" class="" title="线速度">  <p>物理意义：描述质点圆周运动快慢的物理量。<br>定义：质点做圆周运动通过的弧长$\Delta S$和所用时间$\Delta t$的比值叫做线速度的大小。<br>公式：$v=\frac{\Delta S}{\Delta t}$<br>单位：$m/s$<br>方向：质点在圆周某点的线速度方向沿圆周上该点的切线方向。</p><h2 id="2-角速度"><a href="#2-角速度" class="headerlink" title="2.角速度"></a>2.角速度</h2><img src="/2023/02/18/%E7%BA%BF%E9%80%9F%E5%BA%A6%E4%B8%8E%E8%A7%92%E9%80%9F%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/angular.png" class="" title="角速度">  <p>物理意义：描述质点绕圆心转动快慢的物理量。<br>定义：质点所在半径转过的角度$\Delta \theta$和所用时间$\Delta t$的比值叫做角速度。<br>公式：$\omega = \frac{\Delta \theta}{\Delta t}$<br>单位：弧度/秒 $rad/s$</p><h2 id="3-关系证明"><a href="#3-关系证明" class="headerlink" title="3.关系证明"></a>3.关系证明</h2><img src="/2023/02/18/%E7%BA%BF%E9%80%9F%E5%BA%A6%E4%B8%8E%E8%A7%92%E9%80%9F%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/prove.png" class="" title="证明">  <p>在$\Delta t$内通过的弧长为$\Delta S$，半径转过的角度为$\Delta \theta$<br>由$\Delta S=r\Delta \theta$<br>得到$v=\frac{\Delta S}{\Delta t}=\frac{r\Delta \theta}{\Delta t}=\omega r$<br>写成微分形式$\frac{d\theta}{dt}=\frac{v}{r}$</p>]]></content>
    
    
    <categories>
      
      <category>机器人运动控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux使用find统计代码行数</title>
    <link href="/2023/02/17/Linux%E4%BD%BF%E7%94%A8find%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/"/>
    <url>/2023/02/17/Linux%E4%BD%BF%E7%94%A8find%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>Linux一行代码统计项目代码行数<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> . -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*.cpp&quot;</span> -<span class="hljs-built_in">or</span> -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*.cc&quot;</span> -<span class="hljs-built_in">or</span> -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*.h&quot;</span> -<span class="hljs-built_in">or</span> -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*.hpp&quot;</span> |xargs cat|wc -l<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu18.04中ROS版本为melodic环境安装cartographer</title>
    <link href="/2023/02/17/ubuntu18-04%E4%B8%ADROS%E7%89%88%E6%9C%AC%E4%B8%BAmelodic%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85cartographer/"/>
    <url>/2023/02/17/ubuntu18-04%E4%B8%ADROS%E7%89%88%E6%9C%AC%E4%B8%BAmelodic%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85cartographer/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1.安装环境"></a>1.安装环境</h1><p>本文是在ubuntu18.04下重新安装了melodic，然后成功安装并运行了cartographer</p><h1 id="2-依赖安装"><a href="#2-依赖安装" class="headerlink" title="2.依赖安装"></a>2.依赖安装</h1><p>按照cartographer的官网提供的<a href="https://google-cartographer.readthedocs.io/en/latest/">依赖安装</a><br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment"># Install the required libraries that are available as debs.</span><br>sudo apt-get update<br>sudo apt-get install -y <span class="hljs-string">\</span><br>    clang <span class="hljs-string">\</span><br>    cmake <span class="hljs-string">\</span><br>    g++ <span class="hljs-string">\</span><br>    git <span class="hljs-string">\</span><br>    google-mock <span class="hljs-string">\</span><br>    libboost-all-dev <span class="hljs-string">\</span><br>    libcairo2-dev <span class="hljs-string">\</span><br>    libcurl4-openssl-dev <span class="hljs-string">\</span><br>    libeigen3-dev <span class="hljs-string">\</span><br>    libgflags-dev <span class="hljs-string">\</span><br>    libgoogle-glog-dev <span class="hljs-string">\</span><br>    liblua5.<span class="hljs-number">2</span>-dev <span class="hljs-string">\</span><br>    libsuitesparse-dev <span class="hljs-string">\</span><br>    lsb-release <span class="hljs-string">\</span><br>    ninja-build <span class="hljs-string">\</span><br>    stow<br></code></pre></td></tr></table></figure><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Install Ceres Solver and Protocol Buffers support if available.</span><br><span class="hljs-comment"># No need to build it ourselves.</span><br><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$(lsb_release -sc)</span>&quot;</span> = <span class="hljs-string">&quot;focal&quot;</span> || <span class="hljs-string">&quot;<span class="hljs-variable">$(lsb_release -sc)</span>&quot;</span> = <span class="hljs-string">&quot;buster&quot;</span> ]]<br>then<br>  sudo apt-<span class="hljs-built_in">get</span> install -y python3-sphinx libgmock-dev libceres-dev protobuf-compiler<br><span class="hljs-keyword">else</span><br>  sudo apt-<span class="hljs-built_in">get</span> install -y python-sphinx<br>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$(lsb_release -sc)</span>&quot;</span> = <span class="hljs-string">&quot;bionic&quot;</span> ]]<br>  then<br>    sudo apt-<span class="hljs-built_in">get</span> install -y libceres-dev<br>  fi<br>fi<br></code></pre></td></tr></table></figure></p><h1 id="3-安装abseil-cpp"><a href="#3-安装abseil-cpp" class="headerlink" title="3.安装abseil-cpp"></a>3.安装abseil-cpp</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/abseil/</span>abseil-cpp.git<br>cd abseil-cpp<br>git checkout d902eb869bcfacc1bad14933ed9af4bed006d481<br>mkdir build<br>cd build<br>cmake -G Ninja \<br>  -DCMAKE_BUILD_TYPE=Release \<br>  -DCMAKE_POSITION_INDEPENDENT_CODE=ON \<br>  -DCMAKE_INSTALL_PREFIX=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/stow/</span>absl \<br>  ..<br>ninja<br>sudo ninja install<br>cd <span class="hljs-regexp">/usr/</span>local/stow<br>sudo stow absl<br></code></pre></td></tr></table></figure><h1 id="4-安装ceres-solver"><a href="#4-安装ceres-solver" class="headerlink" title="4.安装ceres-solver"></a>4.安装ceres-solver</h1><p>在ceres-solver<a href="https://ceres-solver.googlesource.com/ceres-solver">官网</a>下载1.13.0版本<br><img src="/2023/02/17/ubuntu18-04%E4%B8%ADROS%E7%89%88%E6%9C%AC%E4%B8%BAmelodic%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85cartographer/ceres_solver_download.png" class="" title="ceres-solver下载地址"><br>解压ceres-solver，然后执行以下命令<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> ceres-solver<br><span class="hljs-keyword">mkdir</span> build<br><span class="hljs-keyword">cd</span> build<br>cmake .. -<span class="hljs-keyword">G</span> Ninja -DCXX11=<span class="hljs-keyword">ON</span><br>ninja<br>CTEST_OUTPUT_ON_FAILURE=1 ninja <span class="hljs-keyword">test</span><br>sudo ninja install<br></code></pre></td></tr></table></figure><br>这里之所以和官网安装方式不一样是因为，作者在执行git clone <a href="https://ceres-solver.googlesource.com/ceres-solver">https://ceres-solver.googlesource.com/ceres-solver</a> 这个安装命令时一直不成功，可能是网络原因</p><h1 id="5-安装protobuf"><a href="#5-安装protobuf" class="headerlink" title="5.安装protobuf"></a>5.安装protobuf</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">VERSION=<span class="hljs-string">&quot;v3.4.1&quot;</span><br><span class="hljs-comment"># Build and install proto3.</span><br>git <span class="hljs-built_in">clone</span> https://github.com/google/protobuf.git<br><span class="hljs-built_in">cd</span> protobuf<br>git checkout tags/<span class="hljs-variable">$&#123;VERSION&#125;</span><br><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br>cmake -G Ninja \<br>  -DCMAKE_POSITION_INDEPENDENT_CODE=ON \<br>  -DCMAKE_BUILD_TYPE=Release \<br>  -Dprotobuf_BUILD_TESTS=OFF \<br>  ../cmake<br>ninja<br>sudo ninja install<br></code></pre></td></tr></table></figure><h1 id="6-安装cartographer"><a href="#6-安装cartographer" class="headerlink" title="6.安装cartographer"></a>6.安装cartographer</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim">ROS_DISTRO=<span class="hljs-string">&quot;melodic&quot;</span><br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span><br>sudo apt-<span class="hljs-built_in">get</span> install -<span class="hljs-keyword">y</span> <span class="hljs-keyword">python</span>-wstool <span class="hljs-keyword">python</span>-rosdep ninja-build stow<br><span class="hljs-built_in">mkdir</span> catkin_google_ws<br><span class="hljs-keyword">cd</span> catkin_google_ws<br>wstool init src<br>wstool merge -t src https://ghproxy.<span class="hljs-keyword">com</span>/https://raw.githubusercontent.<span class="hljs-keyword">com</span>/cartographer-project/cartographer_ros/master/cartographer_ros.rosinstall<br>wstool <span class="hljs-keyword">update</span> -t src<br>src/cartographer/scripts/install_abseil.<span class="hljs-keyword">sh</span><br>sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> ros-$&#123;ROS_DISTRO&#125;-abseil-cpp<br>catkin_make_isolated --install --use-ninja<br></code></pre></td></tr></table></figure><h1 id="7-测试demo"><a href="#7-测试demo" class="headerlink" title="7.测试demo"></a>7.测试demo</h1><p>下载官方数据<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">wget -P ~<span class="hljs-regexp">/Downloads https:/</span><span class="hljs-regexp">/storage.googleapis.com/</span>cartographer-<span class="hljs-keyword">public</span>-data<span class="hljs-regexp">/bags/</span>backpack_2d/cartographer_paper_deutsches_museum.bag<br></code></pre></td></tr></table></figure></p><h1 id="8-运行"><a href="#8-运行" class="headerlink" title="8.运行"></a>8.运行</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_google_ws<br><span class="hljs-built_in">source</span> install_isolated/setup.sh<br>roslaunch cartographer_ros demo_backpack_2d.launch bag_filename:=<span class="hljs-variable">$&#123;HOME&#125;</span>/Downloads/cartographer_paper_deutsches_museum.bag<br></code></pre></td></tr></table></figure><h1 id="9-结果"><a href="#9-结果" class="headerlink" title="9.结果"></a>9.结果</h1><img src="/2023/02/17/ubuntu18-04%E4%B8%ADROS%E7%89%88%E6%9C%AC%E4%B8%BAmelodic%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85cartographer/museum.png" class="" title="运行结果"><h1 id="10-Cartographer-ROS-Documentation"><a href="#10-Cartographer-ROS-Documentation" class="headerlink" title="10.Cartographer ROS Documentation"></a>10.Cartographer ROS Documentation</h1><div class="row">    <embed src="google-cartographer-ros.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>slam</category>
      
      <category>cartographer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rosdepc安装</title>
    <link href="/2023/02/17/rosdepc%E5%AE%89%E8%A3%85/"/>
    <url>/2023/02/17/rosdepc%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>rosdep更新失败，使用rosdepc，原文在这<a href="https://www.guyuehome.com/35408">https://www.guyuehome.com/35408</a></p><h1 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo pip <span class="hljs-keyword">install</span> rosdepc<br>sudo apt-get <span class="hljs-keyword">install</span> python-pip <br>sudo pip <span class="hljs-keyword">install</span> rosdepc<br>sudo rosdepc init<br>rosdepc update<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu下安装glog并修改源码打印自定义logo</title>
    <link href="/2023/02/14/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85glog%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E6%89%93%E5%8D%B0%E8%87%AA%E5%AE%9A%E4%B9%89logo/"/>
    <url>/2023/02/14/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85glog%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E6%89%93%E5%8D%B0%E8%87%AA%E5%AE%9A%E4%B9%89logo/</url>
    
    <content type="html"><![CDATA[<h1 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1.下载源码"></a>1.下载源码</h1><p><a href="https://github.com/google/glog">https://github.com/google/glog</a></p><h1 id="2-解压glog-master"><a href="#2-解压glog-master" class="headerlink" title="2.解压glog-master"></a>2.解压glog-master</h1><p>unzip xxx.zip/tar -zxvf xxx.tar.gz</p><h1 id="3-编译"><a href="#3-编译" class="headerlink" title="3.编译"></a>3.编译</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd glog-master<br>mkdir build<br>cd build<br>cmake ..<br>make<br>sudo make install<br></code></pre></td></tr></table></figure><h1 id="4-生成logo代码"><a href="#4-生成logo代码" class="headerlink" title="4.生成logo代码"></a>4.生成logo代码</h1><p><a href="https://tools.kalvinbg.cn/txt/ascii">kalvin在线把logo转换成ACSII</a></p><h1 id="5-kalvin在线生成工具"><a href="#5-kalvin在线生成工具" class="headerlink" title="5.kalvin在线生成工具"></a>5.kalvin在线生成工具</h1><img src="/2023/02/14/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85glog%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E6%89%93%E5%8D%B0%E8%87%AA%E5%AE%9A%E4%B9%89logo/kalvin.png" class="" title="kalvin在线工具"><h1 id="6-修改glog源码"><a href="#6-修改glog源码" class="headerlink" title="6.修改glog源码"></a>6.修改glog源码</h1><p>在glog源码/src/logging.cc 的1265行之后插入logo生成的源码，然后重新编译glog，这样就能够在你的glog打印日志开头先打印logo了。<br><img src="/2023/02/14/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85glog%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E6%89%93%E5%8D%B0%E8%87%AA%E5%AE%9A%E4%B9%89logo/logo.png" class="" title="源码修改实例"></p>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2023/02/14/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2023/02/14/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/13/hello-world/"/>
    <url>/2023/02/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
